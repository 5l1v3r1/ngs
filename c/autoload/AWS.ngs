{
	# WIP, don't use!

	# TODO: order res_instances so that for example delete() dry run and real run would be consistent

	AWS = true

	F stdlib_aws_tags(h:Hash) h.map(F(k, v) "Key=${k},Value=${v}")

	# --------------------------------------------------
	type AwsCommand

	F init(c:AwsCommand, cmd:Arr, supports_filters:Bool) {
		c.cmd = cmd
		c.supports_filters = supports_filters
	}


	# --------------------------------------------------
	type AwsResource

	F init(r:AwsResource, ancor, desired_props:Hash) {
		# TODO: special case: ancor is Null - always create the resource?
		assert(ancor.Bool(), "Ancor must contain something")
		r.ancor = ancor
		r.desired_props = desired_props
		r.cur_props = null
		r.desired_count = try r.desired_props.META.count catch(e) 1
		r.dry_run = try desired_props.META.dry_run catch(e) false
		if 'DRY_RUN' in ENV {
			r.dry_run = true
		}
	}

	F init(r:AwsResource, ancor) init(r, ancor, {})

	F expect(r:AwsResource, e:Int) {
		r.find()
		assert(r.len() == e, "Expected exactly ${e} ${r.typeof().name} resource instances but found ${r.len()}")
		r
	}

	F expect(r:AwsResource) {
		r.find()
		assert(r.len() > 0, "Expected one or more ${r.typeof().name} resource instances but found none")
		r
	}

	F find(r:AwsResource) {
		# XXX: invalid code because misses straightening
		cmd = _find_cmd(r)
		c = cmd.cmd
		filters = if cmd.supports_filters {
			['--filters', *(r.ancor.map(F(k, v) "Name=tag-key,Values=${k},Name=tag-value,Values=${v}"))]
		} else {
			[]
		}
		debug("Filters: $filters")
		cur_props = ``$*c $*filters``

		# echo("cur_props $cur_props")
		if not(cmd.supports_filters) {
			# manual filter then
			cur_props .= filter(F(x) r.ancor.all(F(k, v) try r.Tags[k] == v))
		}
		log("[find] found ${cur_props.len()} ${r.typeof().name} resource instances for ancor ${r.ancor}")

		r.cur_props = cur_props
		r.cur_props
	}

	F converge(r:AwsResource) {
		r.validate()
		r.find()
		n = r.desired_count
		log("[converge] desired count of ${r.typeof().name}: ${n}")
		if n < r.cur_props.len() {
			log("[converge] deleting extra resource instances")
			r.cur_props[n..null].each(F(x) r.delete(x))
			r.cur_props = r.cur_props[0..n]
		}
		if n > r.cur_props.len() {
			for(i=r.cur_props.len(); i<n; i+=1) {
				log("[converge] creating resource instance ${r.typeof().name} #${i+1}")
				create(r)
			}
		}
		r.cur_props.each(F(x) r.update(x))
	}

	F run(r:AwsResource, log_pfx:Str, cmd:Command) {
		if r.dry_run {
			log("[${log_pfx}] would run: ${cmd.argv.join(' ')}")
		} else {
			log("[${log_pfx}] running: ${cmd.argv.join(' ')}")
			$($cmd)
		}
	}

	F len(r:AwsResource) r.cur_props.len()

	# --------------------------------------------------
	type AwsElb(AwsResource)

	F find(r:AwsElb) {
		log("[find] load balancer '${r.ancor}'")
		r.cur_props = ``aws elb describe-load-balancers``.filter(F(desc) desc.LoadBalancerName == r.ancor)
		assert(r.cur_props.len() <= 1, "Can only work with one load balancer at a time")
		r.cur_props .= map(F(props) {
			# Straighten Aws output to match CLI arguments
			translation = %{
				LoadBalancerName name

				AvailabilityZones availability-zones
				SecurityGroups security-groups
				ListenerDescriptions listeners
				Subnets subnets
				Scheme scheme
				HealthCheck health-check
			}
			ret = collector/{}
				translation.each(F(k, v) {
					if k in props {
						collect(v, props[k])
					}
				})
			ret.instances = props.Instances.InstanceId
			log("[find] load balancer '${r.ancor}' tags")
			ret.tags = ``aws elb describe-tags --load-balancer-names ${r.ancor}``[0].Tags
			ret
		})
	}

	F validate(r:AwsElb) {
		r.ancor is not Str throws InvalidArgument("AwsElb is the ELB name and must be a string, not ${r.ancor}")
		r.desired_count > 1 throws InvalidArgument("AwsElb can only handle one instance at a time while desired count is ${r.desired_count}")
		'listeners' not in r.desired_props throws InvalidArgument("AwsElb must have 'listeners' property")

		('azs' not in r.desired_props) and ('subnets' not in r.desired_props) throws InvalidArgument("Either 'azs' or 'subnets' must be in AwsElb properties")
		'azs' in r.desired_props throws NotImplemented("'azs' AwsElb property")
	}

	F create(r:AwsElb) {
		log("[create] creating resource instance")
		subnets = try r.desired_props.subnets
		if subnets is AwsResource {
			subnets .= ids()
		}
		if subnets {
			subnets = ['--subnets', *subnets]
		}
		r.run('create ELB', %(aws elb create-load-balancer --load-balancer-name ${r.ancor} --listeners ${r.desired_props.listeners.encode_json()} $*subnets))
		if not(r.dry_run) {
			r.find()
		}
	}


	F update(r:AwsElb, cur_props:Hash) {
		log("[update ELB] updating load balancer ${r.ancor}")

		# Tags
		diff = cmp(cur_props.tags, r.desired_props.get('tags', {}))

		if (tags = stdlib_aws_tags(diff.add + diff.change)) {
			r.run('add ELB tags', %(aws elb add-tags --load-balancer-names ${r.ancor} --tags $*tags))
		}

		if (tags = diff.remove) {
			r.run('remove ELB tags', %(aws elb remove-tags --load-balancer-names ${r.ancor} --tags $*tags))
		}

		# Health check. Note: only updates given properties and keeps the rest as they were.
		if 'health-check' in r.desired_props {
			diff = cmp(cur_props['health-check'], r.desired_props['health-check'])
			assert(not(diff.add), "Can't handle additional health check properties ${diff.add}")
			if diff.change {
				log("[update ELB health check] change: ${diff.change}")
				t = cur_props['health-check'] + diff.change
				r.run(
					'update ELB health check',
					%(aws elb configure-health-check --load-balancer-name ${r.ancor} --health-check ${t.encode_json()})
				)
			}
		}

		# Instances
		if 'instances' in r.desired_props {
			instances = r.desired_props.instances
			if instances is AwsResource {
				instances .= ids()
			}
			diff = cmp(cur_props['instances'], instances)
			if diff.add {
				r.run(
					'register instances with ELB',
					%(aws elb register-instances-with-load-balancer --load-balancer-name ${r.ancor} --instances $*{diff.add})
				)
			}
			if diff.remove {
				r.run(
					'deregister instances from ELB',
					%(aws elb deregister-instances-from-load-balancer --load-balancer-name ${r.ancor} --instances $*{diff.remove})
				)
			}
		}

		# TODO: Security groups

		# TODO: listeners
		diff = cmp(cur_props['listeners'], r.desired_props.listeners)
		echo("DIFF $diff")
	}

	F delete(r:AwsElb, resource:Hash) {
		r.run('delete ELB', %(aws elb delete-load-balancer --load-balancer-name ${r.ancor}))
	}

	# --------------------------------------------------
	type AwsSubnet(AwsResource)

	F _find_cmd(r:AwsSubnet) AwsCommand(%[aws ec2 describe-subnets], true)
	# Add sort()?
	F ids(r:AwsSubnet) r.cur_props.SubnetId

	# --------------------------------------------------
	type AwsInstance(AwsResource)
	F _find_cmd(r:AwsInstance) AwsCommand(%[aws ec2 describe-instances], true)
	F ids(r:AwsInstance) r.cur_props.InstanceId

	# --------------------------------------------------
	type AwsSecGroup(AwsResource)
	F _find_cmd(r:AwsSecGroup) AwsCommand(%[aws ec2 describe-security-groups], true)
	F ids(r:AwsSecGroup) r.cur_props.GroupId

}
