{
	AWS = true

	# --------------------------------------------------
	# Misc utilities
	# --------------------------------------------------

	F stdlib_aws_tags(h:Hash) h / "Key=$X,Value=$Y"

	# --------------------------------------------------
	# AwsResFindCommand
	# --------------------------------------------------

	type AwsResFindCommand

	F init(c:AwsResFindCommand, cmd:Arr, supports_filters:Bool) {
		c.cmd = cmd
		c.supports_filters = supports_filters
	}

	# --------------------------------------------------
	# AwsRes
	# --------------------------------------------------

	type AwsRes(Res)

	F run(r:AwsRes, log_pfx:Str, cmd:Command) r.def.run(log_pfx, cmd)

	F update_tags(r:AwsRes) {
		# Tags
		diff = cmp(r.props.get('Tags', {}), r.def.props.get('Tags', {}))

		if (tags = stdlib_aws_tags(diff.add + diff.change)) {
			r.run('Add tags', %(aws ec2 create-tags --resources ${r.id()} --tags $*tags))
		}

		if (diff.remove) {
			tags = diff.remove / "Key=$X"
			r.run('Remove tags', %(aws ec2 delete-tags --resources ${r.id()} --tags $*tags))
		}
	}

	# --------------------------------------------------
	# AwsResDef
	# --------------------------------------------------

	type AwsResDef(ResDef)

	F run(rd:AwsResDef, log_pfx:Str, cmd:Command) {
		if rd.dry_run {
			rd.log("run - $log_pfx", "would run: ${cmd.argv.join(' ')}")
		} else {
			rd.log("run - $log_pfx", "running: ${cmd.argv.join(' ')}")
			$($cmd)
		}
	}

	F find(rd:AwsResDef) {
		# XXX: invalid code because misses straightening
		cmd = _get_find_command(rd)
		c = cmd.cmd
		filters = if cmd.supports_filters {
			['--filters', *(rd.ancor / "Name=tag-key,Values=$X,Name=tag-value,Values=$Y")]
		} else {
			[]
		}
		debug("Filters: $filters")
		resources = ``$*c $*filters``

		# echo("resources $resources")
		if not(cmd.supports_filters) {
			throw NotImplemented("AwsResFindCommand with supports_filters=false is not implemented yet")
		}
		rd.log('find', "found ${resources.len()} ${rd.typeof().name} resources")

		t = rd._get_res_type()
		rd.resources = resources / t(rd, X)
		rd.resources
	}

	# --------------------------------------------------
	# AwsVpc
	# --------------------------------------------------

	type AwsVpc(AwsResDef)
	type AwsVpcRes(AwsRes)

	F _get_res_type(rd:AwsVpc) AwsVpcRes

	F _get_find_command(rd:AwsVpc) {
		AwsResFindCommand(%[aws ec2 describe-vpcs], true)
	}

	F ids(rd:AwsVpc) rd.resources.props.VpcId

	F Str(r:AwsVpc) {
		t = if r.resources is Null {
			''
		} else {
			" ${r.ids().join(',')}"
		}
		"<AwsVpc$t ancor=${r.ancor}>"
	}

	# --------------------------------------------------
	# AwsSecGroup
	# --------------------------------------------------

	type AwsSecGroup(AwsResDef)
	type AwsSecGroupRes(AwsRes)

	F ids(rd:AwsSecGroup) rd.resources.props.GroupId
	F users_ids(r:AwsSecGroup) r.resources / F(res) { {'GroupId': res.props.GroupId, 'UserId': res.props.OwnerId} }

	F _get_res_type(rd:AwsSecGroup) AwsSecGroupRes

	F _get_find_command(rd:AwsSecGroup) {
		AwsResFindCommand(%[aws ec2 describe-security-groups], true)
	}

	F validate(rd:AwsSecGroup) {
		(rd.ancor is not Arr) throws
			InvalidArgument("AwsSecGroup's ancor must be an array")
		('Description' not in rd.props) throws
			InvalidArgument("AwsSecGroup must have the 'description' property")
	}

	F vpc_id(rd:AwsSecGroup) rd.ancor[1]

	F vpc_id(rd:AwsSecGroup) {
		guard rd.ancor[1] is AwsResDef
		assert(rd.ancor[1].len() == 1, "AwsSecGroup expects exactly one vpc-id but passed resource ${rd.ancor[1]} has zero or more than one")
		rd.ancor[1].ids()[0]
	}

	F vpc_id_args(rd:AwsSecGroup) ['--vpc-id', vpc_id(rd)]

	F vpc_id_args(rd:AwsSecGroup) {
		guard vpc_id(rd) is Null
		[]
	}

	F vpc_id_filter(rd:AwsSecGroup) ['--filters', "Name=vpc-id,Values=${vpc_id(rd)}"]

	F vpc_id_filter(rd:AwsSecGroup) {
		guard vpc_id(rd) is Null
		[]
	}

	F id(sg:AwsSecGroupRes) sg.props.GroupId

	F find(rd:AwsSecGroup) {
		rd.log('find', 'SG')
		# XXX: check with default VPC / EC2 classic
		# Can not use --group-names as it will assume default VPC / EC2 classic
		resources = ``aws ec2 describe-security-groups $*{vpc_id_filter(rd)}``.filter(F(sg) sg.GroupName == rd.ancor[0])
		assert(resources.len() <= 1, "Can only work with one security group at a time")
		known_props = %[GroupName GroupId OwnerId Description IpPermissions IpPermissionsEgress Tags]
		resources .= map(F(res) {
			AwsSecGroupRes(rd, res ? known_props.has(X))
		})
		rd.resources = resources
		rd.resources
	}

	type IpPermBox(FullBox)

	# Cleans up AWS Security Group IpPermissions so it's possible to compare current and desired states of IpPermissions
	F cleanup(x:IpPermBox) {
		ret = x.val
		ret .= filter(F(k, v) (v is not Arr) or v)
		ret .= without('IpRanges', [{"CidrIp": "0.0.0.0/0"}])
		if 'UserIdGroupPairs' in ret {
			# Hash is ordered. The right order for comparison is GroupId and then UserId
			ret.UserIdGroupPairs .= map(F(pair) { {'GroupId': pair.GroupId, 'UserId': pair.UserId } })
		}
		ret
	}

	F ==(a:IpPermBox, b:IpPermBox) {
		a .= cleanup()
		b .= cleanup()
		a.len() != b.len() returns false
		diff = cmp(a, b)
		not(diff.add or diff.remove or diff.change)
	}

	F create(rd:AwsSecGroup) {
		rd.log('create', 'SG')
		rd.run('create SG', %(aws ec2 create-security-group --group-name ${rd.ancor[0]} --description ${rd.props.Description} $*{vpc_id_args(rd)}))
		if not(rd.dry_run) {
			rd.find()
		}
	}

	F update(sg:AwsSecGroupRes) {

		sg.def.log('update', 'SG')

		if 'IpPermissions' in sg.def.props {
			diff = compare(sg.props.IpPermissions/IpPermBox, sg.def.props.IpPermissions/IpPermBox)
			diff.add.each(F(perm) {
				sg.run('add SG ingress rule', %(aws ec2 authorize-security-group-ingress --group-id ${sg.props.GroupId} --ip-permissions $*{diff.add.val / encode_json}))

			})
			diff.remove.each(F(perm) {
				sg.run('remove SG ingress rule', %(aws ec2 revoke-security-group-ingress --group-id ${sg.props.GroupId} --ip-permissions $*{diff.remove.val / encode_json}))
			})
		}

		sg.update_tags()
	}

	# --------------------------------------------------
	# AwsSubnet
	# --------------------------------------------------

	type AwsSubnet(AwsResDef)
	type AwsSubnetRes(AwsRes)

	F ids(rd:AwsSubnet) rd.resources.props.SubnetId

	F _get_res_type(rd:AwsSubnet) AwsSubnetRes

	F _get_find_command(rd:AwsSubnet) {
		AwsResFindCommand(%[aws ec2 describe-subnets], true)
	}

	# --------------------------------------------------
	# AwsInstance
	# --------------------------------------------------

	type AwsInstance(AwsResDef)
	type AwsInstanceRes(AwsRes)

	F _get_res_type(rd:AwsInstance) AwsInstanceRes

	F _get_find_command(rd:AwsInstance) {
		AwsResFindCommand(%[aws ec2 describe-instances], true)
	}

	F ids(rd:AwsInstance) rd.resources.props.InstanceId

	# --------------------------------------------------
	# AwsElb
	# --------------------------------------------------

	type AwsElb(AwsResDef)
	type AwsElbRes(AwsRes)

	F ids(rd:AwsElb) rd.resources.props.XXX

	F validate(rd:AwsElb) {
		rd.ancor is not Str throws InvalidArgument("AwsElb is the ELB name and must be a string, not ${rd.ancor}")
		rd.count > 1 throws InvalidArgument("AwsElb can only handle one instance at a time while desired count is ${rd.count}")
		'ListenerDescriptions' not in rd.props throws InvalidArgument("AwsElb must have 'listeners' property")

		('AvailabilityZones' not in rd.props) and ('Subnets' not in rd.props) throws InvalidArgument("Either 'azs' or 'subnets' must be in AwsElb properties")
		'AvailabilityZones' in rd.props throws NotImplemented("'AvailabilityZones' AwsElb property")
	}

	F find(rd:AwsElb) {
		rd.log('find', "ELB")
		resources = ``aws elb describe-load-balancers``.filter(F(desc) desc.LoadBalancerName == rd.ancor)
		assert(resources.len() <= 1, "Can only work with one load balancer at a time")
		known_props = %[LoadBalancerName AvailabilityZones SecurityGroups ListenerDescriptions Subnets Scheme HealthCheck Instances]
		rd.resources = resources.map(F(props) {
			ret = props ? known_props.has(X)
			ret.Instances = props.Instances.InstanceId
			# TODO: make it lazy
			rd.log('find', "ELB tags")
			ret.Tags = ``aws elb describe-tags --load-balancer-names ${rd.ancor}``[0].Tags
			AwsElbRes(rd, ret)
		})
		rd.resources
	}

	F create(rd:AwsElb) {
		rd.log('create', "creating an ELB")
		subnets = try rd.props.Subnets
		if subnets is AwsResDef {
			subnets .= ids()
		}
		if subnets {
			subnets = ['--subnets', *subnets]
		}
		rd.run('create ELB', %(aws elb create-load-balancer --load-balancer-name ${rd.ancor} --listeners ${rd.props.ListenerDescriptions.encode_json()} $*subnets))
		if not(rd.dry_run) {
			rd.find()
		}
	}

	F update(elb:AwsElbRes) {
		elb.def.log('update', 'ELB')

		# Tags
		diff = cmp(elb.props.get('Tags', {}), elb.def.props.get('Tags', {}))

		if (tags = stdlib_aws_tags(diff.add + diff.change)) {
			elb.run('add ELB tags', %(aws elb add-tags --load-balancer-names ${elb.def.ancor} --tags $*tags))
		}

		if (tags = diff.remove) {
			elb.run('remove ELB tags', %(aws elb remove-tags --load-balancer-names ${elb.def.ancor} --tags $*tags))
		}

		# Health check. Note: only updates given properties and keeps the rest as they were.
		if 'HealthCheck' in elb.def.props {
			diff = cmp(elb.props['HealthCheck'], elb.def.props['HealthCheck'])
			assert(not(diff.add), "Can't handle additional health check properties ${diff.add}")
			if diff.change {
				elb.def.log('update', "ELB health check change: ${diff.change}")
				t = elb.props['HealthCheck'] + diff.change
				elb.run(
					'update ELB health check',
					%(aws elb configure-health-check --load-balancer-name ${elb.def.ancor} --health-check ${t.encode_json()})
				)
			}
		}

		# Instances
		if 'Instances' in elb.def.props {
			instances = elb.def.props.Instances
			if instances is AwsResDef {
				instances .= ids()
			}
			diff = cmp(elb.props.Instances, instances)
			if diff.add {
				elb.run(
					'register instances with ELB',
					%(aws elb register-instances-with-load-balancer --load-balancer-name ${elb.def.ancor} --instances $*{diff.add})
				)
			}
			if diff.remove {
				elb.run(
					'deregister instances from ELB',
					%(aws elb deregister-instances-from-load-balancer --load-balancer-name ${elb.def.ancor} --instances $*{diff.remove})
				)
			}
		}

		# Security groups
		if 'SecurityGroups' in elb.def.props {
			sgs = elb.def.props.SecurityGroups
			if sgs is AwsResDef {
				sgs .= ids()
			}
			diff = cmp(elb.props.SecurityGroups, sgs)
			if diff.add or diff.remove {
				elb.run(
					'update ELB SGs',
					%(aws elb apply-security-groups-to-load-balancer --load-balancer-name ${elb.def.ancor} --security-groups $*{sgs})
				)
			}
		}

		# TODO: listeners
		diff = cmp(elb.props.ListenerDescriptions, elb.def.props.ListenerDescriptions)
		# echo("DIFF $diff")
	}

	F delete(elb:AwsElb) {
		elb.run('delete ELB', %(aws elb delete-load-balancer --load-balancer-name ${elb.ancor}))
	}

}
