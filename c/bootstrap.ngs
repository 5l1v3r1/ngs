# === Exception ==================================

doc %RET - Exception with .backtrace attribute
F init(e:Exception) {
	# Last entry in backtrace would be this init() invocation
	local b = Backtrace()
	pop(b.frames)
	e.backtrace = b
}


doc %RET - Exception with .backtrace and .info
doc s - Goes into .info
F init(e:Exception, s:Str) {
	# Last entry in backtrace would be this Exception() invocation
	init(e)
	e.info = s
	e.backtrace.frames.pop()
}

doc %RET - Exception with .backtrace and .cause
F init(e:Exception, cause:Exception) {
	# Last entry in backtrace would be this Exception() invocation
	init(e)
	e.cause = cause
	e.backtrace.frames.pop()
}

TEST Exception().backtrace is Backtrace
TEST Exception("xyz").info == "xyz"
TEST Exception(Exception()).cause is Exception


{
	type NotImplemented; NotImplemented.inherit(Exception);
	type FetchFail; FetchFail.inherit(Exception);
	type RequreFail; RequreFail.inherit(Exception);
	type MainFail; MainFail.inherit(Exception);
}

# === bootstrap ==================================

# *** Convert values returned by the program (or -e/-E expression) to exit codes ***
doc %RET - always 0
F to_exit_code(x) 0
doc %RET - 0 for true, 1 for false
F to_exit_code(b:Bool) if b 0 1
doc %RET - n
F to_exit_code(n:Int) n


# *** Define bootstrap_debug function ***
bootstrap_debug =
	if 'NGS_BOOTSTRAP_DEBUG' in ENV
		F(s) echo("+ [BOOSTRAP DEBUG] $s")
	else
		F(s) {}

bootstrap_ngs_dir_candidates = [
	'/usr/local/etc/ngs'
	'/usr/local/share/ngs'
	'/etc/ngs'
	'/usr/share/ngs'
]

F bootstrap_find_ngs_dir() {
	local l = bootstrap_ngs_dir_candidates.len()
	for(i;l) {
		c_access("${bootstrap_ngs_dir_candidates[i]}/stdlib.ngs", C_F_OK) == 0 returns bootstrap_ngs_dir_candidates[i]
	}
	null
}

F bootstrap_find_ngs_dir() {
	guard 'NGS_DIR' in ENV
	ENV['NGS_DIR']
}

# *** fetch - abstraction above low level c io primitives ***
# TODO: Better exceptions
doc Fetches whole file
doc fname - File name to fetch
doc %RET - Whole file as a string
F fetch(fname:Str) {
	try {
		local fd, file_len, data
		fd = c_open(fname, 'r')
		fd <= 0 throws Exception("fetch(): failed to open file ${fname}")
		bootstrap_debug("fetch(): opened file ${fname} as fd ${fd}")
		file_len = c_lseek(fd, 0, "end")
		file_len < 0 throws Exception("fetch(): failed to get the size of file ${fname}")
		c_lseek(fd, 0, "set")
		bootstrap_debug("fetch(): file size of ${fname} is ${file_len}")
		data = c_read(fd, file_len)
		c_close(fd)
		data[1]
	} catch(e) {
		throw FetchFail(e)
	}
}

doc Runs the given file
doc %RET - Typically whatever the last expression in the file evaluates to
F require(fname:Str) {
	try {
		local program_text = fetch(fname)
		local program_bytecode = compile(program_text, fname)
		bootstrap_debug("require(): bytecode for ${fname} has length of ${program_bytecode.len()} bytes")
		local program_func = load(program_bytecode, "require()d file: $fname")
		local ret = program_func()
		bootstrap_debug("require(): done requiring ${fname}")
		ret
	} catch(e) {
		throw RequreFail(e)
	}
}

doc Main entry point. Executed on NGS boot.
F bootstrap() {
	local do_load_stdlib = true
	local code_to_run = null
	local fname

	bootstrap_debug('bootstrap.ngs begin')
	bootstrap_debug("BOOTSTRAP_FILE=$BOOTSTRAP_FILE")

	# *** Prepare ARGV ***
	# first_item = shift(array, default_value_if_array_is_empty)
	ARGV0 = ARGV.shift(null)

	# *** Parse switches ***
	if ARGV and (ARGV[0] == '-e' or ARGV[0] == '-E') {
		local sw = ARGV.shift()
		code_to_run = "{ ${ARGV.shift()} }"
		bootstrap_debug("Got $sw switch, using command line provided code")
		if sw == '-E' {
			bootstrap_debug('Will skip loading stdlib because of -E flag')
			do_load_stdlib = false
		}
		fname = "<command line ${sw} switch>"
	}

	if 'NGS_SKIP_STDLIB' in ENV {
		bootstrap_debug('Will skip loading stdlib because of set NGS_SKIP_STDLIB environment variable')
		do_load_stdlib = false
	}

	NGS_DIR = bootstrap_find_ngs_dir()

	NGS_DIR is Null throws Exception("Could not find NGS_DIR")

	# *** WIP: Load stdlib ***
	if do_load_stdlib {
		bootstrap_debug('Will load stdlib')
		stdlib_file = "${NGS_DIR}/stdlib.ngs"
		bootstrap_debug("Stdlib is at $stdlib_file")
		require(stdlib_file)
	}

	# *** WIP: Load the main program ***
	# XXX: not() is not defined yet. Change 'code_to_run is Null' to 'not(code_to_run)' later.

	if code_to_run is Null {
		bootstrap_debug('No -e or -E switch was passed, will load the program from a file')
		fname = ARGV.shift(null)
		if fname is Null {
			fname = ENV.get('NGS_CLI', "${NGS_DIR}/cli.ngs")
		}
		code_to_run = fetch(fname)
	}

	local program_bytecode = compile(code_to_run, fname)
	bootstrap_debug("bootstrap(): bytecode for ${fname} has length of ${program_bytecode.len()} bytes")
	local program_func = load(program_bytecode, "bootstrap()ped file: $fname")
	local result = program_func()
	if not(defined main) {
		bootstrap_debug("main() not defined, exiting")
		c_exit(result.to_exit_code())
	}
	bootstrap_debug("main() defined, using bootstrap_invoke_main()")
	if global_not_found_hook.len() == 0 {
		throw MainFail("Autoloading (usually defined in stdlib) is not present but the main() invoking mechanism requires it")
	}

	result = bootstrap_invoke_main()
	c_exit(result.to_exit_code())
}

bootstrap()
