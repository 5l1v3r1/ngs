# === Misc functional ============================


F identity(x) x

# TEST: identity(10) == 10


# === Syntactic sugar ============================


F !=(a,b) not(a==b)

# TEST: 1 != 2
# TEST: (1 != 1) == false


F 'not in'(a,b) not(a in b)

# TEST: (1 not in [1,2,3]) == false
# TEST: (10 not in [1,2,3])


F 'is not'(a,b) not(a is b)

# TEST: 1 is not Null
# TEST: (null is not Null) == false


F has(container, element) element in container

# TEST: [1,2,3].has(1)
# TEST: [1,2,3].has(10) == false


# Return the "collect" function for the given initial object (defaults to [])
F collector(a:Arr, code:Fun) {
	code(F(elt) a.push(elt))
	a
}

F collector(h:Hash, code:Fun) {
	code(F(k, v) h[k] = v)
	h
}

F collector(n:Int, code:Fun) {
	code(F(incr) n=n+incr)
	n
}


# === Array ======================================


# Checks whether element x is in array arr
F in(x, arr:Arr) {
	local l = arr.len()
	for(i;l) arr[i] == x returns true
	false
}

# Tested by has() tests


# XXX BUG: the dot precedence is incorrect
# temporary workaround - parenthesis
F ==(a:Arr, b:Arr) {
	local l = a.len()
	l != (b.len()) returns false
	for(i;l) a[i] != b[i] returns false
	true
}

# TEST: [1, 2] == [1, 2]
# TEST: [1, 3] != [1, 2]
# TEST: [1] != [1, 2]


F map(arr:Arr, mapper:Fun) {
	local l = arr.len()
	collector
		for(i;l) collect(mapper(arr[i]))
}

# TEST: [1,2,3].map(F(x) x*3) == [3,6,9]


F each(arr:Arr, cb:Fun) {
	local l = arr.len()
	for(i;l) cb(arr[i])
}

# Tested by flatten() tests


F flatten(arr:Arr)
	collector
		arr.each(F(subarr) {
			subarr.each(collect)
		})

# TEST: [[1], [2,3]].flatten() == [1,2,3]


F Arr(h:Hash)
	h.keys().map(F(k) [k, h[k]])

# TEST: Arr({'x': 7, 'y': 8}) == [['x', 7], ['y', 8]]


# === Hash =======================================


# --- Comparisons ---

F ==(a:Hash, b:Hash) Arr(a) == Arr(b)


# --- Functional ---

F each(h:Hash, cb:Fun) {
	h.keys().each(F(k) cb(k, h[k]))
	h
}

# Make it built in for speed?
F map(h:Hash, mapper:Fun)
	h.keys().map(F(k) mapper(k, h[k]))

# TEST: {'a': 1, 'b': 2}.map(F(k, v) "${k}-$v") == ['a-1', 'b-2']


F filter(h:Hash, predicate:Fun)
	collector/{}
		h.each(F(k,v) {
			if predicate(k, v)
				collect(k, v)
		})

# --- Conversions ---

F Hash(a:Arr)
	collector/{}
		a.each(F(x) collect(x[0], x[1]))

# TEST: Hash([['a', 1], ['c', 3]]) == {'a': 1, 'c': 3}


F Hash(a:Arr, v)
	collector/{}
		a.each(F(k) collect(k, v))

# TEST: Hash([1,2], 'x') == {1: 'x', 2: 'x'}


# --- Misc ---


F without(h:Hash, without_k)
	h.filter(F(k, v) k != without_k)

# TEST: {'a': 1, 'b': 2, 'c': 3}.without('a') == {'b': 2, 'c': 3}


F +(a:Hash, b:Hash)
	collector/{} {
		a.each(collect)
		b.each(collect)
	}


# TEST: {'a': 1, 'b': 2, 'c': 3} + {'b': 20, 'd': 40} == {'a': 1, 'b': 20, 'c': 3, 'd': 40}


F update(dst:Hash, src:Hash)
	collector/dst
		src.each(collect)

# TEST: F() { local h={'a': 1, 'b': 2, 'c': 3}; h.update({'b': 20, 'd': 40}); h == {'a': 1, 'b': 20, 'c': 3, 'd': 40} }()


# === Integer ====================================

# --- Functional ---

F each(n:Int, cb:Fun) for(i;n) cb(i)

F map(n:Int, mapper:Fun)
	collector
		for(i;n) collect(mapper(i))

# TEST: 3.map(identity) == [0, 1, 2]
# TEST: 3.map(F(x) x*2) == [0, 2, 4]


# === Logging and status reporting ===============

# TODO: allow control by facility and severity and maybe source component or file.

F log(s:Str) {
	echo("[LOG   ] $s")
}

F debug(s:Str) {
	ENV.get('DEBUG', '') == '' returns null
	echo("[DEBUG ] $s")
}

F status(s:Str) {
	echo(s)
	log("(status) $s")
}
