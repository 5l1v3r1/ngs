# === Trivial init() helper ===

doc Trivial initialization helper for init(o, ...)
doc Sets object fields from the supplied parameters
doc %EX - # sets t.a and t.b
doc %EX - F init(t:MyType, a, b) init(args())
F init(h:Hash) {
	args = Arr(h)
	dst = args.shift()[1]
	args.each(F(field_name_value) (.=)(dst, field_name_value[0], field_name_value[1]))
	dst
}

# === Exceptions ===

{
	type AssertFail
	AssertFail.inherit(Exception)
}

F init(e:IndexNotFound, message:Str, container, key) init(args())

F assert(condition:Bool, msg:Str) not(condition) throws AssertFail(msg)
F assert(condition:Bool) assert(condition, "Assertion failed")

# === Return =====================================

F call(r:Return, v) {
	r.val = v
	r
}

F call(r:Return) {
	r.val = null
	r
}

# === Misc functional ============================


doc %RET - The given argument
F identity(x)  x

TEST identity(10) == 10


# TODO: Add more info about the newly created function - useful for debugging
#       See https://docs.python.org/2/library/functools.html#partial-objects
doc Returns partially-applied function
doc f - The base function
doc Xunderscore_unsupportedXbind_args - The arguments to bind the function to
F partial(f:Fun, *bind_args)
	F(*args) f(*bind_args, *args)

TEST p = partial((-), 10); p(7) == 3


doc Same as partial() but the bound arguments are last ones
F partial_tail(f:Fun, *bind_args)
	F(*args) f(*args, *bind_args)

TEST p = partial_tail((-), 10); p(7) == -3

F set(obj, attr:Str, val) {
	(.=)(obj, attr, val)
	obj
}

doc Filter operator
doc Syntax mnemonic: ? for predicate
doc %EX - [1,2,3,4] ? F(x) x > 2
F ?(x, predicate:Fun) x.filter(predicate)

doc Map operator
doc Syntax: / is on same key as ? and similar to |
doc %EX - [1,2,3,4] / F(x) x * 10
F /(x, mapper:Fun) x.map(mapper)

doc Each operator
doc Syntax: % is similar to /
doc %EX - [1,2,3,4] % echo
F %(x, cb:Fun) x.each(cb)

doc Call operator
doc %EX - [1,2,3,4] \ echo
F \(x, f:Fun) f(x)


# === Real =======================================

# TODO: something more efficient
F Real(s:Str) {
	parts = s.split('.')
	parts.len() == 1 returns Real(Int(parts[0]))
	parts.len() != 2 throws InvalidArgument("Invalid argument ${s}")
	l = parts[1].len()
	frac = Real(Int(parts[1]))
	for(i;l) frac = frac / 10.0
	Real(Int(parts[0])) + frac
}

TEST Real('1.1') == 1.1

# === NativeMethod ===============================

F Str(c:NativeMethod) {
	"<Native method ${c.attrs().name}>"
}

# === Closure ====================================

F Str(c:Closure) {
	info = c.ip().resolve_instruction_pointer()
	location = "${info.file}:${info.first_line}" tor "<unknown location>"
	"<Closure ${c.attrs().name tor "<anonymous>"} at ${location}>"
}

# === Type =======================================

F Type(t:Str, doc, parent:Type) Type(t, doc, [parent])

F Type(t:Str, doc, parents:Arr) {
	ret = Type(t, doc)
	parents % ret.inherit(X)
	ret
}

TEST type T1; type T2(T1); T2() is T1


STDLIB_EXPOSE = {}

# TODO: better exceptions (use correct type, not string, provide offending type and attribute)
doc Exposes the given attribute so when there is ImplNotFound
doc when the original call had instance of the given type as an argument
doc the call is retried with the instance replaced by the given argument
doc
doc typ - ImplNotFound with instance of this type will cause retry with the given attribute
doc attr - The exposed attribute that will be used on call retry
doc %RET - typ
doc %EX - {
doc %EX - 	type Stats
doc %EX - 	Stats.expose(h)
doc %EX - }
doc %EX -
doc %EX - F init(s:Stats) {
doc %EX - 	s.h = {}
doc %EX - }
doc %EX -
doc %EX - F Stats(a:Arr) {
doc %EX - 	s = Stats()
doc %EX - 	a.each(partial(push, s))
doc %EX - 	s
doc %EX - }
doc %EX -
doc %EX - F push(s:Stats, k) {
doc %EX - 	s.h[k] = s.h.get(k, 0) + 1
doc %EX - 	s
doc %EX - }
doc %EX -
doc %EX - # Usage:
doc %EX - numbering = Stats()
doc %EX - numbering.push(hostname_base)
doc %EX - ... numbering[hostname_base]} ...
F expose(typ:NormalType, attr:Str) {
	STDLIB_EXPOSE[typ] = STDLIB_EXPOSE.get(typ, []).push(attr)
	if STDLIB_EXPOSE[typ].len() > 1 {
		throw NotImplemented("expose() does not support exposing more than one attribute at this time").set('type', typ).set('attr', attr)
	}
	typ
}

# * if there is no appropriate mymethod(...,my_type_instance,...) and the type of my_type_instance
#   has expose()d attribute, retry the call with mymethod(...,my_type_instance.exposed_attribute,...)
# * This is called by the VM when a method was called but none of the implementations matched
#   the parameters (or failed "guard" statements).
# TODO: make it faster
# TODO: support trying all attributes listed in STDLIB_EXPOSE, not just first
# TODO: check and solve usage by inheriting types
# TODO: support keword arguments?
doc Called on ImplNotFound
doc Implements expose() behaviour
F impl_not_found_hook(callable:Fun, *args) {
	l = args.len()
	exposed_attr_name = null
	for(i;l) {
		arg = args[i]
		if typeof(arg) in STDLIB_EXPOSE {
			exposed_attr_name = STDLIB_EXPOSE[typeof(arg)][0]
			change_idx = i
			break
		}
	}
	guard exposed_attr_name
	new_args = copy(args)
	new_args[change_idx] = (.)(new_args[change_idx], exposed_attr_name)
	callable(*new_args)
}

F Str(t:Type) "<Type ${t.name}>"

# === NormalType =================================

F Str(i:NormalTypeInstance) {
	h = Hash(i)
	truncated = len(h) > 10
	if truncated {
		h .= limit(10)
	}
	# TODO limit key and value lengths
	h .= Strs()

	"<${i.typeof().name} ${h.join(' ')}${if truncated ' ...' else ''}>"
}

F dflt(i:NormalTypeInstance, k, v) {
	if k not in i {
		(.=)(i, k, v)
	}
	i
}


# === auto-load ==================================

doc Called when reading undefined global
doc Implements autoloading
F global_not_found_hook(name:Str) {
	require("${NGS_DIR}/autoload/${name}.ngs")
}

# === Range ======================================

F init(r:Range, start, end) init(args())

F ..(start, end)  ExclusiveRange(start, end)
F ...(start, end) InclusiveRange(start, end)

F each(r:Range, cb:Fun, *args) {
	econd {
		r.end is Null {
			step = 1
			cmp = F(a,b) true
		}
		r.start <= r.end {
			step = 1
			cmp = if r is ExclusiveRange (<) (<=)
		}
		r.start > r.end {
			step = -1
			cmp = if r is ExclusiveRange (>) (>=)
		}
	}
	for(i=r.start; cmp(i, r.end); i=i+step)
		cb(i, *args)
	r
}

F map(r:Range, mapper:Fun, *args)
	collector
		r.each(F(elt) collect(mapper(elt, *args)))

TEST (1..3).map(X*2) == [2, 4]
TEST (1...3).map(X*2) == [2, 4, 6]

F first(r:Range, predicate:Fun, *args) {
	finish = Return()
	r.each(F(i) {
		predicate(i, *args) throws finish(i)
	})
	null
}

TEST (10..20).first(F(x) x % 3 == 0) == 12

F Str(r:ExclusiveRange) "<ExclusiveRange ${r.start}..${r.end}>"
F Str(r:InclusiveRange) "<InclusiveRange ${r.start}...${r.end}>"

# === Syntactic sugar ============================

F not(x) { guard (x is Bool) == false; x.Bool().not() }

F !=(a,b) not(a==b)
F !==(a,b) not(a===b)

TEST 1 != 2
TEST (1 != 1) == false

TEST 1 !== 2
TEST (1 !== 1) == false


F 'not in'(a,b) not(a in b)

TEST (1 not in [1,2,3]) == false
TEST 10 not in [1,2,3]


F 'is not'(a,b) not(a is b)

TEST 1 is not Null
TEST (null is not Null) == false


F has(container, element) element in container

TEST [1,2,3].has(1)
TEST [1,2,3].has(10).not()


# Return the "collect" function for the given initial object (defaults to [])
F collector(a:Arr, code:Fun) {
	code(F(elt) a.push(elt))
	a
}

F collector(h:Hash, code:Fun) {
	code(F(k, v) h[k] = v)
	h
}

F collector(n:Int, code:Fun) {
	code(F(incr) n=n+incr)
	n
}

F ==(a:Null, b) false
F ==(a, b:Null) false
F ==(a:Null, b:Null) true

# --- Hash ---
F .(h:Hash, attr:Str) h[attr]
F .=(h:Hash, attr:Str, v) h[attr] = v
F get(h:Hash, k) get(h, k, null)
F n(h:Hash) h.map(F(k, v) [k, Int(v) tor v]).Hash()

TEST %{k 7 kk "a"}.n() == {'k': 7, 'kk': 'a'}

# --- Arr ---
F .(a:Arr, attr:Str) a.map((.), attr)

TEST [{"x": 1}, {"x": 2}].x == [1, 2]

F +(s1:Str, s2:Str) "${s1}${s2}"

TEST "ab" + "cd" == "abcd"

# === Array ======================================


# Checks whether element x is in array arr
F in(x, arr:Arr) {
	l = arr.len()
	for(i;l) arr[i] == x returns true
	false
}

# Tested by has() tests


F ==(a:Arr, b:Arr) {
	l = a.len()
	l != b.len() returns false
	for(i;l) a[i] != b[i] returns false
	true
}

TEST [1, 2] == [1, 2]
TEST [1, 3] != [1, 2]
TEST [1] != [1, 2]


F any(arr:Arr, predicate:Fun, *args) {
	l = arr.len()
	for(i;l)
		predicate(arr[i], *args) returns true
	false
}

TEST [1,2,10].any(F(elt) elt > 5)
TEST [1,2,3].any(F(elt) elt > 5).not()


F all(arr:Arr, predicate:Fun, *args) {
	l = arr.len()
	for(i;l)
		not(predicate(arr[i], *args)) returns false
	true
}

TEST [1,2,3].all((<), 10)
TEST [1,2,10].all((>), 5).not()

F none(arr:Arr, predicate:Fun, *args) not(any(arr, predicate, *args))

TEST [0,1,2].none((>), 2)
TEST [0,1,2].none((<), 2).not()


F map(arr:Arr, mapper:Fun, *args)
	collector
		arr.each(F(elt) {
			collect(mapper(elt, *args))
		})

TEST [1,2,3].map((*), 4) == [4,8,12]


F each(arr:Arr, cb:Fun, *args) {
	l = arr.len()
	for(i;l) cb(arr[i], *args)
	arr
}

# TODO: map_idx_val, each_idx_val for other types
F each_idx_val(arr:Arr, cb:Fun, *args) {
	l = arr.len()
	for(i;l) cb(i, arr[i], *args)
	arr
}

F map_idx_val(arr:Arr, cb:Fun, *args) {
	l = arr.len()
	collector
		for(i;l) collect(cb(i, arr[i], *args))
}

TEST r=[]; ["a", "b"].each_idx_val(F(idx, val) r.push([idx, val])); r == [[0, "a"], [1, "b"]]


# Tested by flatten() tests

F filter(arr:Arr, predicate:Fun, *args)
	collector
		arr.each(F(elt) {
			if predicate(elt, *args)
				collect(elt)
		})

# Tested by without() tests


F without(arr:Arr, without_elt)
	arr.filter((!=), without_elt)

TEST [1,2,3,2].without(2) == [1,3]


F filter(arr:Arr) filter(arr, (is not), Null)

TEST [1,2,null,3].filter() == [1,2,3]


F -(a:Arr, b:Arr) {
	h = if b.len() > 10 {
		collector/{} b.each(collect, true)
	} else {
		b
	}
	a.filter((not in), h)
}

TEST [1,2,3] - [5,6,1] == [2,3]
TEST [1,2,3] - [5,6,1,1,1,1,1,1,1,1,1,1,1,2] == [3]


F count(arr:Arr, predicate:Fun, *args) {
	collector/0
		arr.each(F(elt) {
			if predicate(elt, *args)
				collect(1)
		})
}

TEST [1,2,3,11,12].count(X>10) == 2

F count(arr:Arr) count(arr, identity)

TEST [0,1,2,null,false].count() == 2

F flatten(arr:Arr) {
	guard arr.all(is, Arr)
	collector
		arr.each(F(subarr) {
			subarr % collect
		})
}

TEST [[1], [2,3]].flatten() == [1,2,3]


F uniq(arr:Arr)
	(collector/{}
		arr.each(collect, 1)
	).keys()

TEST [1,2,2,3,4,4].uniq() == [1,2,3,4]


F first(arr:Arr) first(arr, identity)

TEST [null, false, 10, 20].first() == 10


F index(arr:Arr, predicate:Fun, *args) {
	l = arr.len()
	for(i;l)
		predicate(arr[i], *args) returns i
	null
}

F first(arr:Arr, predicate:Fun, *args) {
	i = arr.index(predicate, *args)
	i is Null returns null
	arr[i]
}

TEST [5,10,15].first(X>7) == 10
TEST [5,10,15].first(X>20) == null


F reverse(arr:Arr) {
	l = arr.len()
	collector
		for(i;l) collect(arr[l-i-1])
}

TEST [1,2,3].reverse() == [3,2,1]

# --- Conversions ---

F Arr(h:Hash)
	h.map(F(*pair) pair)

TEST Arr({'x': 7, 'y': 8}) == [['x', 7], ['y', 8]]


F Arr(arr:Arr) arr


F zip(*args) {
	arrays = args.map(Arr)
	# max_len = arrays.map(len).max()
	max_len = arrays / len \ max
	collector
		for(i;max_len)
			collect(arrays.map(get, i, null))
}

TEST zip([1,2,3], [4,5,6]) == [[1,4], [2,5], [3,6]]

F Arr(r:Range) r / identity

TEST Arr(1..3) == [1,2]
TEST Arr(1...3) == [1,2,3]


# --- Access elements ---

F '[]'(arr:Arr, idx:Int) {
	guard idx < 0
	i = arr.len() + idx
	i < 0 throws IndexNotFound("[](Arr, Int): Index $idx is illegal for array of size ${arr.len()}").set('container', arr).set('key', idx)
	arr[i]
}

F '[]'(arr:Arr, indexes:Arr) indexes.map(arr[X])

TEST [10,20,30,40][[0,3]] == [10, 40]

F '[]'(arr:Arr, range:Range) {
	start = econd {
		range.start is Null
			0
		range.start > arr.len()
			throw IndexNotFound("Range start ${range.start} is too high for array of length ${arr.len()}", arr, range.end)
		range.start >= 0
			range.start
		range.start < 0
			throw IndexNotFound("Range start ${range.start} is too low", arr, range.start)
	}
	end = econd {
		range.end is Null
			arr.len()
		range.end < start
			throw IndexNotFound("Range end ${range.end} is lower than selection start ${start}", arr, range.end)
		not(range.end < arr.len())
			throw IndexNotFound("Range end ${range.end} is too high for array of length ${arr.len()}", arr, range.end)
		range is InclusiveRange
			range.end + 1
		range is ExclusiveRange
			range.end
	}
	collector
		(start..end).each(F(idx) collect(arr[idx]))
}

TEST [10,20,30,40][null..2] == [10,20]
TEST [10,20,30,40][1..2] == [20]
TEST (try [10,20,30,40][-1..2] catch(e:IndexNotFound) "OK") == "OK"
TEST [10,20,30,40][2..null] == [30, 40]
TEST (try [10,20,30,40][2..1] catch(e:IndexNotFound) "OK") == "OK"
TEST (try [10,20,30,40][2..10] catch(e:IndexNotFound) "OK") == "OK"
TEST [10,20,30,40][1...2] == [20, 30]
TEST [10,20,30,40][4..null] == []

F limit(a:Arr, l:Int) {
	a.len() <= l returns a
	a[0..l]
}

TEST [10,11,12].limit(10) == [10,11,12]
TEST [10,11,12].limit(2) == [10,11]

# --- Misc ---

{
	F() {
		global min, max
		F most(arr:Arr, f:Fun) {
			guard arr
			ret = arr[0]
			arr.each(F(elt) if f(elt, ret) { ret = elt })
			ret
		}

		F most_by_cb(arr:Arr, f:Fun, cb:Fun) {
			guard arr
			ret = arr[0]
			ret_cb = cb(ret)
			arr.each(F(elt) {
				elt_cb = cb(elt)
				if f(elt_cb, ret_cb) {
					ret = elt
					ret_cb = elt_cb
				}
			})
			ret_cb
		}

		F min(arr:Arr) most(arr, (<))
		F max(arr:Arr) most(arr, (>))

		# TODO: *args for consistency?
		# EXPERIMENTAL!
		F min(arr:Arr, cb:Fun) most_by_cb(arr, (<), cb)
		F max(arr:Arr, cb:Fun) most_by_cb(arr, (>), cb)
	}()
}

F *(arr:Arr, n:Int)
	collector
		for(i;n)
			arr % collect

TEST [10,20] * 2 == [10,20,10,20]


F echo(x) {
	guard x is not Str
	echo(Str(x))
}

# Built-in join() can only handle Str elements
F join(a:Arr, s:Str) {
	guard a.any((is not), Str)
	a.map(Str).join(s)
}

doc Used for command line arguments such as ['--vpc-id', my_vpc_id()].nuke_null()
doc If my_vpc_id() is null the whole array is not needed
F nuke_null(a:Arr) {
	a.any(is, Null) returns []
	a
}

TEST [1,2].nuke_null() == [1,2]
TEST [1,null].nuke_null() == []

# Can be more efficent I guess
F merge_sorted(a:Arr, b:Arr, lte:Fun) {
	al = a.len()
	bl = b.len()
	ai = 0
	bi = 0
	collector
		while ai < al or bi < bl
			econd {
				ai >= al { collect(b[bi]); bi += 1 }
				bi >= bl { collect(a[ai]); ai += 1 }
				lte(a[ai], b[bi]) { collect(a[ai]); ai += 1 }
				true { collect(b[bi]); bi += 1 }
			}
}

TEST merge_sorted([1,3,10], [0, 7], (<=)) == [0, 1, 3, 7, 10]

F sort(a:Arr) sort(a, (<=))

# Current implemetation: https://en.wikipedia.org/wiki/Merge_sort
# TODO: replacte with Timsort https://en.wikipedia.org/wiki/Timsort
F sort(a:Arr, lte:Fun) {
	# XXX: Not copied!
	a.len() <= 1 returns a
	mid = a.len() / 2
	l = a[0..mid]
	r = a[mid..null]
	merge_sorted(sort(l, lte), sort(r, lte), lte)
}

TEST sort([0,5,3,-1], (<=)) == [-1, 0, 3, 5]


F sort(a:Arr, attr:Str) a.sort(F(a, b) (.)(a, attr) <= (.)(b, attr))

TEST [{'x': 1}, {'x': 5}, {'x': 3}].sort('x') == [{'x': 1}, {'x': 3}, {'x': 5}]

F split(a:Arr, delim) {
	ret = []
	cur = []
	a.each(F(elt) {
		if elt == delim {
			ret.push(cur)
			cur = []
		} else {
			cur.push(elt)
		}
	})
	ret.push(cur)
	ret
}


F cmp(a:Arr, b:Arr) {
	ah = collector/{} a.each(collect, true)
	bh = collector/{} b.each(collect, true)
	{
		'add': bh.filter(X not in ah).keys()
		'remove': ah.filter(X not in bh).keys()
	}
}

TEST cmp([1,2], [2,3]) == {'add': [3], 'remove': [1]}

doc Compare arrays without using Hash so that '==' is used for comparison
doc and not internal '===' for Hash keys.
F compare(a:Arr, b:Arr) {
	{
		'add': b.filter(X not in a)
		'remove': a.filter(X not in b)
	}
}

F code(a:Arr) "[" + a.map(code).join(', ') + "]"

# === Hash =======================================


# --- Comparisons ---

F ==(a:Hash, b:Hash) Arr(a) == Arr(b)

F cmp(a:Hash, b:Hash) {
	ret = {'add': {}, 'remove': [], 'change': {}}
	a.each(F(k, v) {
		if k in b {
			if v != b[k] {
				ret.change[k] = b[k]
			}
		} else {
			ret.remove.push(k)
		}
	})
	b.each(F(k, v) {
		if k not in a {
			ret.add[k] = v
		}
	})
	ret
}


# --- Functional ---

# Make it built in for speed?
F each(h:Hash, cb:Fun, *args) {
	h.keys().each(F(k) cb(k, h[k], *args))
	h
}

F each_idx_key_val(h:Hash, cb:Fun, *args) {
	h.keys().each_idx_val(F(idx, k) cb(idx, k, h[k], *args))
	h
}

F map(h:Hash, mapper:Fun, *args)
	collector
		h % { collect(mapper(A, B, *args)) }

TEST {'a': 1, 'b': 2}.map(F(k, v) "${k}-$v") == ['a-1', 'b-2']
TEST {'a': 1, 'b': 2}.map(F(k, v, sep) "${k}${sep}${v}", '+') == ['a+1', 'b+2']


F mapk(h:Hash, mapper:Fun, *args)
	collector/{}
		h % { collect(mapper(A, *args), B) }

TEST mapk({"a": 1}, X+"z") == {"az": 1}


F mapv(h:Hash, mapper:Fun, *args)
	collector/{}
		h % { collect(A, mapper(B, *args)) }

TEST mapv({"a": 1}, X+1) == {"a": 2}


F mapkv(h:Hash, mapper:Fun, *args)
	collector/{}
		h % { collect(*mapper(A, B, *args)) }

TEST mapkv({"a": 1}, {[A+"zz", B+10]}) == {"azz": 11}


F filter(h:Hash, predicate:Fun, *args)
	collector/{}
		h.each(F(k, v) {
			if predicate(k, v, *args)
				collect(k, v)
		})

TEST {'a': 1, 'b': 2}.filter(F(k, v, k_eq) k == k_eq, 'a') == {'a': 1}

F all(h:Hash, predicate:Fun, *args) {
	arr = h.keys()
	l = arr.len()
	for(i;l)
		not(predicate(arr[i], h[arr[i]], *args)) returns false
	true
}

TEST {"x": 1, "y": 2}.all(F(k, v) v is Int)


F count(h:Hash, predicate:Fun, *args)
	collector/0
		h.each(F(k, v) {
			if predicate(k, v, *args)
				collect(1)
		})

TEST {'a': 1, 'b': 2, 'c': 11}.count(F(k, v) v>10) == 1

# --- Conversions ---

F Hash(arr:Arr)
	collector/{}
		arr.each(F(pair) {
			collect(*pair)
		})

TEST Hash([['a', 1], ['c', 3]]) == {'a': 1, 'c': 3}


F Hash(arr:Arr, attr:Str)
	collector/{}
		arr.each(F(v) collect(v[attr], v))

TEST Hash([{'x': 1}, {'x': 2}], 'x') == {1: {'x': 1}, 2: {'x': 2}}


F Hash(arr:Arr, cb:Fun)
	collector/{}
		arr.each(F(elt) collect(elt, cb(elt)))

TEST Hash([1,2], F(x) x*2) == {1: 2, 2: 4}


F Hash(tuple:Arr, names:Arr)
	collector/{}
		tuple.len().each(F(idx) collect(names[idx], tuple[idx]))

TEST [1,2,3].Hash(["a", "b", "c"]) == {"a": 1, "b": 2, "c": 3}


# --- Misc ---


F without(h:Hash, without_k)
	h.filter(X != without_k)

TEST {'a': 1, 'b': 2, 'c': 3}.without('a') == {'b': 2, 'c': 3}

F without(h:Hash, without_k, without_v)
	h.filter(F(k, v) not((k == without_k) and (v == without_v)))

TEST {'a': 1, 'b': 2, 'c': 3}.without('a', 1).without('b', 22) == {'b': 2, 'c': 3}


F +(a:Hash, b:Hash) {
	{**a, **b}
}


TEST {'a': 1, 'b': 2, 'c': 3} + {'b': 20, 'd': 40} == {'a': 1, 'b': 20, 'c': 3, 'd': 40}


F Strs(h:Hash) h / "$X=$Y"

TEST {'a': 1, 'b': 2}.Strs() == ['a=1', 'b=2']

F limit(h:Hash, l:Int) {
	h.len() <= l returns h
	finish = Return()
	result = {}
	h.each_idx_key_val(F(idx, k, v) {
		idx >= l throws finish(result)
		result[k] = v
	})
	# Should not reach
	result
}

TEST {"a": 1, "b": 2}.limit(3) == {"a": 1, "b": 2}
TEST {"a": 1, "b": 2}.limit(1) == {"a": 1}

F group(a:Arr, cb:Fun, *args) {
	ret = {}
	a.each(F(elt) {
		k = cb(elt, *args)
		ret.dflt(k, [])
		ret[k].push(elt)
	})
	ret
}

F code(h:Hash) {
	'{' + h.map(F(k, v) "${k.code()}: ${v.code()}").join(', ') + '}'
}

F dflt(h:Hash, k, v) {
	if k not in h {
		h[k] = v
	}
	h
}

# === Box ========================================

{
	type Box
		type FullBox(Box)
		type EmptyBox(Box)
}

F init(b:FullBox, *args) throw InvalidArgument("FullBox must be initialized with exactly one value")
F init(b:FullBox, val) b.val = val

F Bool(fb:FullBox) true
F Bool(eb:EmptyBox) false
F to_exit_code(b:Box) b.Bool().to_exit_code()

# === Integer ====================================

# --- Functional ---

F each(n:Int, cb:Fun, *args) {
	for(i;n) cb(i, *args)
	n
}

F map(n:Int, mapper:Fun, *args)
	collector
		for(i;n) collect(mapper(i, *args))

TEST 3.map(identity) == [0, 1, 2]
TEST 3.map((*), 3) == [0, 3, 6]

F times(n:Int, cb:Fun, *args) {
	for(i;n) cb(*args)
	n
}

TEST r=0; 5.times(F() r=r+2); r==10


F Int(s:Str) Int(s, 10)

TEST Int(" 100 ") == 100
TEST try Int(" XX ") catch(e:InvalidArgument) true
TEST Int(" XX ", 36) == 1221

F Int(b:Bool) if b 1 0

TEST true.Int() == 1
TEST false.Int() == 0

F code(n:Int) Str(n)


# === String =====================================


# --- Constructors ---

# TODO: escaping?
F Str(s:Str) "'$s'"


F Str(n:Null) "null"

TEST Str(null) == "null"


F Str(b:Bool) if b "true" "false"

TEST Str(true) == "true"
TEST Str(false) == "false"


F Str(a:Arr) "[${a.map(Str).join(',')}]"
F Str(h:Hash) "{" + h.map(F(k, v) "${k}=${v}").join(", ") + "}"

# --- Sugar ---

F pos(haystack:Str, needle:Str) pos(haystack, needle, 0)

TEST pos("abc", "cd") == null
TEST pos("abcdef", "cd") == 2

TEST pos("a:b:c", ":") == 1
TEST pos("a:b:c", ":", 2) == 3

F in(needle:Str, haystack:Str) pos(haystack, needle) is not Null

TEST "bc" in "abcd"
TEST "x" not in "abcd"

F '[]'(s:Str, i:Int) s[i..i+1]

TEST ("abc"[0] == "a") and ("abc"[2] == "c")
TEST try "abc"[3] == "x" catch(e:InvalidArgument) true

F '[]'(s:Str, i:Int) {
	guard i < 0
	i < 0-s.len() throws InvalidArgument("Negative index into string is (abs) larger than the string")
	s[s.len()+i]
}

TEST ("abc"[-1] == "c") and ("abc"[-3] == "a")
TEST try "abc"[-4] == "x" catch(e:InvalidArgument) true

# --- Misc utilities ---

F split(s:Str, delim:Str) {
	start = 0
	collector {
		while (p = pos(s, delim, start)) is not Null {
			collect(s[start..p])
			start = p + 1
		}
		collect(s[start..null])
	}
}

TEST ":a:bc:d:".split(":") == ["", "a", "bc", "d", ""]


F *(s:Str, n:Int) ([s]*n).join('')

# Tested with Str(Str,Int)

F Str(x, target_width:Int) x.Str().Str(target_width)

F Str(s:Str, target_width:Int) {
	l = s.len()
	pad_on_left = if target_width < 0 {
		target_width = 0 - target_width
		true
	} else {
		false
	}

	l >= target_width returns s

	padding = ' ' * (target_width - l)
	if pad_on_left {
		padding + s
	} else {
		s + padding
	}
}

# Not sure about this, might be confusing behaviour
F Str(n:Int, target_width:Int) n.Str().Str(0-target_width)

TEST Str(10,  4) == '  10'
TEST Str(10, -4) == '10  '
TEST Str("x", 3) == 'x  '
TEST Str("x",-3) == '  x'

F starts_with(haystack:Str, needle:Str) {
	needle.len() > haystack.len() returns false
	haystack[0..needle.len()] == needle
}

TEST "abcd".starts_with("ab")
TEST "ab".starts_with("abcd") == false

F ends_with(haystack:Str, needle:Str) {
	needle.len() > haystack.len() returns false
	l = haystack.len()
	haystack[l - needle.len()..l] == needle
}

TEST "abcd".ends_with("cd")
TEST "ab".ends_with("cdab") == false


doc Case-insensitive LessThan or Equal comparison for strings
F lte(a:Str, b:Str)
	c_strcasecmp(a, b) <= 0

F '<='(a:Str, b:Str)
	c_strcmp(a, b) <= 0

F lines(s:Str) {
	# Note: Max OS <= 9 line separation of CR (\r) is not supported
	not(s) returns []
	s -= MaybeSfx('\n')
	s.split('\n').map((-), MaybeSfx('\r'))
}

F lines(a:Str, cb:Fun, *args) {
	lines(a).each(cb, *args)
}

# TEST "xx\nyy".lines() == %[xx yy]

doc Prepend each line in a with s
F +(s:Str, a:Arr) {
	guard a.all(is, Str)
	a.map(s+X)
}
TEST "a " + ["1", "2"] == ["a 1", "a 2"]

doc Append s to each line in a
F +(a:Arr, s:Str) {
	guard a.all(is, Str)
	a.map(X+s)
}
TEST ["1", "2"] + " a" == ["1 a", "2 a"]

F limit(s:Str, n:Int, marker:Str='') {
	s.len() <= n returns s
	if marker {
		lim = n - len(marker)
		s[0..lim] + marker
	} else {
		s[0..n]
	}
}

TEST "abc".limit(5, "...") == "abc"
TEST "abcdef".limit(5, "...") == "ab..."
TEST "abcdef".limit(2) == "ab"

# EXPERIMENTAL. For use with AWS Ancors.
F ~(a:Str, b:Str) a==b


F code(s:Str) {
	# XXX TODO: escaping
	"'${s}'"
}


# === RegExp =====================================

# TODO

# === Logging and status reporting (WIP) =========

# TODO: timestamps

# TODO: allow control by facility and severity
#       and maybe source component or file.

# Not sure such flexibility is needed (NGS_ERR_FD)
stdlib_error_fd = ENV.NGS_ERR_FD.Int() tor 2

F log(s:Str) {
	echo("[LOG] $s")
}

# Set DEBUG environment variable to any non-empty string to activate
F debug(s:Str) {
	# TODO: Use RingBuffer when debug is off and
	#       show last N debug messages on uncaught exception
	if try ENV['DEBUG'] {
		echo("[DEBUG ${c_getpid()} ${c_pthread_self().id()}] $s")
	}
}

F error(s:Str) {
	echo(stdlib_error_fd, "[ERROR ] $s")
}

F status(s:Str) {
	echo(stdlib_error_fd, s)
	log("(status) $s")
}

F die(a:Arr) {
	guard a.all(is, Str)
	a.each(echo, stdlib_error_fd)
	c_exit(1)
}

F die(s:Str) {
	echo(stdlib_error_fd, s)
	c_exit(1)
}

# === Path =======================================

{ type Path }

F Path(s:Str) {
	p = Path()
	p.path = s
	p
}

F Bool(p:Path) c_access(p.path, C_F_OK) == 0

TEST Path('/').Bool()
TEST Path('/no-such-file').Bool() == false

# TODO: better exceptions (use correct type, not string, maybe use errno)
F find_in_path(executable_name:Str) {
	debug("[find_in_path] got ${executable_name}")
	if "/" in executable_name {
		debug("[find_in_path] leaving unprocessed ${executable_name}")
		return Path(executable_name)
	}
	path = ENV.get('PATH', '/usr/local/bin:/usr/bin:/bin:/sbin:/usr/sbin').split(':')
	debug('[find_in_path] will search')
	ret = path.map(F(dir) Path(dir / executable_name)).first()
	debug("[find_in_path] ${executable_name} found at ${ret}")
	ret is Null throws ExecutableNotFound().set('path', path).set('name', executable_name)
	ret
}

F Str(p:Path) p.path

STDLIB_PATH_SEP = '/'

F /(a:Str, b:Str) "$a$STDLIB_PATH_SEP$b"

F /(a:Path, b:Path) Path(a.path / b.path)

# === Commands and processes (WIP) ===============

# TODO: better exceptions (use correct type, not string, maybe use errno)
F dup2(oldfd:Int, newfd:Int) {
	while true {
		status = c_dup2(oldfd, newfd)
		status != -1 returns newfd
		get_c_errno() != C_EINTR throws "dup2() failed"
	}
}

# TODO: Use some thread-local copy of the environment?
#       This would allow simple handling of modifications
#       for exec'ed processes.

# TODO: detect and process errors, throw exception(s)
# TODO: better exceptions (use correct type, not string, maybe use errno)
doc Read all data
doc fd - file descriptor to read from
F read(fd:Int) {
	ret = []
	while true {
		debug("[read] will read from fd $fd")
		result = c_read(fd, 4096)
		debug("[read] read from fd $fd : <<${result}>>")
		result[0] == 0 returns ret.join('')
		if result[0] > 0 {
			ret.push(result[1])
		} else {
			e = get_c_errno()
			if e != C_EINTR {
				debug("[read] read from fd $fd failed, errno $e")
				throw "[read] failed to c_read()"
			}
		}
	}
}

# TODO: handle errors, throw exceptions
F write(fd:Int, s:Str) fd.c_write(s)

F isatty(fd:Int) {
	ret = c_isatty(fd)
	errno = get_c_errno()

	ret == 1 returns true
	ret != 0 throws "c_isatty($fd) - unknown response code $ret"

	errno in [C_EINVAL, C_ENOTTY] returns false
	errno == C_EBADF returns "c_isatty($fd) - invalid file descriptor"

	throw "c_isatty($fd) - unknown errno $errno"
}

# --- Pipe ---

# http://www.microhowto.info/howto/capture_the_output_of_a_child_process_in_c.html

{ type Pipe }

stdlib_fork_lock = Lock()

# TODO: better exceptions (use correct type, not string, maybe use errno)
F init(pipe:Pipe) {
	result = c_pipe()
	# result: [result_code, read_end, write_end]
	result[0] != 0 throws "Failed to create Pipe"
	pipe.read_fd = result[1]
	pipe.write_fd = result[2]
	debug("[Pipe] created pipe with read_fd=${pipe.read_fd} and write_fd=${pipe.write_fd}")
}

STDLIB_CHILD_TO_PARENT_PIPE_DIR = 1
STDLIB_PARENT_TO_CHILD_PIPE_DIR = 2

F init(pipe:Pipe, direction:Int) {
	init(pipe)
	init(args())
}

F Str(p:Pipe) "<Pipe read_fd=${p.read_fd} write_fd=${p.write_fd}>"

# TODO: exception on fail, maybe close() wrapper for c_close()
F close_writing_end(p:Pipe) p.write_fd.c_close()
F close_reading_end(p:Pipe) p.read_fd.c_close()
F write(p:Pipe, s:Str) p.write_fd.c_write(s)
F read(p:Pipe) p.read_fd.read()
F dup2_writing_end(p:Pipe, newfd:Int) dup2(p.write_fd, newfd)
F dup2_reading_end(p:Pipe, newfd:Int) dup2(p.read_fd, newfd)

F child_fd(p:Pipe) {
	guard p.direction == STDLIB_CHILD_TO_PARENT_PIPE_DIR
	p.write_fd
}

F child_fd(p:Pipe) {
	guard p.direction == STDLIB_PARENT_TO_CHILD_PIPE_DIR
	p.read_fd
}

F parent_fd(p:Pipe) {
	guard p.direction == STDLIB_CHILD_TO_PARENT_PIPE_DIR
	p.read_fd
}

F parent_fd(p:Pipe) {
	guard p.direction == STDLIB_PARENT_TO_CHILD_PIPE_DIR
	p.write_fd
}

# --- File ---

{ type FileIOFail }

F init(fail:FileIOFail, name:Str, errno:Int, message:Str) init(args())

{ type File }

F init(f:File, name:Str) {
	f.fd = null
	init(args())
}

F init(f:File, fd:Int) {
	f.fd = fd
	init(args())
}

F Str(f:File) "<File name=${f.name} fd=${f.fd}>"

TEST File('xy').Str() == '<File name=xy fd=null>'

F open(f:File, flags:Str) {
	f.fd is not Null throws FileIOFail(null, "open(f:File, flags:Str): file is already open")
	fd = c_open(f.name, flags)
	fd <= 0 throws FileIOFail(f.name, get_c_errno(), "Failed to open the file ${f.name}")
	f.fd = fd
	f
}

F basename(s:Str) $(basename $s).Str() - Sfx('\n')

# --- Redir ---

F Str(r:Redir) "<Redirect ${r.fd} ${r.marker} ${r.datum}>"

# --- Process ---

{
	type Process
	type ExecutableNotFound(Exception)
}

F '.'(p:Process, attr:Str) {
	guard attr == 'stdout'
	p.outputs[1]
}

F '.='(p:Process, attr:Str, v) {
	guard attr == 'stdout'
	p.outputs[1] = v
}

F '.'(p:Process, attr:Str) {
	guard attr == 'stderr'
	p.outputs[2]
}

F '.='(p:Process, attr:Str, v) {
	guard attr == 'stderr'
	p.outputs[2] = v
}

F finished_ok(p:Process) p.exit_code == 0

F finished_ok(p:Process) {
	guard p.executable.path == '/bin/false'
	p.exit_code == 1
}

F finished_ok(p:Process) {
	guard p.executable.path == '/usr/bin/test'
	p.exit_code in [0, 1]
}

F finished_ok(p:Process) {
	guard p.executable.path == '/bin/ping'
	p.exit_code in [0, 1]
}

F init(p:Process, c:Command) {
	p.command = c
	p.executable = null
	p.pid = null
	p.exit_code = null
	p.exit_signal = null
	p.pipes = {}
	p.outputs = {1:null, 2:null}
	# p.lock = Lock()
}

F Bool(p:Process) {
	p.wait()
	p.exit_code == 0
}

# TODO: better exceptions (use correct type, not string)
F wait(p:Process) {

	p.pid is Null throws "Can not wait() on Process without PID"

	p.exit_code is Int returns p

	debug("[wait] will waitpid(${p.pid})")
	w = c_waitpid(p.pid)
	debug("[wait] waitpid(${p.pid}) -> ${w}")
	p.exit_code = C_WEXITSTATUS(w[1])
	p.exit_signal = C_WTERMSIG(w[1])
	not(finished_ok(p)) throws ProcessFail(p)
	p
}

F to_exit_code(p:Process) p.wait().exit_code

F Str(p:Process) p.wait().stdout

# --- $() ---

# TODO: better exceptions (use correct type, not string)
# TODO: c_waitpid() - handle signals
# TODO: split to methods for easy behaviour modification
# TODO: capture stderr
# TODO: provide additional communication channel on additional fd?
# TODO: handle built-in commands: do not execve,
# INFO: bash - redir.c
F '$()'(c:Command) {

	# Special case: $($cmd)
	if (c.argv.len() == 1) and (c.argv[0] is Command) {
		c = c.argv[0]
	}

	debug_pfx = '[stdlib $()]'
	debug("$debug_pfx Parsed command: ${c.argv}")

	process = Process(c)
	try {
		process.executable = find_in_path(c.argv[0])
	} catch(nf:ExecutableNotFound) {
		throw ProcessFail(process).set('cause', nf).set('message', 'Executable not found')
	}
	# child fd -> Pipe
	pipes = process.pipes
	if not(c.is_top_level) {
		pipes[1] = Pipe(STDLIB_CHILD_TO_PARENT_PIPE_DIR)
	}

	c.redirects.each(F(r:Redir) {
		# WIP. Continue here: support functions and Pipe objects
	})

	pipes % { process.outputs[A] = null }

	pid = c_fork()

	pid == -1 throws "Failed to fork()"

	debug("$debug_pfx PID after fork: $pid")

	child_fds = pipes / child_fd(Y)
	parent_fds = pipes / parent_fd(Y)

	if pid == 0 {
		# === Child ===
		# TODO: -------------------- test - start --------------------

		for(i=3;i<100;i+=1) {
			if i not in child_fds {
				i.c_close()
			}
		}
		# TODO: -------------------- test - end --------------------
		parent_fds % c_close
		pipes % F(fd, pipe) {
			dup2(pipe.child_fd(), fd)
		}
		# Redirections (WIP) - start
		c.redirects.each(F(r:Redir) {

			F fd_or_dflt(fd:Int, dflt) fd
			F fd_or_dflt(fd:Null, dflt) dflt

			eswitch r.marker {
				'<'  { flags = 'r'; target_fd = fd_or_dflt(r.fd, 0); }
				'>'  { flags = 'w'; target_fd = fd_or_dflt(r.fd, 1); }
				'>>' { flags = 'a'; target_fd = fd_or_dflt(r.fd, 1); }
			}

			# TODO: Maybe support File or some other datum types later?
			if r.datum is Str {
				f = File(r.datum).open(flags)
				ok = c_dup2(f.fd, target_fd)
				# TODO: better exception
				ok < 0 throws "Failed to dup2(${f.fd}, ${target_fd}). Errno ${get_c_errno()}"
			}
		})
		# Redirections (WIP) - end
		result = c_execve(process.executable.path, c.argv, ENV.Strs())
		# TODO: propagate this error to parent, don't know how yet
		throw "$debug_pfx failed to execve()"
	}

	if pid > 0 {
		# === Parent ===
		process.pid = pid
		child_fds % c_close
		debug("$debug_pfx reading all output of the child process")
		# XXX: maybe make it chunk based with c_poll() and single thread
		pipes_to_read_from = pipes ? F(fd, pipe) { pipe.direction == STDLIB_CHILD_TO_PARENT_PIPE_DIR }
		reading_threads = pipes_to_read_from.map(F(fd, pipe) {
			Thread({ process.outputs[fd] = pipe.read() })
		})
		if reading_threads {
			reading_threads.join()
		}
		debug("$debug_pfx read all output of the child process")
		parent_fds % c_close
		# debug("$debug_pfx child output was <<${process.stdout}>>")
		process.wait()
	}

	# TODO: pid < 0 => throw exception with errno

	process
}

TEST $(true).Bool()
TEST $(false).Bool() == false
TEST "$(/bin/echo -n abc)" == 'abc'

F ``(c:Command) ('$()')(c).Str()

F ````(c:Command) {
	p = ('$()')(c)
	p.stdout.parse({'process': p})
}

F parse(s:Str) parse(s, {})

F parse(s:Str, hints:Hash) s

F parse(s:Str, hints:Hash) {
	ret = FullBox(decode_json(s)) tor EmptyBox()
	guard ret
	ret.val
}

# Just the command, no processing
F '%()'(c:Command) c

F lines(p:Process) {
	p.wait()
	p.stdout.lines()
}

# TODO: ability to handle running process & it's streaming stdout
F lines(p:Process, cb:Fun, *args) {
	p.wait()
	p.stdout.lines(cb, *args)
}

# === Parse aws output ===========================
# TODO: move to separate auto-loaded file maybe?

F stdlib_aws_straighten_tags(a:Arr) a.each(stdlib_aws_straighten_tags)

F stdlib_aws_straighten_tags(h:Hash) {
	if 'Tags' in h {
		h.Tags = h.get('Tags', []).map(
			F(tag_pair) [tag_pair.Key, tag_pair.Value]
		).Hash()
	}
}

# For the case of { "SecurityGroups": [ "sg-XXXXXXXX" ] }
# Which is output of aws elb apply-security-groups-to-load-balancer --load-balancer-name SOMETHING -beame-servers-authz --security-groups sg-XXXXXXXX
F stdlib_aws_straighten_tags(s:Str) null

TEST instances = [{"Tags": [{"Key": "k", "Value": "v"},{"Key": "k2", "Value": "v2"}]}]; stdlib_aws_straighten_tags(instances); instances.Tags == [{"k": "v", "k2": "v2"}]
TEST instances = ["something"]; stdlib_aws_straighten_tags(instances); instances == ["something"]

F parse(s:Str, hints:Hash) {
	guard try hints['process'].command.argv[0] == 'aws'

	# aws ec2 create-tags/delete-tags
	s == '' returns null

	data = decode_json(s)
	guard data is Hash

	# Use the only top-level key that has array as it's value
	# Thanks goes to Elastic Beanstalk which complicates this,
	# all other APIs seem to return only one top-level key.
	# ( aws elasticbeanstalk describe-configuration-options )

	top_level_vals = data.values().filter(is, Arr)

	guard top_level_vals.len() == 1

	data = top_level_vals[0]

	# Anyone cares about Reservations? Certainly it's not the common case so...
	if data.all(has, 'ReservationId') {
		data = data.Instances.flatten()
	}
	data.stdlib_aws_straighten_tags()
}

# === config =====================================

STDLIB_CONFIG = {}

F config(k:Str) {
	# TODO: think, organize
	#       what about structured data? JSON?
	# TODO: read from config files
	# TODO: read from command line switches
	debug("[config] getting key '$k'")
	v = try ENV["NGS_$k"]
	if v {
		debug("[config] Value config for key '$k' found in the environment variable 'NGS_${k}': '$v'")
		return parse(v)
	}
	v = try STDLIB_CONFIG[k]
	if v is not Null {
		debug("Value config for key '$k' found in STDLIB_CONFIG: $v")
		return v
	}
	v
}

F config(s:Str, x) {
	debug("Configuring ${s}=${x}")
	STDLIB_CONFIG[s] = x
}

# === Match, Pfx, Sfx ============================

{
	doc Sucessfull or unsucessfull match result
	type Match

		doc Sucessfull match result
		doc matches - succsessfull matches
		type MatchY(Match)

		doc Unsucessfull match result
		type MatchN(Match)

	type MatchFail(Exception)

	type SubSeq
		doc Prefix subsequence of a sequence
		type Pfx(SubSeq)
			type MaybePfx(Pfx)
			type MustPfx(Pfx)
		doc Suffix subsequence of a sequence
		type Sfx(SubSeq)
			type MaybeSfx(Sfx)
			type MustSfx(Sfx)
}

F Bool(my:MatchY) true
F Bool(my:MatchN) false
F to_exit_code(m:Match) m.Bool().to_exit_code()

F init(mf:MatchFail, msg:Str, container, pattern) init(args())

F init(s:SubSeq, *args) throw Exception("${s.typeof().name} must be initialized with a single argument - value, given: $args")
F init(s:SubSeq, val) s.val = val

# The common case
F Pfx(val) MustPfx(val)
F Sfx(val) MustSfx(val)

F Str(s:SubSeq) "<${s.typeof().name} ${s.val}>"

F -(s:Str, pfx:Pfx) {
	s.starts_with(pfx.val) returns s[pfx.val.len()..null]
	pfx is MustPfx throws MatchFail("Given string '$s' does not start with prefix '$pfx.val'", s, pfx)
	s
}

TEST "abc" - Pfx("a") == "bc"
TEST try "abc" - Pfx("wa") catch(mf:MatchFail) true
TEST "abc" - MaybePfx("wa") == "abc"


F -(s:Str, sfx:Sfx) {
	s.ends_with(sfx.val) returns s[0 .. (s.len() - sfx.val.len())]
	sfx is MustSfx throws MatchFail("Given string '$s' does not end with suffix '$sfx.val'", s, sfx)
	s
}

TEST "abc" - Sfx("c") == "ab"
TEST try "abc" - Sfx("cd") catch(mf:MatchFail) true
TEST "abc" - MaybeSfx("cd") == "abc"

F ~(s:Str, pfx:Pfx) {
	not(s.starts_with(pfx.val)) returns MatchN()
	ret = MatchY()
	ret.matches = [pfx.val]
	ret.before = ''
	ret.after = s[pfx.val.len()..null]
	ret
}

F ~(s:Str, sfx:Sfx) {
	not(s.ends_with(sfx.val)) returns MatchN()
	ret = MatchY()
	ret.matches = [sfx.val]
	ret.before = s[0..(s.len() - sfx.val.len())]
	ret.after = ''
	ret
}

# === Fun ========================================

F *(cb:Fun, n:Int, *args) n.map(F(idx) cb(*args))

# TEST a = Box * 2; a[0] is Box and a[1] is Box and a[0] != a[1]

# === Null =======================================

F code(n:Null) "null"


# === uncaught_exception_hook ====================

F exception_specific_message(e:Exception) null

F exception_specific_message(gnf:GlobalNotFound) "Global '${gnf.name}' not found"

F inspect(val) ["$val"]
F inspect(r:Real) ["Real: $r"]
F inspect(i:Int) ["Int: $i"]
F inspect(s:Str) ["String: $s"]
F inspect(a:Arr) ["Array of size ${a.len()}"] + a.map_idx_val("[$X] = $Y")
F inspect(h:Hash) ["Hash of size ${h.len()}"] + h.map("[$X] = $Y")

F inspect(p:Process) {
	collector {
		collect("Process")
		collect("command = ${p.command}")
		collect("pid = ${p.pid}")
		collect("exit_code = ${p.exit_code}")
		collect("exit_signal = ${p.exit_signal}")
		%[stdout stderr].each(F(attr) {
			val = (.)(p, attr)
			val_lines = if val is not Null {
				val.lines()
			} else {
				[]
			}
			collect("$attr (${val_lines.len()} lines):")
			if val_lines {
				("  " + val_lines) % collect
			}
		})
	}
}


F print_exception(e:Exception, level:Int = 0, parent:Exception = null) {

	F err(message:Str) error("$pfx$message")

	pfx = "  " * level
	h = Hash(e)

	err("Exception of type ${e.typeof().name} occured")

	if esm = exception_specific_message(e) {
		err(esm)
	}

	if 'message' in h {
		err("Message: ${h.message}")
	}

	info_keys = h.keys() - %[message backtrace cause]

	F print_info(k) {
		out = inspect(h[k])
		assert(out is Arr)
		assert(out.len() > 0)
		if out.len() == 1 {
			err("Info: $k = ${out[0]}")
		} else {
			err("Info: $k:")
			("  " + out) % err
		}

		# err("Info: $k is hash of size ${h[k].len()}")
	}

	info_keys % print_info

	if 'backtrace' in h {

		parent_frames = parent.backtrace.frames tor []

		h.backtrace.frames.each_idx_val(F(idx, frame) {

			# Don't print frames that overlap with parent exception
			frame.ip == (try parent_frames[idx].ip) returns null

			l = resolve_instruction_pointer(frame.ip)
			closure = " [in ${frame.closure.attrs().name}]" tor ''
			err("Frame $idx: ${l.file}:${l.first_line}:${l.first_column} - ${l.last_line}:${l.last_column}$closure")
		})
	}

	if 'cause' in h {
		err("Cause:")
		print_exception(e.cause, level+1, e)
	}

}

F uncaught_exception_hook(e:Exception) {
	print_exception(e)
	c_exit(1)
}

# === Misc tests =================================

# expr1 op= expr2
TEST a = 1; a+=1 ; a*=10; a == 20
TEST a=[{"x": 7}, {"x": 8}]; a .= x; a == [7, 8]
TEST a=[1,2]; a .= map(F(x) x*2); a[0]+=10; a == [12,4]

TEST o = {'a': 1, 'b': [null, false, true, 3.14], 'nothing': null}; decode_json(encode_json(o)) == o
TEST h={'a': 1, 'b': 2, 'c': 3}; h.update({'b': 20, 'd': 40}); h == {'a': 1, 'b': 20, 'c': 3, 'd': 40}

TEST F opt(a, b=10, *rest) [b, rest]; opt(1) == [10, []]
TEST F opt(a, b=10, *rest) [b, rest]; opt(1, 2) == [2, []]
TEST F opt(a, b=10, *rest) [b, rest]; opt(1, 2, 3) == [2, [3]]
TEST F opt(a, b=10, *rest) [b, rest]; opt(1, b=10) == [10, []]
TEST F opt(a, b=10, *rest, **kw) [b, rest, kw]; opt(1, b=20) == [20, [], {"b": 20}]
TEST F opt(a, b=10, *rest, **kw) [b, rest, kw]; opt(1, c=20) == [10, [], {"c": 20}]
TEST F opt(a, b=10, *rest) [b, rest]; try opt(1, c=20) == [10, []] catch(e:ImplNotFound) true
TEST F opt(a, b=10, *rest, **kw) [b, rest, kw]; opt(1, b=30, **{"b": 20}) == [20, [], {"b": 20}]
TEST F opt(a, b=10, *rest, **kw) [b, rest, kw]; opt(1, b=30, **{"b": 20}, b=40) == [40, [], {"b": 40}]
TEST F opt(a, b=10, *rest, **kw) [a, b, rest, kw]; opt(1, 100, 200, **{"b": 20}, b=40) == [1, 100, [200], {"b": 40}]
TEST F f(a) a; f(**{"a": 10}) == 10
TEST F f(a=7) a; f(**{"a": 10}) == 10

TEST F construct(x:Int) F() x; f1=construct(1); f2=construct(2); (f1==f1) and (f1!=f2)
TEST 1.1 < 1.11
TEST 1.1 + 1.1 == 2.2
TEST F uniq_attrs_func() "some body"; uniq_attrs_func[0].attrs({"a": 1}); uniq_attrs_func[0].attrs() == {"a": 1}
TEST attrs((+)[0])['name'] == '+'
# TODO: more introspection tests
TEST params((+)[0])[0]['name'] == 'a'
TEST params((+)[0])[0]['type'] === Real
TEST "config" in globals()
TEST args=['1', '+', '2']; $(expr $*args).Str()[0..1] == '3'
TEST time() > 1466662171
TEST a=[10,20,30]; f=a[X]; f(1) == 20
TEST a=[10,20,30]; f=X[1]; f(a) == 20

# === Exceptions tests ===========================
TEST h={}; try h["a"] catch(e:KeyNotFound) true
TEST a=[]; try a[0] catch(e:IndexNotFound) true
TEST a=[]; try a[0]=1 catch(e:IndexNotFound) true
TEST type T; try T().xyz catch(e:AttrNotFound) true
TEST try NO_SUCH_GLOBAL catch(e:GlobalNotFound) true
TEST try c_lseek(0, 0, "bad arg") catch(e:InvalidArgument) true
TEST try compile("xyz(", "something") catch(e:CompileFail) true
TEST try 1(2, 3) catch(e:DontKnowHowToCall) true
TEST type T; try echo(T(), T()) catch(e:ImplNotFound) true
TEST try F f() f(); try f() catch(e:StackDepthFail) true
