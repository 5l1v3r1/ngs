%{
#include <string.h>
#include "ngs.h"
#include "ast.h"

// gcc still warns about unused yymatchDot() and yyAccept(). clang does not.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#define YY_CTX_LOCAL 1

#define YY_MAX_LINES (10000)

#define YYSTYPE ast_node*
#define YY_CTX_MEMBERS \
	int fail_pos, seq_pos; \
	char *fail_rule; \
	int lines, lines_postions[YY_MAX_LINES];

#define YYMALLOC(size)        NGS_MALLOC(size)
#define YYREALLOC(ptr, size)  NGS_REALLOC(ptr, size)
#define YYFREE(ptr)           (void)(ptr)

#define YY_INPUT(yy, buf, result, max_size)		\
  { \
    int yyc = getchar(); \
	if(yyc == EOF) { \
		result = 0; \
	} else { \
		*(buf) = yyc; \
		yy->seq_pos++; \
		if(yyc == '\n') { \
			yy->lines++; \
			assert(yy->lines < YY_MAX_LINES); \
			yy->lines_postions[yy->lines] = yy->seq_pos; \
		} \
		yyprintf((stderr, "<%c>", yyc)); \
		result = 1; \
	} \
  }

void position_to_line_col();

#define ALLOC_NODE(dst, type_) (dst) = NGS_MALLOC(sizeof(ast_node)); dst->type=type_
#define CAPTURE_LOCATION(name) { \
	name->location.first_line = location[0]; \
	name->location.first_column = location[1]; \
	name->location.last_line = location[2]; \
	name->location.last_column = location[3]; \
}
#define MAKE_NODE(name, type_) \
	ast_node *name = NGS_MALLOC(sizeof(*name)); name->type = type_; \
	CAPTURE_LOCATION(name) \
	DEBUG_PARSER("[ast_node] at %p type %3d (%-12s) %d:%d-%d:%d\n", name, name->type, NGS_AST_NODE_TYPES_NAMES[name->type], name->location.first_line, name->location.first_column, name->location.last_line, name->location.last_column);
// TODO: check whether it's appropriate to use Boehm's "atomic" allocation.
#define COPY_NODE(dst, src) (dst) = NGS_MALLOC(sizeof(ast_node)); memcpy((dst), (src), sizeof(ast_node))
#define MAKE_REQ_ARG_NODE(name, val) MAKE_NODE(name, ARG_NODE); name->first_child = val; val->next_sibling = NULL;
#define PREPEND_NODE(list, elt) elt->next_sibling = list->first_child; list->first_child = elt;

#define HANDLE_FAILED_MATCH(rule_name) \
	if(yy->__pos > yy->fail_pos) {\
		yy->fail_pos = yy->__pos; \
		yy->fail_rule = rule_name; \
	}


void append_ast_node_child(ast_node *target, ast_node *child) {
	// printf("TARGET %p, CHILD %p\n", target, child);
	if(!target->first_child) {
		target->first_child = child;
		target->last_child = child;
		return;
	}
	target->last_child->next_sibling = child;
	target->last_child = child;
}

%}

start = 
	commands eof

eof = !.

space = [ \t\n]+
inline_space = [ \t]+
newline_space = (inline_space? [\n]+ inline_space?)+

commands =
	space? c:command commands-separator cs:commands {
		if(c) {
			PREPEND_NODE(cs, c);
		}
		$$ = cs;
		CAPTURE_LOCATION($$);
	}
	|
	c:command commands-separator? space? {
		MAKE_NODE(ret, EXPRESSIONS_NODE);
		ret->first_child = c;
		ret->last_child = c;
		$$ = ret;
		CAPTURE_LOCATION($$);
	}
	|
	{
		MAKE_NODE(ret, EXPRESSIONS_NODE);
		ret->first_child = NULL;
		ret->last_child = NULL;
		$$ = ret;
	}

commands-separator = newline_space | inline_space? [;] inline_space?
items-separator = newline_space | inline_space? [,] space?

comment =
  "#" [^\n]+ { $$ = NULL; }
  |
  "//" [^\n]+ { $$ = NULL; }

command =
	curly-code-block
	|
	assignment
	|
	function-definition
	|
	function-call
	|
	if
	|
	while
	|
	for
	|
	comment
	# | execute_external_prog

curly-code-block =
	space? '{' space? code:expressions space? ";"? space? '}' {
		$$ = code;
	}

code-block = curly-code-block | expression

expressions =
	e:expression expression-delimiter es:expressions {
		if(e) {
			PREPEND_NODE(es, e);
		}
		$$ = es;
		CAPTURE_LOCATION($$);
	}
	|
	e:expression {
		MAKE_NODE(ret, EXPRESSIONS_NODE);
		ret->first_child = e;
		ret->last_child = e;
		$$ = ret;
	}

expression-delimiter =
	newline_space
	|
	inline_space? ";" space?

expression =
	comment
	|
	e:set-item-expression comment? { $$ = e; }


set-item-expression =
	binop-expression

binop-expression =
	e1:chain-expression (b:binop e2:chain-expression {
		// TODO: cleaner code and better naming
		MAKE_NODE(args, ARGS_NODE);
		b->next_sibling = args;
		if(e1->type == CALL_NODE && e1->number && e1->number < b->number) {
			MAKE_NODE(next_node, CALL_NODE);
			next_node->first_child = b;
			next_node->number = b->number;
			MAKE_REQ_ARG_NODE(a2, e2);
			// printf("AHA TAKING\n");
			// print_ast(e1->first_child->next_sibling->first_child->next_sibling, 0);
			args->first_child = e1->first_child->next_sibling->first_child->next_sibling;
			args->first_child->next_sibling = a2;
			MAKE_REQ_ARG_NODE(arg_for_next_node, next_node);
			e1->first_child->next_sibling->first_child->next_sibling = arg_for_next_node;
		} else {
			MAKE_NODE(ret, CALL_NODE);
			ret->first_child = b;
			ret->number = b->number;
			// args
				MAKE_REQ_ARG_NODE(a1, e1);
				MAKE_REQ_ARG_NODE(a2, e2);
				a1->next_sibling = a2;
				args->first_child = a1;
			e1 = ret;
		}
		if(e1->first_child && e1->first_child->type == IDENTIFIER_NODE) {
			ast_node *ret = NULL;
			if(!strcmp("and", e1->first_child->name)) { ALLOC_NODE(ret, AND_NODE); }
			if(!strcmp("or", e1->first_child->name)) { ALLOC_NODE(ret, OR_NODE); }
			if(ret) {
				//                                              identifier      args         arg0
				ret->first_child               = e1->first_child->next_sibling->first_child->first_child;
				//                                              identifier      args         arg0          arg1
				ret->first_child->next_sibling = e1->first_child->next_sibling->first_child->next_sibling->first_child;
				CAPTURE_LOCATION(ret);
				e1 = ret;
			}
		}
	}
	|
	"." i:identifier "(" space? fcall_args:function-call-arguments space? ")" {
		// e1.method(...) => method(e1, ...)
		MAKE_NODE(ret, CALL_NODE);
		ret->first_child = i;
		ret->first_child->next_sibling = fcall_args;

		// Prepend first argument
		MAKE_REQ_ARG_NODE(a1, e1);
		a1->next_sibling = fcall_args->first_child;
		fcall_args->first_child = a1;

		e1 = ret;
	}
	|
	space "returns" space e2:expression {
		// e1 returns e2 => if e1 { return e2 }
		MAKE_NODE(ret, IF_NODE);
			ret->first_child = e1;
			MAKE_NODE(yes, RETURN_NODE);
				yes->first_child = e2;
			e1->next_sibling = yes;
			MAKE_NODE(no, NULL_NODE);
			yes->next_sibling = no;
		e1 = ret;
	}
	)* {
		// XXX
		$$ = e1;
	}

binop = binop1 | binop2

binop1 = space? (
	  <"|">  @@ 120 @@
	| <"=="> @@ 130 @@
	| <"!="> @@ 130 @@
	| <"@?"> @@ 140 @@
	| <"@">  @@ 140 @@
	| <"<="> @@ 150 @@
	| <"<">  @@ 150 @@
	| <">="> @@ 150 @@
	| <">">  @@ 150 @@
	| <"~">  @@ 150 @@
	| <"+">  @@ 190 @@
	| <"-">  @@ 190 @@
	| <"*">  @@ 200 @@
	| <"/">  @@ 200 @@
	| <"%">  @@ 200 @@
	) space?

binop2 = space (
	  <"is not">  @@ 90 @@
	| <"is">      @@ 90 @@
	| <"throws">  @@ 50 @@
	| <"or">      @@ 60 @@
	| <"and">     @@ 60 @@
	| <"in">      @@ 70 @@
	| <"not in">  @@ 70 @@
) space {
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = strdup(yytext);
		$$ = ret;
	}

chain-expression = b:basic-expression (
		inline_space? "(" space? args:function-call-arguments space? ")" {
			MAKE_NODE(ret, CALL_NODE);
			ret->first_child = b;
			ret->first_child->next_sibling = args;
			b = ret;
		}
		|
		inline_space? "[" space? idx:expression space? "]" {
			MAKE_NODE(ret, INDEX_NODE);
			ret->first_child = b;
			ret->first_child->next_sibling = idx;
			b = ret;
		}
		|
		inline_space? "=" space? e:expression {
			MAKE_NODE(ret, ASSIGNMENT_NODE);
			b->next_sibling = e;
			ret->first_child = b;
			b = ret;
		}
	)*
	{
		$$ = b;
		CAPTURE_LOCATION($$)
	}

basic-expression =
	if
	|
	while
	|
	defined
	|
	for
	|
	comment
	|
	"null"  { MAKE_NODE(ret, NULL_NODE); $$ = ret; }
	|
	"true"  { MAKE_NODE(ret, TRUE_NODE); $$ = ret; }
	|
	"false" { MAKE_NODE(ret, FALSE_NODE); $$ = ret; }
	|
	number
	|
	string
	|
	assignment
	|
	local-declaration
	|
	function-definition
	|
	return
	|
	identifier
	|
	array-literal
	|
	hash-literal
	|
	"(" space? e:expression space? ")" { $$ = e; }

assignment =
	i:identifier space? "=" space? e:expression {
		MAKE_NODE(ret, ASSIGNMENT_NODE);
		i->next_sibling = e;
		ret->first_child = i;
		$$ = ret;
	}

function-definition =
	"F" space+ name:function-definition-name space? "(" space? params:function-definition-parameters space? ")" space? body:code-block {
		MAKE_NODE(ret, FUNC_NODE);
		ret->first_child = params;
		params->next_sibling = body;
		body->next_sibling = name;
		$$ = ret;
	}

function-definition-name = i:identifier { $$ = i; } | { $$ = NULL; }

function-definition-parameters =
	param:function-definition-parameter space? "," space? params:function-definition-parameters {
		PREPEND_NODE(params, param);
		$$ = params;
		CAPTURE_LOCATION($$);
	}
	|
	param:function-definition-parameter {
		MAKE_NODE(ret, PARAMS_NODE);
		ret->first_child = param;
		ret->last_child = param;
		$$ = ret;
	}
	|
	{
		MAKE_NODE(ret, PARAMS_NODE);
		$$ = ret;
	}

function-definition-parameter =
	i:identifier t:function-definition-parameter-type {
		MAKE_NODE(ret, PARAM_NODE);
		i->next_sibling = t;
		ret->first_child = i;
		$$ = ret;
	}

function-definition-parameter-type =
	space? ":" space? c:code-block { $$ = c; }
	|
	{
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = "Any";
		$$ = ret;
	}

function-call =
	f:basic-expression inline_space? "(" space? args:function-call-arguments space? ")" {
		MAKE_NODE(ret, CALL_NODE);
		ret->first_child = f;
		ret->first_child->next_sibling = args;
		$$ = ret;
	}

function-call-arguments =
	arg:function-call-argument space? "," space? args:function-call-arguments {
		PREPEND_NODE(args, arg);
		$$ = args;
		CAPTURE_LOCATION($$);
	}
	|
	arg:function-call-argument {
		MAKE_NODE(ret, ARGS_NODE);
		ret->first_child = arg;
		ret->last_child = arg;
		$$ = ret;
	}
	|
	{
		MAKE_NODE(ret, ARGS_NODE);
		$$ = ret;
	}

function-call-argument =
	i:identifier space? "=" space? e:expression {
		MAKE_NODE(ret, ARG_NODE);
		ret->first_child = e;
		e->next_sibling = i;
		$$ = ret;
	}
	|
	e:expression {
		MAKE_NODE(ret, ARG_NODE);
		ret->first_child = e;
		e->next_sibling = NULL;
		$$ = ret;
	}

array-literal =
		"[" space? "]" {
				MAKE_NODE(ret, ARR_LIT_NODE);
				$$ = ret;
		}
		| "[" items:array-items space? ","? space? "]" {
				$$ = items;
				CAPTURE_LOCATION($$);
		}

array-items =
		acc:array-literal-node expression { append_ast_node_child(acc, $$); } (items-separator expression { append_ast_node_child(acc, $$); })* {
			$$ = acc;
			CAPTURE_LOCATION($$);
		}

array-literal-node = {
		MAKE_NODE(ret, ARR_LIT_NODE);
		$$ = ret;
}

hash-literal =
		"{" space? "}" {
				MAKE_NODE(ret, HASH_LIT_NODE);
				$$ = ret;
		}
		| "{" space? items:hash-items space? ","? space? "}" {
				$$ = items;
		}

hash-items =
		acc:hash-literal-node hash-item { append_ast_node_child(acc, $$); } (items-separator hash-item { append_ast_node_child(acc, $$); })* {
			$$ = acc;
			CAPTURE_LOCATION($$);
		}

hash-item =
		k:expression space? ":" space? v:expression {
			MAKE_NODE(ret, EXPRESSIONS_NODE);
			ret->first_child = k;
			ret->last_child = v;
			k->next_sibling = v;
			$$ = ret;
		}

hash-literal-node = {
		MAKE_NODE(ret, HASH_LIT_NODE);
		$$ = ret;
}

for =
	for-i-n
	|
	for-start-cond-incr

for-start-cond-incr =
	"for" space? "(" init:code-block ";" space? cond:code-block space? ";" space? incr:code-block space? ")" space? body:code-block {
		MAKE_NODE(ret, FOR_NODE);
		init->next_sibling = cond;
		cond->next_sibling = incr;
		incr->next_sibling = body;
		ret->first_child = init;
		$$ = ret;
	}

for-i-n =
	"for" space? "(" space? i:identifier space? ";" space? e:code-block space? ")" space? body:code-block {
		MAKE_NODE(ret, FOR_NODE);

			MAKE_NODE(init_node, ASSIGNMENT_NODE);
			ret->first_child = init_node;
				COPY_NODE(init_node->first_child, i);
				ALLOC_NODE(init_node->first_child->next_sibling, NUMBER_NODE);
				init_node->first_child->next_sibling->number = 0;

			MAKE_NODE(cond_node, CALL_NODE);
			init_node->next_sibling = cond_node;
				ALLOC_NODE(cond_node->first_child, IDENTIFIER_NODE);
				cond_node->first_child->name = "<";
				MAKE_NODE(cond_args, ARGS_NODE);
					MAKE_NODE(cond_arg1, ARG_NODE);
						COPY_NODE(cond_arg1->first_child, i);
						cond_arg1->first_child->next_sibling = NULL;
					MAKE_NODE(cond_arg2, ARG_NODE);
						COPY_NODE(cond_arg2->first_child, e);
						cond_arg2->first_child->next_sibling = NULL;
					cond_arg1->next_sibling = cond_arg2;
					cond_args->first_child = cond_arg1;
				cond_node->first_child->next_sibling = cond_args;

			MAKE_NODE(incr_node, ASSIGNMENT_NODE);
			cond_node->next_sibling = incr_node;

				COPY_NODE(incr_node->first_child, i);

				MAKE_NODE(incr_plus_node, CALL_NODE);
				incr_node->first_child->next_sibling = incr_plus_node;
					ALLOC_NODE(incr_plus_node->first_child, IDENTIFIER_NODE);
					incr_plus_node->first_child->name = "+";

					MAKE_NODE(incr_plus_args, ARGS_NODE);
						MAKE_NODE(incr_plus_arg1, ARG_NODE);
							COPY_NODE(incr_plus_arg1->first_child, i);
							incr_plus_arg1->first_child->next_sibling = NULL;
						MAKE_NODE(incr_plus_arg2, ARG_NODE);
							ALLOC_NODE(incr_plus_arg2->first_child, NUMBER_NODE);
							incr_plus_arg2->first_child->number = 1;
							incr_plus_arg2->first_child->next_sibling = NULL;
						incr_plus_arg1->next_sibling = incr_plus_arg2;
						incr_plus_args->first_child = incr_plus_arg1;
					incr_plus_node->first_child->next_sibling = incr_plus_args;

			incr_node->next_sibling = body;

		$$ = ret;
	}

if =
	"if" space? cond:code-block space? yes:code-block no:if-optional-else-block {
		MAKE_NODE(ret, IF_NODE);
		ret->first_child = cond;
		cond->next_sibling = yes;
		yes->next_sibling = no;
		$$ = ret;
	}

if-optional-else-block =
	space? c:code-block { $$ = c; }
	|
	{ MAKE_NODE(ret, NULL_NODE); $$ = ret; }

while =
	"while" space? cond:code-block space? body:code-block {
		MAKE_NODE(ret, WHILE_NODE);
		ret->first_child = cond;
		cond->next_sibling = body;
		$$ = ret;
	}

number = 
	<[-+]?[0-9]+> {
		MAKE_NODE(ret, NUMBER_NODE);
		ret->number = atoi(yytext);
		$$ = ret;
	}

identifier =
	<[_a-zA-Z]+[_a-zA-Z0-9]*> {
		 MAKE_NODE(ret, IDENTIFIER_NODE);
		 ret->name = strdup(yytext);
		 $$ = ret;
	}

defined =
	"defined" space i:identifier {
		MAKE_NODE(ret, DEFINED_NODE);
		ret->first_child = i;
		$$ = ret;
	}

local-declaration =
	"local" space i:identifier {
		MAKE_NODE(ret, LOCAL_NODE);
		ret->first_child = i;
		$$ = ret;
	}

string =
	# TODO: backslash sequences
	string-sq | string-dq

string-sq =
	"'" acc:str-comps-node (string-sq-imm { append_ast_node_child(acc, $$); })* "'" {
		$$ = acc;
	}

string-dq =
	"\"" acc:str-comps-node (string-dq-imm { append_ast_node_child(acc, $$); } | string-dq-dollar-expansion { append_ast_node_child(acc, $$); })* "\"" {
		$$ = acc;
	}

string-sq-imm =
	<[^\']+> {
		MAKE_NODE(content, STR_COMP_IMM_NODE);
		content->name = strdup(yytext);
		$$ = content;
	}

string-dq-imm =
	<[^$\"]+> {
		MAKE_NODE(content, STR_COMP_IMM_NODE);
		content->name = strdup(yytext);
		$$ = content;
	}

string-dq-dollar-expansion = "$" c:code-block { $$ = c; }

str-comps-node = {
		MAKE_NODE(ret, STR_COMPS_NODE);
		$$ = ret;
}

return = "return" r:return-node (inline_space e:expression { r->first_child = e; }) { $$ = r; }
return-node = { MAKE_NODE(ret, RETURN_NODE); $$ = ret; }

%%
#undef ALLOC_NODE
#undef MAKE_NODE
#undef COPY_NODE
#undef MAKE_REQ_ARG_NODE
#undef PREPEND_NODE
#undef HANDLE_FAILED_MATCH
#pragma GCC diagnostic pop

// TODO: more efficient implementation
void position_to_line_col(yycontext *yy, int pos, int result[]) {
	int line;
	result[0] = -1;
	result[1] = -1;
	for(line=yy->lines; line>=0; line--) {
		if(yy->lines_postions[line] <= pos) {
			result[0] = line+1;
			result[1] = pos-yy->lines_postions[line]+1;
			return;
		}
	}
}
