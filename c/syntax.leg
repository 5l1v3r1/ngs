%{
#include <stdarg.h>
#include <string.h>
#include "ngs.h"
#include "ast.h"
#include "syntax.h"
#include "obj.h"

// gcc still warns about unused yymatchDot() and yyAccept(). clang does not.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-label"
#pragma GCC diagnostic ignored "-Wunused-parameter"

#define YY_CTX_LOCAL 1

#define YY_MAX_LINES (10000)

// TODO: use read()
#define YY_INPUT(yy, buf, result, max_size)		\
  { \
    int yyc = getc(yy->input_file); \
	if(yyc == EOF) { \
		result = 0; \
	} else { \
		*(buf) = yyc; \
		yy->seq_pos++; \
		if(yyc == '\n') { \
			yy->lines++; \
			assert(yy->lines < YY_MAX_LINES); \
			yy->lines_postions[yy->lines] = yy->seq_pos; \
		} \
		yyprintf((stderr, "<%c>", yyc)); \
		result = 1; \
	} \
  }

void position_to_line_col();

#define ALLOC_NODE(dst, type_) (dst) = NGS_MALLOC(sizeof(ast_node)); dst->type=type_
#define CAPTURE_LOCATION(name) { \
	name->location.first_line = location[0]; \
	name->location.first_column = location[1]; \
	name->location.last_line = location[2]; \
	name->location.last_column = location[3]; \
}
#define MAKE_NODE(name, type_) \
	ast_node *name = NGS_MALLOC(sizeof(*name)); name->type = type_; \
	CAPTURE_LOCATION(name) \
	DEBUG_PARSER("[ast_node] at %p type %3d (%-12s) %d:%d-%d:%d\n", name, name->type, NGS_AST_NODE_TYPES_NAMES[name->type], name->location.first_line, name->location.first_column, name->location.last_line, name->location.last_column);
// TODO: check whether it's appropriate to use Boehm's "atomic" allocation.
#define COPY_NODE(dst, src) (dst) = NGS_MALLOC(sizeof(ast_node)); memcpy((dst), (src), sizeof(ast_node))
#define MAKE_REQ_ARG_NODE(name, val) MAKE_NODE(name, ARG_NODE); name->first_child = val; val->next_sibling = NULL;
#define PREPEND_NODE(list, elt) elt->next_sibling = list->first_child; list->first_child = elt; if(!list->last_child) { list->last_child=elt; };

#define MAKE_IDENTIFIER_NODE(var_name, s) MAKE_NODE(var_name, IDENTIFIER_NODE); var_name->name = ngs_strdup(s);
#define MAKE_STRING_NODE(var_name, s) \
	MAKE_NODE(var_name, STR_COMPS_NODE); \
		MAKE_NODE(var_name##_comp, STR_COMP_IMM_NODE); \
		var_name##_comp->name = ngs_strdup(s); \
		append_ast_node_child(var_name, var_name##_comp);

#define HANDLE_FAILED_MATCH(rule_name) \
	if(yy->__pos > yy->fail_pos) {\
		yy->fail_pos = yy->__pos; \
		yy->fail_rule = rule_name; \
	}


void append_ast_node_child(ast_node *target, ast_node *child) {
	// printf("TARGET %p, CHILD %p\n", target, child);
	if(!target->first_child) {
		target->first_child = child;
		target->last_child = child;
		return;
	}
	target->last_child->next_sibling = child;
	target->last_child = child;
}

ast_node *wrap_in_func(ast_node *node, int location[4], int argc, ...) {
	int i;
	va_list varargs;
	ast_node *p;
	MAKE_NODE(func, FUNC_NODE);
	MAKE_NODE(params, PARAMS_NODE);

	func->first_child = params;
	params->next_sibling = node;

	va_start(varargs, argc);
	for(i=0, p=NULL; i<argc; i++) {
		MAKE_NODE(param, PARAM_NODE);
		MAKE_IDENTIFIER_NODE(param_name, va_arg(varargs, char *))
		MAKE_IDENTIFIER_NODE(param_type, va_arg(varargs, char *))
		param->first_child = param_name;
		param_name->next_sibling = param_type;
		if(p) {
			p->next_sibling = param;
		} else {
			params->first_child = param;
		}
		p = param;
	}
	va_end(varargs);
	return func;
}

%}

start = 
	commands eof

eof = !.

space = [ \t\n]+
inline_space = [ \t]+
newline_space = (inline_space? [\n]+ inline_space?)+

commands =
	space? c:command commands-separator cs:commands {
		if(c) {
			PREPEND_NODE(cs, c);
		}
		$$ = cs;
		CAPTURE_LOCATION($$);
	}
	|
	c:command commands-separator? space? {
		MAKE_NODE(ret, EXPRESSIONS_NODE);
		ret->first_child = c;
		ret->last_child = c;
		$$ = ret;
		CAPTURE_LOCATION($$);
	}
	|
	{
		MAKE_NODE(ret, EXPRESSIONS_NODE);
		$$ = ret;
	}

commands-separator = newline_space | inline_space? [;] inline_space?
items-separator = newline_space | inline_space? [,] space?

comment =
  "#" [^\n]+ { $$ = NULL; }
  |
  "TEST " [^\n]+ { $$ = NULL; }

command =
	curly-code-block
	|
	assignment
	|
	function-definition
	|
	function-call
	|
	if
	|
	while
	|
	for
	|
	comment
	|
	command-words


curly-code-block =
	space? '{' space? code:expressions space? ";"? space? '}' {
		$$ = code;
	}

code-block = curly-code-block | expression

expressions =
	e:expression expression-delimiter es:expressions {
		if(e) {
			PREPEND_NODE(es, e);
		}
		$$ = es;
		CAPTURE_LOCATION($$);
	}
	|
	e:expression {
		MAKE_NODE(ret, EXPRESSIONS_NODE);
		ret->first_child = e;
		ret->last_child = e;
		$$ = ret;
	}

expression-delimiter =
	newline_space
	|
	inline_space? ";" space?

expression =
	comment
	|
	e:set-item-expression comment? { $$ = e; }


set-item-expression =
	binop-expression

binop-expression = e:binop-expression-inner {
	// Handle special "and" and "or" nodes.
	AST_NODE_TYPE_LL *ll;
	ast_node *cur, *arg0_node;

	for(ll = yy->nodes_for_type_change; ll; ll=ll->next) {
		cur = ll->node;
		if(cur->type == ll->type) {
			// Already processed this node
			// Warn here maybe? Duplicates should not appear here.
			continue;
		}
		assert(cur->type == CALL_NODE);
		arg0_node = cur->first_child->next_sibling->first_child;
		cur->type = ll->type;
		cur->first_child = arg0_node->first_child;
		cur->first_child->next_sibling = arg0_node->next_sibling->first_child;
	}
	yy->nodes_for_type_change = NULL;
	$$ = e;
}

binop-expression-inner =
	e1:chain-expression (b:binop e2:chain-expression {
		// TODO: cleaner code and better naming
		MAKE_NODE(args, ARGS_NODE);
		b->next_sibling = args;
		if(e1->type == CALL_NODE && e1->number && e1->number < b->number) {
			MAKE_NODE(next_node, CALL_NODE);
			next_node->first_child = b;
			next_node->number = b->number;
			MAKE_REQ_ARG_NODE(a2, e2);
			args->first_child = e1->first_child->next_sibling->first_child->next_sibling;
			args->first_child->next_sibling = a2;
			MAKE_REQ_ARG_NODE(arg_for_next_node, next_node);
			e1->first_child->next_sibling->first_child->next_sibling = arg_for_next_node;
		} else {
			MAKE_NODE(ret, CALL_NODE);
			ret->first_child = b;
			ret->number = b->number;
			// args
				MAKE_REQ_ARG_NODE(a1, e1);
				MAKE_REQ_ARG_NODE(a2, e2);
				a1->next_sibling = a2;
				args->first_child = a1;
			e1 = ret;
		}
		if(e1->first_child && e1->first_child->type == IDENTIFIER_NODE) {
			ast_node_type t=0;
			AST_NODE_TYPE_LL *ll;
			if(!strcmp("and", e1->first_child->name)) { t = AND_NODE; }
			if(!strcmp("or", e1->first_child->name))  { t = OR_NODE; }
			if(t) {
				// TODO: dedup. Somehow "or" node in 'echo("a" == "a" or "b" == "b")' is registered twice
				ll = NGS_MALLOC(sizeof(*ll));
				assert(ll);
				ll->node = e1;
				ll->type = t;
				ll->next = yy->nodes_for_type_change;
				yy->nodes_for_type_change = ll;
			}
		}
	}
	|
	space "returns" space e2:expression {
		// e1 returns e2 => if e1 { return e2 }
		MAKE_NODE(ret, IF_NODE);
			ret->first_child = e1;
			MAKE_NODE(yes, RETURN_NODE);
				yes->first_child = e2;
			e1->next_sibling = yes;
			MAKE_NODE(no, NULL_NODE);
			yes->next_sibling = no;
		e1 = ret;
	}
	|
	space "throws" space e2:expression {
		// e1 throws e2 => if e1 { return e2 }
		MAKE_NODE(ret, IF_NODE);
			ret->first_child = e1;
			MAKE_NODE(yes, THROW_NODE);
				yes->first_child = e2;
			e1->next_sibling = yes;
			MAKE_NODE(no, NULL_NODE);
			yes->next_sibling = no;
		e1 = ret;
	}
	)* {
		// XXX
		$$ = e1;
	}

binop = binop1 | binop2

binop1 = space? (
	  <"|">  @@ 120 @@
	| <"=="> @@ 130 @@
	| <"!="> @@ 130 @@
	| <"@?"> @@ 140 @@
	| <"@">  @@ 140 @@
	| <"<="> @@ 150 @@
	| <"<">  @@ 150 @@
	| <">="> @@ 150 @@
	| <">">  @@ 150 @@
	| <"~">  @@ 150 @@
	| <"+">  @@ 190 @@
	| <"-">  @@ 190 @@
	| <"*">  @@ 200 @@
	| <"/">  @@ 200 @@
	| <"%">  @@ 200 @@
	| <"...">@@ 300 @@
	| <".."> @@ 300 @@
	) space?

binop2 = space op:binop2op space { $$ = op; }

binop2op =
	  <"is not">  @@ 90 @@
	| <"is">      @@ 90 @@
	| <"or">      @@ 60 @@
	| <"and">     @@ 65 @@
	| <"in">      @@ 70 @@
	| <"not in">  @@ 70 @@

chain-expression = b:basic-expression (
		inline_space? a:function-call-arguments {
			// printf("CHAIN/FCALL\n");
			MAKE_NODE(ret, CALL_NODE);
			ret->first_child = b;
			ret->first_child->next_sibling = a;
			b = ret;
		}
		|
		inline_space? "[" space? idx:expression space? "]" {
			MAKE_NODE(ret, INDEX_NODE);
			ret->first_child = b;
			ret->first_child->next_sibling = idx;
			b = ret;
		}
		|
		inline_space? "=" space? e:expression {
			MAKE_NODE(ret, ASSIGNMENT_NODE);
			b->next_sibling = e;
			ret->first_child = b;
			b = ret;
		}
		|
		"." i:identifier fcall_args:function-call-arguments {
			// b.method(...) => method(b, ...)
			MAKE_NODE(ret, CALL_NODE);
			ret->number = 900;
			ret->first_child = i;
			ret->first_child->next_sibling = fcall_args;

			// Prepend first argument
			MAKE_REQ_ARG_NODE(a1, b);
			a1->next_sibling = fcall_args->first_child;
			fcall_args->first_child = a1;

			b = ret;
		}
		|
		"." i:identifier space? "=" space? e:expression {
			MAKE_NODE(ret, CALL_NODE);
				ret->number = 901;
				MAKE_IDENTIFIER_NODE(get_attr_identifier, ".=");
				MAKE_NODE(args, ARGS_NODE);
					MAKE_STRING_NODE(attr_name_string, i->name);
					MAKE_REQ_ARG_NODE(a1, b);
					MAKE_REQ_ARG_NODE(a2, attr_name_string);
					MAKE_REQ_ARG_NODE(a3, e);
					args->first_child = a1;
					a1->next_sibling = a2;
					a2->next_sibling = a3;
				ret->first_child = get_attr_identifier;
				get_attr_identifier->next_sibling = args;

			b = ret;
		}
		|
		"." i:identifier {
			MAKE_NODE(ret, CALL_NODE);
			ret->number = 902;

				MAKE_IDENTIFIER_NODE(get_attr_identifier, ".");

				MAKE_NODE(args, ARGS_NODE);
					MAKE_REQ_ARG_NODE(a1, b);
					MAKE_STRING_NODE(attr_name_string, i->name);
					MAKE_REQ_ARG_NODE(a2, attr_name_string);
					a1->next_sibling = a2;
					args->first_child = a1;
				ret->first_child = get_attr_identifier;
				get_attr_identifier->next_sibling = args;

			b = ret;
		}
	)*
	{
		$$ = b;
		CAPTURE_LOCATION($$)
	}

basic-expression =
	if
	| while
	| defined
	| for
	| comment
	| "null"  { MAKE_NODE(ret, NULL_NODE); $$ = ret; }
	| "true"  { MAKE_NODE(ret, TRUE_NODE); $$ = ret; }
	| "false" { MAKE_NODE(ret, FALSE_NODE); $$ = ret; }
	| number
	| string
	| assignment
	| local-declaration
	| function-definition
	| return
	| collector
	| guard
	| try-catch
	| throw
	| type
	| subshell
	| identifier
	| array-literal
	| hash-literal
	| "(" space? e:expression space? ")" { MAKE_NODE(ret, EXPRESSIONS_NODE); ret->name = "()"; ret->first_child = e; ret->last_child = e; $$ = ret; }

assignment =
	i:identifier space? "=" space? e:expression {
		MAKE_NODE(ret, ASSIGNMENT_NODE);
		i->next_sibling = e;
		ret->first_child = i;
		$$ = ret;
	}

function-definition =
	"F" name:function-definition-name space? "(" space? params:function-definition-parameters space? ")" space? body:code-block {
		MAKE_NODE(ret, FUNC_NODE);
		ret->first_child = params;
		params->next_sibling = body;
		body->next_sibling = name;
		$$ = ret;
	}

function-definition-name =
	space+ i:identifier { $$ = i; }
	| space? "'" <([-|=!@?<>~+*/%()$a-zA-Z0-9.` ]|"["|"]")+> "'" {
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = ngs_strdup(yytext);
		$$ = ret;
	}
	| space? <[-|=!@?~+*/%$.`]+> {
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = ngs_strdup(yytext);
		$$ = ret;
	}
	| { $$ = NULL; }

function-definition-parameters =
	param:function-definition-parameter space? "," space? params:function-definition-parameters {
		PREPEND_NODE(params, param);
		$$ = params;
		CAPTURE_LOCATION($$);
	}
	|
	param:function-definition-parameter {
		MAKE_NODE(ret, PARAMS_NODE);
		ret->first_child = param;
		ret->last_child = param;
		$$ = ret;
	}
	|
	{
		MAKE_NODE(ret, PARAMS_NODE);
		$$ = ret;
	}

# TODO: make sure it's the last one (or the last ones are *args, **kwargs later)
# *args at any other positon is a syntax error for now
function-definition-parameter =
	"*" space? i:identifier {
		MAKE_NODE(ret, PARAM_NODE);
			MAKE_NODE(arr, IDENTIFIER_NODE);
			arr->name = "Arr";
			MAKE_NODE(splat, ARR_SPLAT_NODE);
			ret->first_child = i;
			i->next_sibling = arr;
			arr->next_sibling = splat;
		$$ = ret;
	}
	|
	i:identifier t:function-definition-parameter-type {
		MAKE_NODE(ret, PARAM_NODE);
		i->next_sibling = t;
		ret->first_child = i;
		$$ = ret;
	}

function-definition-parameter-type =
	space? ":" space? c:expression { $$ = c; }
	|
	{
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = "Any";
		$$ = ret;
	}

function-call =
	f:basic-expression inline_space? args:function-call-arguments {
		MAKE_NODE(ret, CALL_NODE);
		ret->first_child = f;
		ret->first_child->next_sibling = args;
		$$ = ret;
	}

function-call-arguments = "(" space? a:function-call-arguments-with-parens space? ")" {
	$$ = a;
}

function-call-arguments-with-parens =
	arg:function-call-argument space? "," space? args:function-call-arguments-with-parens {
		PREPEND_NODE(args, arg);
		$$ = args;
		CAPTURE_LOCATION($$);
	}
	|
	arg:function-call-argument {
		MAKE_NODE(ret, ARGS_NODE);
		ret->first_child = arg;
		ret->last_child = arg;
		$$ = ret;
	}
	|
	{
		MAKE_NODE(ret, ARGS_NODE);
		$$ = ret;
	}

function-call-argument =
	i:identifier space? "=" space? e:expression {
		MAKE_NODE(ret, ARG_NODE);
		ret->first_child = e;
		e->next_sibling = i;
		$$ = ret;
	}
	|
	"*" space? e:expression {
		MAKE_NODE(ret, ARG_NODE);
			MAKE_NODE(splat, ARR_SPLAT_NODE);
				splat->first_child = e;
			ret->first_child = splat;
		$$ = ret;
	}
	|
	e:expression {
		MAKE_NODE(ret, ARG_NODE);
		ret->first_child = e;
		$$ = ret;
	}

array-literal =
		"[" space? "]" {
				MAKE_NODE(ret, ARR_LIT_NODE);
				$$ = ret;
		}
		| "[" items:array-items space? ","? space? "]" {
				$$ = items;
				CAPTURE_LOCATION($$);
		}

array-items =
		acc:array-literal-node array-item { append_ast_node_child(acc, $$); } (items-separator array-item { append_ast_node_child(acc, $$); })* {
			$$ = acc;
			CAPTURE_LOCATION($$);
		}

array-item =
	"*" space? e:expression {
		MAKE_NODE(ret, ARR_SPLAT_NODE);
			ret->first_child = e;
		$$ = ret;
	}
	| expression

array-literal-node = {
		MAKE_NODE(ret, ARR_LIT_NODE);
		$$ = ret;
}

hash-literal =
		"{" space? "}" {
				MAKE_NODE(ret, HASH_LIT_NODE);
				$$ = ret;
		}
		| "{" space? items:hash-items space? ","? space? "}" {
				$$ = items;
		}

hash-items =
		acc:hash-literal-node hash-item { append_ast_node_child(acc, $$); } (items-separator hash-item { append_ast_node_child(acc, $$); })* {
			$$ = acc;
			CAPTURE_LOCATION($$);
		}

hash-item =
		"**" space? e:expression {
			MAKE_NODE(ret, HASH_SPLAT_NODE);
			ret->first_child = e;
			$$ = ret;
		}
		|
		k:expression space? ":" space? v:expression {
			MAKE_NODE(ret, EXPRESSIONS_NODE);
			ret->first_child = k;
			ret->last_child = v;
			k->next_sibling = v;
			$$ = ret;
		}

hash-literal-node = {
		MAKE_NODE(ret, HASH_LIT_NODE);
		$$ = ret;
}

for =
	for-i-n
	|
	for-start-cond-incr

for-start-cond-incr =
	"for" space? "(" init:code-block ";" space? cond:code-block space? ";" space? incr:code-block space? ")" space? body:code-block {
		MAKE_NODE(ret, FOR_NODE);
		init->next_sibling = cond;
		cond->next_sibling = incr;
		incr->next_sibling = body;
		ret->first_child = init;
		$$ = ret;
	}

for-i-n =
	"for" space? "(" space? i:identifier space? ";" space? e:code-block space? ")" space? body:code-block {
		MAKE_NODE(ret, FOR_NODE);

			MAKE_NODE(init_node, ASSIGNMENT_NODE);
			ret->first_child = init_node;
				COPY_NODE(init_node->first_child, i);
				ALLOC_NODE(init_node->first_child->next_sibling, NUMBER_NODE);
				init_node->first_child->next_sibling->number = 0;

			MAKE_NODE(cond_node, CALL_NODE);
			init_node->next_sibling = cond_node;
				ALLOC_NODE(cond_node->first_child, IDENTIFIER_NODE);
				cond_node->first_child->name = "<";
				MAKE_NODE(cond_args, ARGS_NODE);
					MAKE_NODE(cond_arg1, ARG_NODE);
						COPY_NODE(cond_arg1->first_child, i);
						cond_arg1->first_child->next_sibling = NULL;
					MAKE_NODE(cond_arg2, ARG_NODE);
						COPY_NODE(cond_arg2->first_child, e);
						cond_arg2->first_child->next_sibling = NULL;
					cond_arg1->next_sibling = cond_arg2;
					cond_args->first_child = cond_arg1;
				cond_node->first_child->next_sibling = cond_args;

			MAKE_NODE(incr_node, ASSIGNMENT_NODE);
			cond_node->next_sibling = incr_node;

				COPY_NODE(incr_node->first_child, i);

				MAKE_NODE(incr_plus_node, CALL_NODE);
				incr_node->first_child->next_sibling = incr_plus_node;
					ALLOC_NODE(incr_plus_node->first_child, IDENTIFIER_NODE);
					incr_plus_node->first_child->name = "+";

					MAKE_NODE(incr_plus_args, ARGS_NODE);
						MAKE_NODE(incr_plus_arg1, ARG_NODE);
							COPY_NODE(incr_plus_arg1->first_child, i);
							incr_plus_arg1->first_child->next_sibling = NULL;
						MAKE_NODE(incr_plus_arg2, ARG_NODE);
							ALLOC_NODE(incr_plus_arg2->first_child, NUMBER_NODE);
							incr_plus_arg2->first_child->number = 1;
							incr_plus_arg2->first_child->next_sibling = NULL;
						incr_plus_arg1->next_sibling = incr_plus_arg2;
						incr_plus_args->first_child = incr_plus_arg1;
					incr_plus_node->first_child->next_sibling = incr_plus_args;

			incr_node->next_sibling = body;

		$$ = ret;
	}

if =
	"if" space? cond:code-block (space "then")? space? yes:code-block no:if-optional-else-block {
		MAKE_NODE(ret, IF_NODE);
		ret->first_child = cond;
		cond->next_sibling = yes;
		yes->next_sibling = no;
		$$ = ret;
	}

if-optional-else-block =
	(space? "else" space?)? inline_space? c:code-block { $$ = c; }
	|
	{ MAKE_NODE(ret, NULL_NODE); $$ = ret; }

while =
	"while" space? cond:code-block space? body:code-block {
		MAKE_NODE(ret, WHILE_NODE);
		ret->first_child = cond;
		cond->next_sibling = body;
		$$ = ret;
	}

number = 
	<[-+]?[0-9]+> {
		MAKE_NODE(ret, NUMBER_NODE);
		ret->number = atoi(yytext);
		$$ = ret;
	}

identifier =
	<[_a-zA-Z]+[_a-zA-Z0-9]*> {
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = ngs_strdup(yytext);
		$$ = ret;
	}
	| "('" <([-|=!@?<>~+*/%()$a-zA-Z0-9.` ]|"["|"]")+> "')" {
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = ngs_strdup(yytext);
		$$ = ret;
	}
	| "(" <([-|=!@?~+*/%$<>.\[\]]+ | "is not" | "not in")> ")" {
		MAKE_NODE(ret, IDENTIFIER_NODE);
		ret->name = ngs_strdup(yytext);
		$$ = ret;
	}

defined =
	"defined" space i:identifier {
		MAKE_NODE(ret, DEFINED_NODE);
		ret->first_child = i;
		$$ = ret;
	}

local-declaration =
	"local" space l:local-node local-declaration-item { append_ast_node_child(l, $$); } (space? "," space? local-declaration-item { append_ast_node_child(l, $$); })* {
		$$ = l;
		CAPTURE_LOCATION($$);
	}

local-node = { MAKE_NODE(ret, LOCAL_NODE); $$ = ret }

local-declaration-item = i:identifier e:local-declaration-item-optional-value {
		if(!e) {
			$$ = i;
			return;
		}
		MAKE_NODE(ret, ASSIGNMENT_NODE);
		i->next_sibling = e;
		ret->first_child = i;
		$$ = ret;
	}

local-declaration-item-optional-value = (space? "=" space? e:expression) { $$ = e } | { $$ = NULL; }

string =
	# TODO: backslash sequences
	string-sq | string-dq

string-sq =
	"'" acc:str-comps-node (string-sq-imm { append_ast_node_child(acc, $$); })* "'" {
		$$ = acc;
	}

string-dq =
	"\"" acc:str-comps-node (string-dq-imm { append_ast_node_child(acc, $$); } | string-dq-dollar-expansion { append_ast_node_child(acc, $$); })* "\"" {
		$$ = acc;
	}

string-sq-imm =
	<[^\']+> {
		MAKE_NODE(content, STR_COMP_IMM_NODE);
		content->name = ngs_strdup(yytext);
		$$ = content;
	}

string-dq-imm =
	<[^$\"]+> {
		MAKE_NODE(content, STR_COMP_IMM_NODE);
		content->name = ngs_strdup(yytext);
		$$ = content;
	}

string-dq-dollar-expansion =
	"$" c:code-block { $$ = c; }
	| subshell

str-comps-node = {
		MAKE_NODE(ret, STR_COMPS_NODE);
		$$ = ret;
}

return = "return" r:return-node (inline_space e:expression { r->first_child = e; }) { $$ = r; }
return-node = { MAKE_NODE(ret, RETURN_NODE); $$ = ret; }

collector = "collector" init:collector-init space c:code-block {
		MAKE_NODE(ret, CALL_NODE);
			MAKE_IDENTIFIER_NODE(collector_identifier, "collector");
			MAKE_NODE(args, ARGS_NODE);
				MAKE_REQ_ARG_NODE(a1, init);
				MAKE_REQ_ARG_NODE(a2, wrap_in_func(c, location, 1, "collect", "Any"));
				a1->next_sibling = a2;
				args->first_child = a1;
			ret->first_child = collector_identifier;
			collector_identifier->next_sibling = args;
		$$ = ret;
		CAPTURE_LOCATION($$);
	};

collector-init =
	"/" e:expression { $$ = e; }
	| {
		MAKE_NODE(arr, ARR_LIT_NODE);
		$$ = arr;
	}

guard = "guard" space c:code-block {
	MAKE_NODE(ret, GUARD_NODE);
	ret->first_child = c;
	$$ = ret;
}

try-catch = "try" space acc:try-catch-node c:code-block { append_ast_node_child(acc, $$); }
	(space? "catch" space? "(" space? params:function-definition-parameters space? ")" space? body:code-block {
		MAKE_NODE(ret, FUNC_NODE);
		ret->first_child = params;
		params->next_sibling = body;
		append_ast_node_child(acc, ret);
	})*
	{
	$$ = acc;
	CAPTURE_LOCATION($$);
}

try-catch-node = { MAKE_NODE(ret, TRY_CATCH_NODE); $$ = ret; }

throw = "throw" space e:expression { MAKE_NODE(ret, THROW_NODE); ret->first_child = e; $$ = ret; }

# type MyType => MyType = Type('MyType')
# TODO: Style warning for identifiers starting with lower case letter
type = "type" space i:identifier {
	MAKE_NODE(ret, ASSIGNMENT_NODE);
		MAKE_NODE(call, CALL_NODE);
			MAKE_IDENTIFIER_NODE(type_identifier, "Type");
			MAKE_NODE(args, ARGS_NODE);
				MAKE_NODE(type_string, STR_COMPS_NODE);
					MAKE_NODE(type_string_comp, STR_COMP_IMM_NODE);
					type_string_comp->name = ngs_strdup(i->name);
					append_ast_node_child(type_string, type_string_comp);
				MAKE_REQ_ARG_NODE(a1, type_string);
				args->first_child = a1;
			call->first_child = type_identifier;
			type_identifier->next_sibling = args;
		ret->first_child = i;
		i->next_sibling = call;
	$$ = ret;
	CAPTURE_LOCATION($$);
}

subshell =
	"$(" cmd:command-words ")" { $$ = cmd; }
	| "``" cmd:command-words "``" { cmd->first_child->name = ngs_strdup("````"); $$ = cmd; }
	| "`" cmd:command-words "`" { cmd->first_child->name = ngs_strdup("``");  $$ = cmd; }

command-words = acc:command-node (inline_space? command-word {append_ast_node_child(acc, $$);})+ {
	$$ = acc;
	CAPTURE_LOCATION($$);
}

command-node = {
	MAKE_NODE(ret, COMMAND_NODE);
		MAKE_IDENTIFIER_NODE(f, "$()");
		append_ast_node_child(ret, f);
	$$ = ret;
}

command-word =
	<[-a-zA-Z0-9/]+> {
		MAKE_STRING_NODE(ret, yytext);
		$$ = ret;
	}
	| "$" c:code-block { $$ = c; }
	| string

%%
#undef ALLOC_NODE
#undef MAKE_NODE
#undef COPY_NODE
#undef MAKE_REQ_ARG_NODE
#undef PREPEND_NODE
#undef HANDLE_FAILED_MATCH
#pragma GCC diagnostic pop

// TODO: more efficient implementation
void position_to_line_col(yycontext *yy, int pos, int result[]) {
	int line;
	result[0] = -1;
	result[1] = -1;
	for(line=yy->lines; line>=0; line--) {
		if(yy->lines_postions[line] <= pos) {
			result[0] = line+1;
			result[1] = pos-yy->lines_postions[line]+1;
			return;
		}
	}
}
