Note that this started as internal document so things here are unformed, not final and fluid.

[inbox]

	Unsorted and undecided things go here

	* Delimited string type, such as PATH
		+ ds = DelimStr(ENV.PATH, ':'); ds.each(echo); ds.push('mypath_element')
	* digits() function?
	* completion-safe marker in scripts + completion protocol
	* Eachable type?
	* Fix inspect() and maybe others to display special symbols in strings as \x.. or alike
	* Consider Syntax for stripping last newline character in `cmd`
	* Document catch/guard combination
	* Suggested commands ("Command ... did not find any results. Try ..." - CLI menu)
	* filterk / filterv
	* Sub-typing built-in types
		* Subclass Fun? For mapper for example to know which arguments to pass and what to construct
	* method to push a value into Arr if it's not there already
	* add profiling info to ngs-debug
		+ memory allocations - where and how much
		+ opcodes stats
		+ method calls: scanned / not scanned (where in Arr the method was found)
		+ something about call sites?
	* intern strings automatically (see Python algorithm)
		+ do profiling first
	* Possible syntax of Arr[ElementsType]
		F +(s:Str, a:Arr[Str]) { ... }
		instead of
		F +(s:Str, a:Arr) { guard a.all(is, Str); ... }
		don't see any use now but for completeness: Hash[KeysType, ValuesType]
	* ASN1 parser
	* Function static variables
		F parse(s:Str, ...)
		?static? re = /myregex/
		guard s ~ re
		...
	* dig with data_struct['a', 10, *, ...]
		* Not sure about the star, maybe:
			~All
			X ~ All
	* Dynamic file names for use cases such as logger
		logger = DynFile('/var/log/...%h')
		logger.echo('my log event')
	* think about read/write vs read/echo methods naming
	* f'file literals'
	* arbitrary length integers
	* Consider shortcut syntax for ENV.MYVAR
		maybe %MYVAR ?
	* Consider shortcut syntax for ARGV[n]
		feels like less needed than ENV.MYVAR
	* Make each(), filter() and friends be able to work on endless lists
	* Some read()s do not parse() - fix or rethink
	* Bool(subtypes of Path) - kind of object (File, Dir, etc) must match to what's on disk
	* while/for should return a value?
	* Consider having chunk() method as in Ruby
	* Channels - Chan type & syntax
		Initial syntax thoughts:

		1..10 | map(X*2) | sum | echo

		a = Chan()
		b = Chan()
		1..10 | group({A % 2 ==0 }, a, b)
		a | { echo("Even number $A") }
		b | sum | { echo("Sum of odd numbers: $A") }

		F map(in:Chan, out:Chan, mapper:Fun) {
			# while in(&item) ?
			while in -> item {
				# out(mapper(item)) ?
				out <- mapper(item)
			}
		}
	* Copy stderr to both stderr and to captured .stderr of the process
	* Run exit_hook on CTRL+C (Throw exception)
	* Replace Command#options with Hash (currently Arr)
	* FIX F f(optional=[], **attrs) {...}; f(name=name)

[roadmap]

	* Phase 1 - the language (will be v0.1.0) [in progress]

		* Milestone "programming"

			* main() - match arguments and make it usable [in progress]
				* allow positional parameters as in ec2din.ngs [done]
				* allow documentation of parameters for displaying help [already have it]
				* display help when no matching main or when --help is given
				+ think of @table_args decorator for main()

			* commands syntax

				* io redirection - see F '$()'(c:Command) { ... } in stdlib.ngs [task is on hold]
					* basic redirections ( <x , >y , >>z ) [done]
					* tests for basic redirections
					* advanced redirections ( N>x , N<y, N>>z ), think of more
					* document redirections

				* pipes
					* between external commands
					* between internal commands/functions
					* between internal and external commands

			* documentation [in progress]
				* Tutorial
					+ Common types and common operations
						+ Scalars [done]
						+ Arr [done]
						+ Hash [done]
						+ RegExp [done]
						+ Other common types
					+ Control structures (if, loops, cond)
					+ Common methods
						+ Boolean
						+ Math
						+ Strings
						+ Functional
					+ Build an app - decide which
				* True values - make sure it's in
				* Hash keys comparison
				* All types documentation
				* All methods documentation
				* Exit codes (see bootstrap.ngs and ngs.c)
				* Document that inner functions are declared local
				* Language reference, good example: https://golang.org/ref/spec
				* Internals

			* files globbing
				consider special syntax such as <foo*bar>

		* Milestone "Mac OS support" (will be v0.2.0)

			+ Issue #15

		* Milestone "correct programming" (will be v0.3.0)

			* Move everything in "c" directory one level up

			* locals() - to complete globals()

			* Consider Eachable or alike for methods like F map(something, mapper:Fun, *args)

			* Make sure attrs() are implemented on all possible types

			* OP_PUSH_INT - check limits of the number

			* Make comments that begin not at beginning of line work

			* Go over methods and make sure the method X types matrix is as full as possible

			* Usage of undefined local variable - add name of the variable in exception

			* Partial application syntax
				* Make sure it works correct in expressions such as 10 + X * 2
				* Check that this works: f(X, *something, **some_kw)

			* Fix segfault in case of comments between cond clauses

			* Go over naming convention, making sure it's consistent and can be easily described in the manual

			* Binary safe strings

			* Make sure not to leak FDs to processes that NGS runs
				+ See bash-4.3/execute_cmd.c, execute_in_subshell(), "fds_to_close"

			* Make sure STACK_DEPTH is correct everywhere and add tests

			* Fix "Function does not have result value" when compiling and running an empty string

			* Implement missing local/upvar/global functionality and add tests

			* Make sure local/upvar cause exceptions when used at top-level code

			* Check what happends with misplaced local/upvar/global. Example: "F f(); global f" - function declaration causes f to be local

			* Replace all compile asserts with exceptions

			* Make sure (uncaught) exceptions go to stderr, not stdout

			* get rid of expose() ?
				+ Used in Stats
				+ Probably needs inheritance from builtin types

			* get rid of nuke_null() ?
				+ Not used in current stdlib
				+ Think of use cases justifying existence of nuke_null()

			* Low prioroty method MatchY[]

			* break / continue - disable when not in for

			* -pedantic

			* check integer overflows everywhere

			* compile
				* exceptions instead of asserts
				* disallow duplicate name for an argument

		* Milestone "threads" (will be v0.4.0)

			* Thread - Make pthread_attr_t accessible - get/set attributes

			* Thread local variables

			* Make ENV and current directory thread-local but allow access to the global ones


	* Phase 2 - the shell [not started]

		See beginning of CLI implementation in previous NGS implementation:
		https://github.com/ilyash/ngs/blob/0ed8455efe851e3c5a275290a71c38c4e718f15c/cli.ngs

		* Milestone "screen layout"

			* Processes have their own area on the screen
				+ Truncated stdout/stderr
				+ Option to view full stdout/stderr in a pager

		* Milestone "semantic output"

			* Allow navigation on the screen, choosing operations from a menu for the objects

	* Phase 3 - running code remotely

		* think about serialization and remote execution
			Probably pushing a bytecode (which we already have because the code was compiled)
			of a function that does not reference any upper-level variables, only locals and globals,
			maybe like this:

				RF myfunc(param1:Str, param2:Int, ...)

			RF means remote function and compiler checks for absence of upper-level variables references.

	* Phase 4 - assist developing

		* Local variables values in backtrace

		* tracing / debug

	* Phase 5 - nice to have

		* Consider IP and subnet literals of the form:
			1.2.3.4
			1.2.3.4/8

		* Go over "TODO"s in all *.ngs files

		* Better start time

		* benchmarks - different tasks and languages
			+ There is one task benchmark in the Makefile (time-sum target)

		* RegExp
			* c_pcre_exec() - support options?
				PCRE_NOTBOL
				PCRE_NOTEOL
			* c_pcre_study()

		* modules / namespaces

		* implement parse() wherever possible (example: IPAddr, IPNet)

		* push/pop/shift/unshift for Hash
			To be consistent with Arr, which has all of these.
			The push is regular h[k] = v while others need additional vm functionality.

		* match, ematch - some way to get the match object?

			+ Check if match is used before doing this task. Currently there is not single usage of match construct.

			For example when RegExp is implmeneted in the code

				match mystring {
					/my_regex(.*)/ { my_code }
				}

			in my_code there should be access to the match object
			The syntax might be

				match mystring {
					/my_regex(.*)/ -> my_match { my_code }
				}

			or something alike, not sure yet.
			Maybe

				match my_string my_match {
					/my_regex(.*)/ { my_code }
				}

		* Destructuring. Automatically declare the variables local, as for does.
			+ Check whether really needed. Currently would fit OK in several places in stdlib when returning few values from C calls:
				result = c_something(...)
				... result[0] ...
				... result[1] ...
				...
			* [a,b=default,*some,c]
			* {'a','b':newvar,**some,'c'=default}
			+ Not sure about the syntax.
			+ Nested?
			+ Pattern matching like [a, *other1, 100, b, *other2] ?
				+ If yes, shouldn't the syntax be tilde (~) as for RegExp/Pfx/Sfx/... ?
			+ "xyz${myvar}www" = myvar syntax for regexes? ... for consistency.
			+ {[_, dst], **args} = h means also changing function arguments?

		* text templates (stdlib with builtin parse I guess)

		* Nfile - NGS version of Makefile

		* Compile time stack depth check?

		* yaml
			* parse
			* generate

		* K M G suffixes for numbers

		* Optimize calling speed
			* Optimize obj_is_of_type()
			* Optimize vm_call matching algorithm
			* Optimize calling of unrelated methods
				+ such as F f(t:T1) and F f(t:T2) when T1 and T2 are unrelated types


[todo by priority]

	* doc
		* "local" and for() auto-local
			Describe the "local myvar" behavior and make it clear that
			for(i=0;i<n;i=i+1) will automatically declare i as local.
		* which exceptions are thrown where and their meanings
		* config()
		* other projects
			Explain how this project is different from other projects:
				+ There is a shell in Python, don't remember the name.
				( add more projects here )
	* solve the inheritance (also for "expose")
	* strings / mb_strings

[types]
	* Bin (or Bytes, later, after Str is multibyte)
	* Cloud / Compute / etc ?
	* Host
		+ ip?, public_ip, private_ip, other ips?
		+ image_id
		+ instance_id
		+ ssh_user()
		+ ssh_key()
		+ cloud type / endpoint / ... ?
	* HostsGroup
		+ refresh() or get()?
	* FSObject
		* Path
			* File
			* Dir
	* Widget
		+ Command
		+ Status
		+ Progress
		+ Pipes
	* HistoryEntry

[functions]
	* parse()
		+ allow auto-load missing implementations by extension and mime type
	* write()
	* stat(), mtime(), ...
	* file.relative_to(root)
