# TODO: load cli-specific user ini .ngs files
# TODO: history file

if not(stdout.istty()) {
	throw ["runtime", "CLI needs stdout to be a TTY"]
}

require("ngs/widgets.ngs")

sm = ScreenManager(stdin, stdout)

# Example of how to remove parts
# { prompt_contributors = prompt_contributors.filter(F(x) { x.first() != "ver" }) }
prompt_contributors = [
	["ver", F() { "NGS v" + ver }],
	["nothing_to_say", F() { null }],
	["threads", F() {
		ts = supervised_threads.filter(F(x) {x.state != "finished"})
		if(ts) {
			"jobs:" + ts.join(",")
		}
	}],
	["num", F() { n }],
	["finish", F() { "> " }],
]

supervised_threads = []
supervised_processes = []
widgets = []
thread_widget = {}
process_widgets = {}

defun cli_make_prompt(vars) {
	prompt_contributors.map(second).map(F(contributor_func) {
		(contributor_func.locals(vars))()
	}).filter().join(" ")
}

defun cli_screen_updater() {
	while 1 {
		$(sleep 2)
		supervised_processes.each(F(prc) {
			pw = process_widgets[prc.ngs_id]
			pw.stdout.text = prc.stdout.strip()
			pw.stderr.text = prc.stderr.strip()
		})
		sm.echo(widgets)
	}
}

defun native_spawn(*args) {
	# TODO: handle children threads maybe?
	prc = __super(*args)
	if thread() not in supervised_threads {
	   return prc
	}
	t = thread().id
	# echo("SPAWN", thread().id, prc.ngs_id)
	supervised_processes.push(prc)
	o = StdoutWidget()
	e = StderrWidget()
	thread_widget[t].push(o).push(e)
	process_widgets[prc.ngs_id] = {'stdout': o, 'stderr': e}
	prc
}

defun cli_main() {

	local_scope = {"x": 7}
	n = 0
	screen_updater = thread(cli_screen_updater.one())
	while true {
		n = n + 1

		# echo(supervised_threads.Bool(), [].Bool(), Bool);

		prompt_vars = {"n": n, "ver": "0.0.1"}
		prompt = cli_make_prompt(prompt_vars)

		l = sm.read(prompt)

		if l == "" {
			n = n - 1
			sm.echo(widgets)
			continue
		}
		if l == "exit" {
			echo("BYE")
			break
		}
		if l == "vars" {
			echo("VARS:", local_scope)
			continue
		}

		code = catch compile(l)
		# echo("CODE", code)
		if not(code[0]) {
			# echo("ERROR", code[1])
			widgets.push(WidgetsSeq().push(OrigCmdWidget(l)).push(ErrorWidget(String(code[1]))))
			continue
		}
		lambda_ = load(code[1]).locals(local_scope)

		t = thread(F() {
			result = catch lambda_()
		})

		t.locals()["cli_input"] = l
		t.locals()["cli_n"] = n

		supervised_threads.push(t)
		ws = WidgetsSeq().push(OrigCmdWidget(l))
		widgets.push(ws)
		thread_widget[t.id] = ws
		sm.echo(widgets)
	}

	# later # screen_updater.kill()

	rl.close()
}

{ cli_main() }
