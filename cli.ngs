# TODO: load cli-specific user ini .ngs files
# TODO: history file

if not(stdout.istty()) {
	throw ["runtime", "CLI needs stdout to be a TTY"]
}

require("ngs/widgets.ngs")

sm = ScreenManager(stdin, stdout)

# Example of how to remove parts
# { prompt_contributors = prompt_contributors.filter(F(x) { x.first() != "ver" }) }
prompt_contributors = [
	["ver", F() { "NGS v" + ver }],
	["nothing_to_say", F() { null }],
	["threads", F() {
		ts = supervised_threads.filter(F(x) {x.state != "finished"})
		if(ts) {
			"jobs:" + ts.join(",")
		}
	}],
	["num", F() { n }],
	["finish", F() { "> " }],
]

supervised_threads = []
widgets = []

defun cli_make_prompt(vars) {
	prompt_contributors.map(second).map(F(contributor_func) {
		(contributor_func.locals(vars))()
	}).filter().join(" ")
}

defun cli_screen_updater() {
	while 1 {
		$(sleep 2)
		# sm.echo(widgets)
	}
}

defun cli_main() {

	local_scope = {"x": 7}
	n = 0
	screen_updater = thread(cli_screen_updater.one())
	while true {
		n = n + 1

		# echo(supervised_threads.Bool(), [].Bool(), Bool);

		prompt_vars = {"n": n, "ver": "0.0.1"}
		prompt = cli_make_prompt(prompt_vars)

		l = sm.read(prompt)

		if l == "" {
			n = n - 1
			continue
		}
		if l == "exit" {
			echo("BYE")
			break
		}
		if l == "vars" {
			echo("VARS:", local_scope)
			continue
		}

		code = catch compile(l)
		# echo("CODE", code)
		if not(code[0]) {
			# echo("ERROR", code[1])
			widgets.push(WidgetsSeq().push(OrigCmdWidget(l)).push(ErrorWidget(String(code[1]))))
			continue
		}
		lambda_ = load(code[1]).locals(local_scope)

		t = thread(F() {
			result = catch lambda_()
		})

		t.locals()["cli_input"] = l
		t.locals()["cli_n"] = n

		supervised_threads.push(t)
		ws = WidgetsSeq().push(OrigCmdWidget(l)).push(StdoutWidget()).push(StderrWidget())
		widgets.push(ws)
		sm.echo(widgets)
	}

	# later # screen_updater.kill()

	rl.close()
}

{ cli_main() }
