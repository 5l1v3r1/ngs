# WIP: fixes after rewrite
# TODO: load cli-specific user ini .ngs files
# TODO: history file

if not(stdout.istty()) {
	throw ["runtime", "CLI needs stdout to be a TTY"]
}

require("widgets.ngs")

sm = ScreenManager(stdin, stdout)

# Example of how to remove parts:
# prompt_contributors = prompt_contributors @? X.first() != 'ver'
global cli_prompt_contributors = [
	["ver", @"NGS v$ver"],
	["nothing_to_say", @null],
	["threads", F cli_thread_prompt() {
		ts = supervised_threads.count(@ X.state != 'finished')
		if ts {
			"(${ts} jobs)"
		}
	}],
	["num", @n],
	["finish", @"> "],
]

supervised_threads = Set()
supervised_processes = Set()

defg cli_make_prompt(vars) {
	(cli_prompt_contributors @
		X[1].locals(vars).call()
	).filter().join(" ")
}

defg cli_update_screen() {
	supervised_processes.each(F(prc) {
		process_widgets = prc.meta('cli_widgets')
		process_widgets.stdout.text = prc.stdout.strip()
		process_widgets.stderr.text = prc.stderr.strip()
		process_widgets.cmd.exit_code = prc.exit_code
	})
	sm.echo()
}

defg cli_screen_updater() {
	while 1 {
		$(sleep 2)
		cli_update_screen()
	}
}

defg native_spawn(*args) {
	# TODO: handle children threads maybe?
	prc = __super(*args)
	if thread() in supervised_threads {
		supervised_processes.push(prc)
		thread_widgets = thread().meta('cli_widgets')
		o = StdoutWidget()
		e = StderrWidget()
		thread_widgets.container.push(o).push(e)

		prc.meta('cli_widgets', {
			'cmd': thread_widgets.cmd,
			'stdout': o,
			'stderr': e
		})
	}
	prc
}

defg cli_main() {

	local_scope = {"x": 7}
	n = 0
	screen_updater = thread(cli_screen_updater).run()
	while true {
		n = n + 1

		prompt_vars = {"n": n, "ver": "0.0.1"}
		prompt = cli_make_prompt(prompt_vars)

		l = sm.read(prompt)

		lambda_ = null

		if l == "" {
			n = n - 1
			sm.echo()
			continue
		}
		if l == "exit" {
			echo("BYE")
			break
		}
		if l == "vars" {
			lambda_ = @local_scope
		}

		time = `date '+%Y-%m-%d %H:%M:%S'`

		if not(lambda_) {
			code = try {
				compile(l, "cli_command_$n")
			} catch(e) {
				# echo("ERROR", code[1])
				o = OrigCmdWidget(l, time)
				o.err = 'COMP'
				e = StderrWidget()
				e.text = code[1].String()
				sm.widgets.push(WidgetsSeq().push(o).push(e))
				sm.echo()
				continue
			}

			lambda_ = load(code[1]).locals(local_scope)
		}

		t = thread(F cli_input_line_thread() {
			result = catch lambda_()
			thread_widgets = thread().meta('cli_widgets')
			cmd_widget = thread_widgets.cmd
			do_display_result = true
			if result[0] {
				ow = StdoutWidget()
				cmd_widget.exit_code = 0
				if result[1].typeof() == 'Process' {
					do_display_result = false
				}
			} else {
				ow = StderrWidget()
				# XXX: Not sure this works:
				cmd_widget.exit_code = 1
			}
			ow.text = repr(result[1])
			if do_display_result {
				thread_widgets.container.push(ow)
			}

			supervised_threads.remove(thread())

			cli_update_screen()
		})

		supervised_threads.add(t)
		cmd_widget = OrigCmdWidget(l, time)
		container_widget = WidgetsSeq()
		container_widget.push(cmd_widget)
		t.meta('cli_widgets', {
			'container': container_widget,
			'cmd': cmd_widget
		})
		sm.widgets.push(container_widget)

		t.run()
		cli_update_screen()
	}

	# later # screen_updater.kill()
}

cli_main()
