# TODO: load cli-specific user ini .ngs files
# TODO: history file

if not(stdout.istty()) {
	throw ["runtime", "CLI needs stdout to be a TTY"]
}

require("ngs/widgets.ngs")

sm = ScreenManager(stdin, stdout)

# Example of how to remove parts
# { prompt_contributors = prompt_contributors.filter(@X.first() != 'ver' ) }
prompt_contributors = [
	["ver", @"NGS v$ver"],
	["nothing_to_say", @null],
	["threads", F() {
		ts = supervised_threads.filter(@X.state != 'finished')
		if(ts) {
			"jobs:" + ts.join(",")
		}
	}],
	["num", @n],
	["finish", @"> "],
]

supervised_threads = Set()
supervised_processes = Set()

defun global cli_make_prompt(vars) {
	prompt_contributors.map(second).map(@
		(X.locals(vars))()
	).filter().join(" ")
}

defun global cli_screen_updater() {
	while 1 {
		$(sleep 2)
		supervised_processes.each(F(prc) {
			process_widgets = prc.meta('cli_widgets')
			process_widgets.stdout.text = prc.stdout.strip()
			process_widgets.stderr.text = prc.stderr.strip()
			process_widgets.cmd.exit_code = prc.exit_code
		})
		sm.echo()
	}
}

defun native_spawn(*args) {
	# TODO: handle children threads maybe?
	prc = __super(*args)
	if thread().has_meta('cli_widgets') {
		supervised_processes.push(prc)
		thread_widgets = thread().meta('cli_widgets')
		o = StdoutWidget()
		e = StderrWidget()
		thread_widgets.container.push(o).push(e)

		prc.meta('cli_widgets', {
			'cmd': thread_widgets.cmd,
			'stdout': o,
			'stderr': e
		})
	}
	prc
}

defun global cli_main() {

	local_scope = {"x": 7}
	n = 0
	screen_updater = thread(cli_screen_updater.one())
	while true {
		n = n + 1

		prompt_vars = {"n": n, "ver": "0.0.1"}
		prompt = cli_make_prompt(prompt_vars)

		l = sm.read(prompt)

		lambda_ = null

		if l == "" {
			n = n - 1
			sm.echo()
			continue
		}
		if l == "exit" {
			echo("BYE")
			break
		}
		if l == "vars" {
			lambda_ = @local_scope
		}

		time = $(date '+%Y-%m-%d %H:%M:%S').String()

		if not(lambda_) {
			code = catch compile(l)
			# echo("CODE", code)
			if not(code[0]) {
				# echo("ERROR", code[1])
				sm.widgets.push(WidgetsSeq().push(OrigCmdWidget(l, time)).push(ErrorWidget(String(code[1]))))
				continue
			}
			lambda_ = load(code[1]).locals(local_scope)
		}

		t = thread(F() {
			result = catch lambda_()
			thread_widgets = thread().meta('cli_widgets')
			cmd_widget = thread_widgets.cmd
			do_display_result = true
			if result[0] {
				ow = StdoutWidget()
				cmd_widget.exit_code = 0
				if result[1].typeof() == 'Process' {
					do_display_result = false
				}
			} else {
				ow = StderrWidget()
				# XXX: Not sure this works:
				cmd_widget.exit_code = 1
			}
			ow.text = repr(result[1])
			if do_display_result {
				thread_widgets.container.push(ow)
			}
		})

		supervised_threads.push(t)
		cmd_widget = OrigCmdWidget(l, time)
		container_widget = WidgetsSeq()
		container_widget.push(cmd_widget)
		t.meta('cli_widgets', {
			'container': container_widget,
			'cmd': cmd_widget
		})
		sm.widgets.push(container_widget)
		sm.echo()
	}

	# later # screen_updater.kill()
}

cli_main()
