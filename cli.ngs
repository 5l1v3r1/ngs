if not(stdout.istty()) {
	throw ["runtime", "CLI needs stdout to be a TTY"]
}

# TODO: load cli-specific user ini .ngs files
# TODO: history file

# Example of how to remove parts
# { prompt_contributors = prompt_contributors.filter(F(x) { x.first() != "ver" }) }
prompt_contributors = [
	["ver", F() { "NGS v" + ver }],
	["nothing_to_say", F() { null }],
	["num", F() { n }],
	["finish", F() { "> " }],
]


defun cli_make_prompt(vars) {
	prompt_contributors.map(second).map(F(contributor_func) {
		(contributor_func.locals(vars))()
	}).filter().join(" ")
}


defun cli_main() {
	rl = Readline()

	local_scope = {"x": 7}
	n = 0
	while true {
		n = n + 1

		prompt_vars = {"n": n, "ver": "0.0.1"}
		prompt = cli_make_prompt(prompt_vars)

		l = rl.read(prompt)

		if l == "" {
			n = n - 1
			continue
		}
		if l == "exit" {
			echo("BYE")
			break
		}
		if l == "vars" {
			echo("VARS:", local_scope)
			continue
		}
		code = compile(l)
		if not(code[0]) {
			echo("ERROR", code[1])
			continue
		}
		lambda_ = load(code[1]).locals(local_scope)
		result = catch lambda_()
		if result[0] {
			if result[1].typeof() == "Process" {
				echo(result[1])
			}
			echo("OK")
		} else {
			echo("FAIL", result[1])
		}
	}

	rl.close()
}

{ cli_main() }
