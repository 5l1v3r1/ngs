#!/usr/bin/env ngs
{

	# Autoload
	AWS
	ArgvMatcher
	DelimStr
	Doc
	Iter
	KV
	Lock
	Res
	ResDef
	Stats
	Table
	Thread
	test

	F main(doc_root:Str) {

		DocPart = Doc::Part
		DocNode = Doc::Node
		DocText = Doc::Text
		DocGroup = Doc::Group
		doc_visit = Doc::visit

		commit = `line: git rev-parse HEAD`

		F is_public_name(s:Str) s ~ /^[^_]/
		F is_phased_out_type(s:Str) s ~ Pfx('Aws')

		F to_lines(s:Str) [s]
		F to_lines(a:Arr) a

		F safe_file_name(s:Str) s.replace(/[^-_a-zA-Z0-9]/, F(char) '%' + encode_hex(char))
		F method_impl_id(name:Str, mi:Fun) (name + '-' + mi.params().type.name.join('-'))

		F list_methods()
			collector/{}
				globals().filterk(is_public_name).sortk(lte).each(F(name, value) {
					cond {
						(value is Arr) and value.all(Fun) {
							collect(name, value)
						}
						value is NormalType {
							# NormalType has special constructor which we can't handle for now
							# so skipping that one
							collect(name, value.constructors[1..null])
						}
						value is Type {
							collect(name, value.constructors)
						}
					}
				})

		F process_param(param:Hash, doc:Hash) {
			dflt = param.Box('dflt').map({ematch A {
				Fun Doc::Node('default-is-fun')
				Any Doc::Node('default-value', text=param.dflt.Str())
			}})
			ret = DocNode('param', name=param.name, type=param.get('type', Any), splat=param.get('splat'), doc=doc.get(param.name))
			dflt.each(ret.push(X))
			ret
		}

		F process_doc_attr(mi:Fun, attr:Str, cb:Fun) {
			d = mi.attrs().doc or {}
			d.Box(attr).map(to_lines).each(cb)
		}

		method_impls_by_id = {}

		# F process_params

		pfx = Pfx("$NGS_DIR/")
		F process_method_impl(name:Str, mi:Fun) {
			method_impls_by_id.dflt(method_impl_id(name, mi), [name]).push(mi)

			dn = DocNode('method-impl', name=name, mi=mi)
			process_doc_attr(mi, '', F(lines) {
				dn.push(DocNode('description') with [
					DocText(lines.join('\n'))
				])
			})
			if mi is Closure {
				# Handling Closure, not handling built-ins yet
				location_info = mi.ip().resolve_instruction_pointer()
				if m = location_info.file ~ pfx {
					dn.push(DocNode('source-ref', file=m.after, line=location_info.first_line))
				}
			}

			process_doc_attr(mi, '%AUTO', F(lines) {
				assert(lines.len() == 1, '%AUTO must be used at most once per method')
				dn.push(DocNode('auto') with [
					DocText(lines[0])
				])
			})

			mi_doc = mi.attrs().doc or {}
			dn.push(DocNode('params') with mi.params().map(process_param(X, mi_doc)))

			process_doc_attr(mi, '%RET', F(lines) {
				assert(lines.len() == 1, '%RET must be used at most once per method')
				dn.push(DocNode('returns') with [
					DocText(lines[0])
				])
			})
			process_doc_attr(mi, '%EX', F(lines) {
				dn.push(DocNode('example') with [
					DocText(lines.join('\n'))
				])
			})
			dn
		}

		F process_method(name, implementations) {
			status("Processing method: $name")
			DocNode('method', name=name) with
				implementations.map(process_method_impl(name, X))
		}

		doc Convert h to h1, h2, ... depending on depth (counted by number of "section" elements)
		F fix_headers(doc:DocPart) {
			doc.doc_visit(F(dp:DocPart, parents) {
				if dp is DocNode and dp.name == 'h' {
					dp.name = "h${parents.filter(DocNode).count({'name': 'section'})}"
				}
			})
			doc
		}

		F do_methods() {
			# Index page
			methods_node = DocNode('methods') with list_methods().limit(90).map(process_method)
			page_node = DocNode('root') with [methods_node]

			params_inline_transformer = {
				'default-value': F(dn:DocNode) {
					DocGroup() with [
						DocText('=')
						DocText(dn.attrs.text)
					]
				}
				'default-is-fun': F(dn:DocNode) {
					DocGroup() with [
						DocText('=')
						DocNode('span', class='non-literal') with [ DocText('method') ]
					]
				}
				'param': F(dn:DocNode) {
					# status("P $dn")
					DocNode('span', class='inline-param') with [
						DocText(dn.attrs.name)
						DocText(':')
						DocText(dn.attrs.type.name)
					] + Doc::transform(dn.children, params_inline_transformer)
				}
				'params': F(dn:DocNode) {
					DocGroup() with
						[ DocText('(') ] +
						Doc::transform(dn.children, params_inline_transformer).intersperse(DocText(', ')) +
						[ DocText(')') ]
				}
			}

			index_page_transformer = {
				'method-impl': F(dn:DocNode) {
					# dn.attrs.mi
					desc_nodes = dn.children.filter(DocNode).filter({'name': 'description'})
					mi_id = method_impl_id(dn.attrs.name, dn.attrs.mi)
					params = Doc::transform(dn.children.filter(DocNode).filter({'name': 'params'}), params_inline_transformer)
					DocNode('li') with [
						DocNode('a', href=mi_id.safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with
							[DocText(dn.attrs.name)] + params + [
								DocText(' - ')
								if desc_nodes {
									desc_nodes[0].children[0]
								} else {
									DocText('Undocumented')
								}
							]
					]
				}
				'method': F(dn:DocNode) {
					# dn.attrs.name
					DocNode('li', style='method') with [
						DocNode('a', href=dn.attrs.name.safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with [
							DocText(dn.attrs.name)
						]
						DocNode('ul') with Doc::transform(dn.children, index_page_transformer)
					].reject(F(dn) dn is DocNode and dn.name == 'ul' and not(dn.children))
					# .reject(DocNode ?? {'name': ul, children: []})
				}
				'methods': F(dn:DocNode) {
					DocNode('section', class='methods') with [
						DocNode('h') with [
							DocText('Methods index')
						]
						DocNode('ul') with Doc::transform(dn.children, index_page_transformer)
					]
				}
				'root': F(dn:DocNode) {
					DocNode('html') with [
						DocNode('head') with [
							DocNode('meta', charset='UTF-8')
							DocNode('link', rel='stylesheet', href='../main.css', type='text/css')
							DocNode('title') with [
								DocText('Methods index - NGS documentation')
							]
						]
						DocNode('body', class='methods-index-page') with [
							DocNode('nav') with [
								DocNode('ul') with [
									DocNode('li') with [
										DocNode('span', class='nav-here') with [
											DocText('Methods index')
										]
									]
								]
							]
							DocNode('main') with Doc::transform(dn.children, index_page_transformer)
						]
					]
				}
				DocText: F(t:DocText) t
			}

			index_page_html = Doc::transform(page_node, index_page_transformer).fix_headers()

			$(mkdir -p ${doc_root / 'methods'})
			$(cp main.css "$doc_root/")
			status("Writing methods index (overview) page")
			write(doc_root / 'methods/index.html', Doc::HtmlRoot(index_page_html))

			for method_node in methods_node.children {
				status("Making page for method ${method_node.attrs.name}")
				method_page_transformer = {
					'param': F(dn:DocNode) {
							# name, type, splat, dflt, doc
							# TODO later: type link
							## DocText(dn.attrs.type.name)
							DocNode('tr', class='param') with [
								DocNode('td') with [
									DocText(dn.attrs.name)
								]
								DocNode('td') with [
									DocText(dn.attrs.type.name)
								]
								DocNode('td') with [
									DocText(if dn.attrs.doc then dn.attrs.doc.to_lines().join('\n') else '-')
								]
							]
					}
					'source-ref': F(dn:DocNode) {
						# dn.attrs.file
						# dn.attrs.line
						DocNode('span', class="source-ref") with [
							DocText('Source: ')
							DocNode('a', href="https://github.com/ilyash/ngs/blob/$commit/lib/${dn.attrs.file}#L${dn.attrs.line}") with [
								DocText("${dn.attrs.file}:${dn.attrs.line}")

							]
						]
					}
					'auto':  F(dn:DocNode) {
							DocNode('section', class='auto') with [
								DocText('Automatically called by NGS for syntax:')
								DocNode('code', class='auto', title='Usage syntax') with Doc::transform(dn.children, method_page_transformer)
							]
					}
					'example':  F(dn:DocNode) {
							DocNode('section', class='example') with [
								DocNode('pre', class='example', title='Example') with Doc::transform(dn.children, method_page_transformer)
							]
					}
					'returns':  F(dn:DocNode) {
							DocNode('tr', class='returns') with [
								DocNode('td') with [
									DocNode('span', class='non-literal') with [ DocText('Returns') ]
								]
								DocNode('td') with [
									DocText('-')
								]
								DocNode('td') with Doc::transform(dn.children, method_page_transformer)
							]
					}
					'description': F(dn:DocNode) {
						DocNode('section', class='method-description') with Doc::transform(dn.children, method_page_transformer)
					}
					'method-impl': F(dn:DocNode) {
						# dn.attrs.mi
						params = dn.children.filter(DocNode).filter({'name': 'params'})[0]
						_returns = dn.children.filter(DocNode).filter({'name': 'returns'}).Box(0)
						_auto = dn.children.filter(DocNode).filter({'name': 'auto'}).Box(0)
						src_ref = dn.children.filter(DocNode).filter({'name': 'source-ref'}).Box(0)
						DocNode('dl') with [
							DocNode('dt') with [
								DocText(dn.attrs.name)
								Doc::transform(params, params_inline_transformer)
								src_ref.map(F(s) Doc::transform(s, method_page_transformer)).get(DocGroup())
							]
							DocNode('dd') with
								Doc::transform(dn.children, method_page_transformer + {
									'source-ref': { DocGroup() }
									'returns': { DocGroup() }
									'params': F(dn:DocNode) {
										ret = DocNode('table', class='params') with [
											DocNode('tr') with [
												DocNode('th') with [
													DocText('Parameter')
												]
												DocNode('th') with [
													DocText('Type')
												]
												DocNode('th') with [
													DocText('Description')
												]
											]
										] + Doc::transform(dn.children, method_page_transformer)
										_returns.each(F(r) ret.push(Doc::transform(r, method_page_transformer)))
										ret
									}
								})
						]
					}
					'method': F(dn:DocNode) {
						# dn.attrs.name
						DocGroup() with [
							DocNode('h1') with [
								DocText(dn.attrs.name)
								DocNode('span', class='unobtrusive') with [ DocText(" (method)") ]
							]
						] + Doc::transform(dn.children, method_page_transformer)
					}
					'root': F(dn:DocNode) {
						# TODO: title
						DocNode('html') with [
							DocNode('head') with [
								DocNode('meta', charset='UTF-8')
								DocNode('link', rel='stylesheet', href='../main.css', type='text/css')
								DocNode('title') with [
									DocText("${dn.attrs.name} method - NGS documentation")
								]
							]
							DocNode('body', class='method-page') with [
								DocNode('nav') with [
									DocNode('ul') with [
										DocNode('li') with [
											DocNode('a', href='index.html') with [
												DocText('Methods index')
											]
										]
										DocNode('ul') with [
											DocNode('li') with [
												DocNode('span', class='nav-here') with [
													DocText(dn.attrs.name)
													DocNode('span', class='unobtrusive') with [ DocText(" (method)") ]
												]
											]
										]
									]
								]
								DocNode('main') with Doc::transform(dn.children, method_page_transformer)
							]
						]
					}
					DocText: F(t:DocText) t
				}

				method_page_html = Doc::transform(DocNode('root', name=method_node.attrs.name) with [method_node], method_page_transformer)
				status("Writing method page: name=${method_node.attrs.name} file=${method_node.attrs.name.safe_file_name()}.html")
				write(doc_root / 'methods' / method_node.attrs.name.safe_file_name() + '.html', Doc::HtmlRoot(method_page_html))


			}


			### # Detailed method implementations pages
			### method_impls_by_id.each(F(id, impls) {
			### 	assert('/' not in id)
			### 	assert('.' not in id)
			### 	local mdn = MethodsDocNode([process_method(impls[0], impls[1..null])])
			### 	local page = TopDocNode([mdn])
			### 	local html = Html(page, {'detailed_method_page': true})
			### 	# OLD # html.Str().write("method-impl-${id}.html")
			### })
		}

		F do_types() {

			# TODO: methods with this type
			# TODO: constructors
			# TODO: child types

			# Splat params will be Arr or Hash but they are not interesting
			F method_impl_has_arg_of_type(mi:Fun, t:Type) mi.params().reject(X.get('splat')).type.has(t)

			# We'll use it to list methods that have given
			# type as type of one of the parameters.
			methods = list_methods()

			types = globals().filterv(Type).filterk(is_public_name).filterk(not + is_phased_out_type).sortk(lte)

			# Init with ( type -> [] ) pairs
			types_direct_children = types.values().Hash({ [] })

			types.values().each(F(t) {
				t.parents.each(F(p) {
					types_direct_children[p].push(t)
				})
			})


			# TODO: straighten by using ParentTypeDocNode instead of 'full' / 'leaf' option.
			F type_to_doc_node(value:Type, full:Bool) {
				# echo("N $name")
				# ret = TypeDocNode([ParentTypesDocNode(value.parents.map())])
				ret = TypeDocNode()
				ret.type = value
				# ret.full = full
				process_type_impl_doc_attr(value, ret, '', DescDocNode)
				type_attrs_dns = ((try value.attrs().doc) or {}).without('').reject(X ~ /^%/).map(F(k, v) {
					TypeAttrDocNode(v.to_lines()).set('name', k)
				})
				ret.push(TypeAttrsDocNode(type_attrs_dns))

				if full {
					process_type_impl_doc_attr(value, ret, '%EX', ExampleDocNode)
					ret.push(ParentTypesDocNode(value.parents.map(type_to_doc_node(X, false))))
					ret.push(ChildTypesDocNode(types_direct_children[value].map(type_to_doc_node(X, false))))
					methods_of_type_dns = collector
						methods.each() do F(name, impls) {
							relevant_impls = impls.filter(method_impl_has_arg_of_type(X, value)).map() do F(mi) {
								dn = TypeMethodImplDocNode([])
								dn.mi = mi
								process_method_impl_doc_attr(mi, dn, '', DescDocNode)
								dn.push(ParamsDocNode(mi.params().map(process_param(X, mi.attrs().doc or {}))))
								dn
							}
							if relevant_impls {
								dn = TypeMethodDocNode(relevant_impls)
								dn.method = name
								collect(dn)
							}
						}
					constructors_dns = value.constructors.reject(NormalTypeConstructor).map() do F(c) {
						dn = TypeMethodImplDocNode([])
						# dn.method = value.name
						dn.mi = c
						process_method_impl_doc_attr(c, dn, '', DescDocNode)
						dn.push(ParamsDocNode(c.params().map(process_param(X, c.attrs().doc or {}))))
						dn
					}
					ret.push(TypeMethodsDocNode(methods_of_type_dns))
					ret.push(TypeConstructorsDocNode(constructors_dns).set('method', value.name))
				}
				ret
			}

			types .= map(F(name, value) {
				type_to_doc_node(value, true)
			})

			# Index page
			tdn = TypesDocNode(types)
			page = TopDocNode([tdn])

			# Detailed types pages
			types.each(F(t) {
				assert('/' not in t.type.name)
				assert('.' not in t.type.name)
				local tdn = TypesDocNode([t])
				local page = TopDocNode([tdn])
				local html = Html(page, {'detailed_type_page': true})
				# OLD # html.Str().write("type-${t.type.name}.html")
			})

		}

		do_methods()

		# echo(page)
		# inspect(html_page, 5) % echo
		# each_idx_val(page.children[0].children[0].children, F(idx, val) {
		# 	log("IDX $idx")
		# 	log("KEYS ${val.Hash().keys()}")
		# 	inspect(val.Hash()).each(echo)
		# 	Str(val)
		# 	# log("ELT $val")
		# })
		# echo(hash(page))
		# echo(hash(page.children[0]))
		# echo(hash(page.children[0].children[0]))
		# echo(hash(page.children[0].children[0].children[0]))
		# echo(hash(page.children[0].children[0].children[0].children[0]))
		# echo(hash(page.children[0].children[0].children[0].children[0].children[0]))
		# echo(page.children[0].children[0].children[0].children[0].name)
		# echo(Data::find_cycle(page)[1].name)

		# echo(methods.children[-100])
	}
}


