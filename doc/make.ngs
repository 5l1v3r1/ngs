#!/usr/bin/env ngs
{

	# Autoload
	AWS
	AWS2
	ArgvMatcher
	DelimStr
	Doc
	Iter
	Res
	ResDef
	Set
	Stats
	Table
	Thread
	test

	# TODO: Do not list all types on the namespace page,
	# just up to TYPES_THRESHOLD, probably the parents.
	TYPES_THRESHOLD = 10
	g = globals()

	# TODO: types trees pages

	F main(doc_root:Str) {

		global init, Str, Bool, ([]=)

		DocPart = Doc::Part
		DocNode = Doc::Node
		DocText = Doc::Text
		DocGroup = Doc::Group

		commit = `line: git rev-parse HEAD`

		F is_public_name(s:Str) s ~ /^[^_]/
		F is_phased_out_type(s:Str) s ~ Pfx('Aws')

		F safe_file_name(s:Str) s.replace(/[^-._a-zA-Z0-9]/, F(char) '%' + encode_hex(char))

		F object_attr(x, a:Str) (x.attrs() or {}).get(a).Box()
		F object_doc(x) x.object_attr('doc')
		F object_doc_attr(x, a:Str) object_doc(x).filter(a in X).map(X[a]).map(ensure_array)

		obj_to_description = {}

		doc Setting same key twice is a bug. If it happens, augment_types() works on one objects
		doc but other objects are used later.
		F '[]='(h:Hash, k, v) {
			guard h === obj_to_description
			assert(k not in h)
			super(h, k, v)
		}

		type Description

			F href(from:Description, to:Description) {
				from_path = from.path_as_item()
				to_path = to.path_as_item()
				i = 0
				while from_path[i] == to_path[i] {
					i += 1
				}
				ret =
					('../' * (len(from_path) - i - 1)) +
					to_path[i..null].map(safe_file_name).map(encode_uri_component).join('/')
			}

			F fqname(d:Description) fqname(d.containing_nd) +? '::' + d.name

			F generate(d:Description) {
				# status("Generating page for descriptors ${d}")
				dst = (d.path_as_item().map(safe_file_name)).reduce(doc_root, (/))
				p = page(d)
				file_content = Doc::HtmlRoot(p)
				log("Writing file=${dst} description=${d} len=${file_content.len()} hash=${file_content.hash()}")
				write(dst, file_content)

				children = get_children(d)

				if children {
					d = d.path_as_container().map(safe_file_name).reduce(doc_root, (/))
					log("Ensuring directory $d exists")
					$(mkdir -p $d)
					children.each(generate)
				}
			}

			F get_children(d:Description) []

			F path_as_item(d:Description) d.containing_nd.path_as_container() + [(if d.name == 'index' then '_index' else d.name) + '.html']
			F path_as_container(d:Description) d.containing_nd.path_as_container() + [d.name]

			F head_fragment(from:Description) {
				\head [
					\meta charset='UTF-8'
					\link rel='stylesheet' href=('../' * (len(from.path_as_item()) - 1)) + 'main.css' type='text/css'
					\title [ page_title(from) ]
				]
			}

			F nav_name(d:Description) d.name

			F nav_fragment(d:Description) {

				t = d
				ns_nav = \div class='current-nav' [ nav_name(t) ]
				while 'containing_nd' in t {
					t = t.containing_nd
					ns_nav = \div class='parent-namespace-nav' [
						\a href=href(d, t) [ t.nav_name() ]
						ns_nav
					]
				}

				DocGroup() with [
					\div class='header' [
						"NGS version $VERSION auto-generated documentation"
					]
					\nav [
						\div class='nav-main' [
							\h5 [ "Namespaces" ]
							ns_nav
						]
					]
				]
			}

			F description_fragment(d:Description)
				\section class='description' [
					d.description.map(F(desc) {
						desc.join('\n')
					}).get('Undocumented')
				]

			F example_fragment(d:Description) {
				d.example.map(F(ex) {
					\section [
						\h2 ['Example']
						\pre class='example' title='Example' [
							ex.join('\n')
						]
					]
				})
			}

			F page(d:Description) \html [ \body [ "NOT-READY-YET" ] ]

			F Bool(d:Description) true

			F Str(d:Description) {
				"<${d.typeof().name} ${d.name}>"
			}


		type NamespaceDescription(Description)

			F init(nd:NamespaceDescription, namespace:Hash) {
				nd.fqname = nd.fqname()
				nd.description = object_doc_attr(namespace, '')
				nd.example = object_doc_attr(namespace, '%EX')
				# 'ext_links': doc_attr(ns, '%EXTLINK').map(ensure_array)
				# 'methods': ns.filterv(Fun).rejectv(Type).map(F(name, impls) {
				# 	# STDLIB_FILE_TYPE namespace has numbers as keys
				# 	impls = if impls is MultiMethod {
				# 		impls.Arr()
				# 	} else {
				# 		[impls]
				# 	}
				# 	process_method(Str(name), impls.filter(is_in_ns(X, ns)))
				# })
				nd.attrs = namespace.attrs().Box().get({}).get('doc', {}).without('').reject(X ~ /^%/).mapv(ensure_array)
				nd.objects_descriptions = {}
				nd.objects_by_type = {
					MultiMethodDescription: []
					MethodDescription: []
					TypeDescription: []
					NamespaceDescription: []
				}
				namespace.each(F(k, v) {
					if t = Description(nd, k, v) {
						if t is TypeDescription and nd is not GlobalNamespaceDescription {
							# Skip global types which are also in a namespace when showing the namespace
							g.get(k) === v returns
						}
						nd.objects_descriptions[k] = t
						nd.objects_by_type[t.typeof()].push(t)
					}
				})
			}

			F init(nd:NamespaceDescription, containing_nd:NamespaceDescription, name:Str, namespace:Hash) {
				init(args())
				obj_to_description[namespace] = nd
				super(nd, namespace)
			}

			F get_children(nd:NamespaceDescription) nd.objects_descriptions.values()

			F page_title(nd:NamespaceDescription) "${nd.fqname} namespace - NGS documentation"
			F page_heading(nd:NamespaceDescription) "${nd.fqname} namespace"
			F nav_name(nd:NamespaceDescription) "${nd.name} namespace"

			F index_fragment(indexer:Description, nd:NamespaceDescription) {

				\dl [
					\dt [
						\a href=href(indexer, nd)  [nd.fqname]
					]
					\dd [
						description_fragment(nd)
						\div class='unobtrusive' [
							{
								'sub-namespaces':     NamespaceDescription
								'types':              TypeDescription
								'multimethods':       MultiMethodDescription
								'top level methods':  MethodDescription
							}.mapv({nd.objects_by_type[A].len()}).filterv(X>0).map("$Y $X").join(', ')
						]
						example_fragment(nd)
					] # dd
				]
			}

			F top_level_types(nd:NamespaceDescription) {
				types = nd.objects_by_type[TypeDescription]
				all_types_count = len(types)
				types .= reject(F(t) {
					t.parents.any(F(p) {
						p.containing_nd === nd
					})
				})
				{
					'types': types
					'hidden': all_types_count - len(types)
				}
			}

			# TODO: MethodDescription (bootstrap_debug for example)
			F page(nd:NamespaceDescription) {
				tlt = top_level_types(nd)
				\html [
					head_fragment(nd)
					\body class='namespace-page' [
						nav_fragment(nd)
						\main [
							\h1 [page_heading(nd)]
							description_fragment(nd)
							example_fragment(nd)
							if nd.objects_by_type[NamespaceDescription] {
								DocGroup() with [
									\h2 ['Sub-namespaces']
									*nd.objects_by_type[NamespaceDescription].map(index_fragment(nd, X))
								]
							}
							if tlt.types {
								DocGroup() with [
									\h2 ['Types']
									if tlt.hidden {
										\section class='unobtrusive' ["${tlt.hidden} types, which are descendants of types listed below, are not shown for brevity"]
									} else {
										DocGroup()
									}
									*tlt.types.map(index_fragment(nd, X))
								]
							}
							if nd.objects_by_type[MultiMethodDescription] or nd.objects_by_type[MethodDescription] {
								DocGroup() with [
									\h2 ['Methods and Multimethods']
									*nd.objects_by_type[MultiMethodDescription].map(index_fragment(nd, X))
									*nd.objects_by_type[MethodDescription].map(index_fragment(nd, X))
								]
							}
						]
					]
				]
			}

			F Str(nd:NamespaceDescription) {
				"<${nd.typeof().name} ${nd.name} with ${nd.objects_descriptions.len()} items>"
			}

		type GlobalNamespaceDescription(NamespaceDescription)

			F fqname(gnd:GlobalNamespaceDescription) ''

			F init(gnd:GlobalNamespaceDescription) {
				super(gnd, g.without('main').filterk(is_public_name).rejectk(is_phased_out_type).sortk(lte))
			}

			F page_title(gnd:GlobalNamespaceDescription) "The global namespace - NGS documentation"
			F page_heading(gnd:GlobalNamespaceDescription) "The global namespace"
			F nav_name(gnd:GlobalNamespaceDescription) "The global namespace"

			F path_as_item(gnd:GlobalNamespaceDescription) ['index.html']
			F path_as_container(gnd:GlobalNamespaceDescription) []

			F description_fragment(gnd:GlobalNamespaceDescription) null

			F Str(gnd:GlobalNamespaceDescription) {
				"<${gnd.typeof().name} with ${gnd.objects_descriptions.len()} items>"
			}


		type TypeDescription(Description)

			F init(td:TypeDescription, containing_nd:NamespaceDescription, name:Str, type:Type) {
				init(args())
				obj_to_description[type] = td
				td.fqname = fqname(td)
				td.constructor = MultiMethodDescription(containing_nd, name, type.constructors)
				td.description = object_doc_attr(type, '')
				td.example = object_doc_attr(type, '%EX')
				td.parents = null
				td.children = []
			}

			F page_title(td:TypeDescription) "${td.fqname} type - NGS documentation"
			F page_heading(td:TypeDescription) "${td.fqname} type"
			F nav_name(td:TypeDescription) "${td.name} type"

			F index_fragment(indexer:Description, td:TypeDescription) {
				alt_name = ' (' +? (if td.name != td.type.name then td.type.name else '') +? ')'
				\dl [
					\dt [
						\a href=href(indexer, td) [td.fqname + alt_name]
					]
					\dd [
						description_fragment(td)
						if td.children {
							\div class='unobtrusive' [
								"Direct subtypes: ${td.children.len()}"
							]
						}
					]
				]
			}

			F directly_related_types_fragment(td:TypeDescription, related_types:Arr, rel:Str) {
				if related_types {
					\section [
						\h2 [ "Direct ${rel} types" ]
						*related_types.map(index_fragment(td, X))
					]
				} else {
					DocGroup()
				}

			}

			F page(td:TypeDescription) {
				\html [
					head_fragment(td)
					\body class='type-page' [
						nav_fragment(td)
						\main [
							\h1 [page_heading(td)]
							description_fragment(td)
							example_fragment(td)
							directly_related_types_fragment(td, td.parents, 'parent')
							directly_related_types_fragment(td, td.children, 'children')
						]
					]
				]
			}

		type MultiMethodDescription(Description)

			F init(mmd:MultiMethodDescription, containing_nd:NamespaceDescription, name:Str, multimethod:MultiMethod) {
				init(args())
				obj_to_description[multimethod] = mmd
				mmd.fqname = fqname(mmd)
				mmd.methods = multimethod.Arr().reject(NormalTypeConstructor).map(MethodDescription(containing_nd, name, mmd, X))
				# mmd.methods = multimethod.Arr().map(MethodDescription(containing_nd, name, mmd, X))
			}

			F index_fragment(indexer:Description, mmd:MultiMethodDescription) {
				\dl [
					\dt [
						\a href=href(indexer, mmd) class='underline-on-hover-only' [
							mmd.fqname
						]
					]
					\dd [
						\section class='unobtrusive' [
							"MultiMethod with ${mmd.methods.len()} methods"
						]
					]
				]
			}

			F index_fragment(indexer:Description, mmd:MultiMethodDescription) {
				guard mmd.methods.len() == 1
				index_fragment(indexer, mmd.methods[0])
			}




		type MethodDescription(Description)

			F init(md:MethodDescription, method:Fun) {
				obj_to_description[method] = md
				md.fqname = md.mmd.map(fqname).get(md.name)
				md.description = object_doc_attr(method, '')
				md.status = object_doc_attr(method, '%STATUS').get([])
			}


			F init(md:MethodDescription, containing_nd:NamespaceDescription, name:Str, mmd:MultiMethodDescription, method:Fun) {
				init(args())
				md.mmd = FullBox(mmd)
				super(md, method)
			}

			F init(md:MethodDescription, containing_nd:NamespaceDescription, name:Str, method:Fun) {
				init(args())
				md.mmd = EmptyBox()
				super(md, method)
			}

			F index_fragment(indexer:Description, md:MethodDescription) {
				\dl [
					\dt [
						\a href=href(indexer, md) class='underline-on-hover-only' [
							md.fqname
						]
						*md.status.map(F(s) {
							\span class="method-status" [ s ]
						})
					]
					\dd [
						description_fragment(md)
					]
				]
			}



		F Description(containing_nd:NamespaceDescription, name:Str, x) {
			if ENV.get('SHOW_IGNORED') {
				warn("Ignoring ${containing_nd} ${x.typeof()} ${name}")
			}
			null
		}

		F Description(containing_nd:NamespaceDescription, name:Str, method:Fun) {
			MethodDescription(containing_nd, name, method)
		}

		F Description(containing_nd:NamespaceDescription, name:Str, multimethod:MultiMethod) {
			MultiMethodDescription(containing_nd, name, multimethod)
		}

		F Description(containing_nd:NamespaceDescription, name:Str, t:Type) {
			TypeDescription(containing_nd, name, t)
		}

		F Description(containing_nd:NamespaceDescription, name:Str, maybe_namespace:Hash) {
			F is_namespace(x) {
				not(object_doc(x)) returns false
				x.keys().all(Int) returns false # STDLIB_FILE_TYPE, possibly others in future
				x.values().any(F(v) v is Type or v is Fun)
			}
			not(is_namespace(maybe_namespace)) returns null
			NamespaceDescription(containing_nd, name, maybe_namespace)
		}

		F Description(containing_nd:NamespaceDescription, name:Str, x) {
			guard x in obj_to_description
			obj_to_description[x]
		}

		F augment_types() {
			status("Augmenting types information")

			tds = obj_to_description.values().filter(TypeDescription)

			# .parents
			for t in tds {
				t.parents = t.type.parents.map(obj_to_description[X])
			}

			# .children
			for t in tds {
				t.parents.each(F(p) {
					p.children.push(t)
				})
			}

			# # maybe find it in methods variable instead of re-doing process_method_impl()
			# t.constructors = t.type.constructors.Arr().reject(NormalTypeConstructor).register_constructors_mis().map(process_method_impl(t.name, X))
			# t.methods = types_methods[t.type].map(processed_methods[X]).reject({'is_constructor': true})

		}


		status("Building descriptors")
		global_ns = GlobalNamespaceDescription()

		augment_types()

		status("Writing files")
		$(cp main.css "$doc_root/")

		global_ns.generate()




		status("OK")

	}
}
