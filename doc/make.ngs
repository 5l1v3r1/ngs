#!/usr/bin/env ngs
{

	# Autoload
	AWS
	ArgvMatcher
	DelimStr
	Doc
	Iter
	KV
	Lock
	Res
	ResDef
	Stats
	Table
	Thread
	test

	F main(doc_root:Str) {

		DocPart = Doc::Part
		DocNode = Doc::Node
		DocText = Doc::Text
		DocGroup = Doc::Group
		doc_visit = Doc::visit

		commit = `line: git rev-parse HEAD`

		F is_public_name(s:Str) s ~ /^[^_]/
		F is_phased_out_type(s:Str) s ~ Pfx('Aws')

		F to_lines(s:Str) [s]
		F to_lines(a:Arr) a

		F safe_file_name(s:Str) s.replace(/[^-_a-zA-Z0-9]/, F(char) '%' + encode_hex(char))
		F method_impl_id(name:Str, mi:Fun) (name + '-' + mi.params().type.name.join('-'))

		F list_methods()
			collector/{}
				globals().filterk(is_public_name).sortk(lte).each(F(name, value) {
					cond {
						(value is Arr) and value.all(Fun) {
							collect(name, value)
						}
						value is NormalType {
							# NormalType has special constructor which we can't handle for now
							# so skipping that one
							collect(name, value.constructors[1..null])
						}
						value is Type {
							collect(name, value.constructors)
						}
					}
				})

		F process_param(param:Hash, doc:Hash) {
			{
				'name':  param.name
				'type':  param.get('type', Any)
				'dflt':  param.Box('dflt')
				'splat': param.Box('splat')
				'doc':   doc.Box(param.name)
			}
		}

		F process_doc_attr(mi:Fun, attr:Str, cb:Fun) {
			a = mi.attrs()
			not(a) returns
			a.get('doc', {}).Box(attr).map(to_lines).each(cb)
		}

		F doc_attr(mi:Fun, attr:Str) {
			a = mi.attrs()
			not(a) returns
			(a.get('doc') or {}).Box(attr).map(to_lines)
		}

		method_impls_by_id = {}

		# F process_params

		pfx = Pfx("$NGS_DIR/")
		F process_method_impl(name:Str, mi:Fun) {
			method_impls_by_id.dflt(method_impl_id(name, mi), [name]).push(mi)

			mi_doc = mi.attrs().doc or {}
			{
				'name': name
				'mi': mi
				'description': doc_attr(mi, '')
				'auto': doc_attr(mi, '%AUTO').each(F(lines) assert(lines.len() == 1, '%AUTO must be used at most once per method'))
				'params': mi.params().map(process_param(X, mi_doc))
				'source_ref': Box(if mi is Closure {
					# Handling Closure, not handling built-ins yet
					location_info = mi.ip().resolve_instruction_pointer()
					if m = location_info.file ~ pfx {
						{
							'file': m.after
							'line': location_info.first_line
						}
					}
				})
				'returns': doc_attr(mi, '%RET').each(F(lines) assert(lines.len() == 1, '%RET must be used at most once per method'))
				'example': doc_attr(mi, '%EX').map(F(lines) lines.join('\n'))
			}

		}

		F process_method(name, implementations) {
			status("Processing method: $name")
			{
				'name': name
				'implementations': implementations.map(process_method_impl(name, X))
			}
		}

		F param_to_inline_html_doc(param:Hash) {
			DocNode('span', class='inline-param') with [
				DocText(param.name)
				DocText(':')
				DocText(param.type.name)
				param.dflt.map(F(d) {
					DocGroup() with [
						DocText('=')
						ematch d {
							Fun DocNode('span', class='non-literal') with [ DocText('method') ]
							Any DocText(d.code())
						}
					]
				}).get(DocGroup())
			]
		}

		F params_to_inline_html_doc(params:Arr) {
			DocGroup() with
				[
					DocText('('),
					*params.map(param_to_inline_html_doc).intersperse(DocText(', '))
					DocText(')')
				]
		}

		F method_impl_to_index_html_doc(name:Str, mi:Hash) {

			DocNode('li') with [
				DocNode('a', href=method_impl_id(name, mi.mi).safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with
					[
						DocText(name),
						*params_to_inline_html_doc(mi.params)
						DocText(' - ')
						mi.description.map(X.join('\n')).map(DocText).get(DocText('Undocumented'))
					]
			]

		}

		F method_to_index_html_doc(method:Hash) {
			status("Preparing HTML doc for method ${method.name}")
			DocNode('li', style='method') with [
				DocNode('a', href=method.name.safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with [
					DocText(method.name)
				]
				method.implementations.map(method_impl_to_index_html_doc(method.name, X)).Box().filter({A}).map(DocNode('ul', X)).get(DocGroup())
			]
		}

		F methods_to_index_html_doc(methods:Arr) {
			DocNode('html') with [
				DocNode('head') with [
					DocNode('meta', charset='UTF-8')
					DocNode('link', rel='stylesheet', href='../main.css', type='text/css')
					DocNode('title') with [
						DocText('Methods index - NGS documentation')
					]
				]
				DocNode('body', class='methods-index-page') with [
					DocNode('nav') with [
						DocNode('ul') with [
							DocNode('li') with [
								DocNode('span', class='nav-here') with [
									DocText('Methods index')
								]
							]
						]
					]
					DocNode('main') with [
						DocGroup() with [
							DocNode('h1') with [
								DocText('Methods')
							]
						] + methods.map(method_to_index_html_doc)
					]
				]
			]
		}

		F do_methods() {
			methods_index_html_doc = list_methods().limit(30).map(process_method).methods_to_index_html_doc()
			$(mkdir -p ${doc_root / 'methods'})
			$(cp main.css "$doc_root/")
			status("Writing methods index (overview) page")
			write(doc_root / 'methods/index.html', Doc::HtmlRoot(methods_index_html_doc))


			return

			for method_node in methods_node.children {
				status("Making page for method ${method_node.attrs.name}")
				method_page_transformer = {
					'param': F(dn:DocNode) {
							# name, type, splat, dflt, doc
							# TODO later: type link
							## DocText(dn.attrs.type.name)
							DocNode('tr', class='param') with [
								DocNode('td') with [
									DocText(dn.attrs.name)
								]
								DocNode('td') with [
									DocText(dn.attrs.type.name)
								]
								DocNode('td') with [
									DocText(if dn.attrs.doc then dn.attrs.doc.to_lines().join('\n') else '-')
								]
							]
					}
					'source-ref': F(dn:DocNode) {
						# dn.attrs.file
						# dn.attrs.line
						DocNode('span', class="source-ref") with [
							DocText('Source: ')
							DocNode('a', href="https://github.com/ilyash/ngs/blob/$commit/lib/${dn.attrs.file}#L${dn.attrs.line}") with [
								DocText("${dn.attrs.file}:${dn.attrs.line}")

							]
						]
					}
					'auto':  F(dn:DocNode) {
							DocNode('section', class='auto') with [
								DocText('Automatically called by NGS for syntax:')
								DocNode('code', class='auto', title='Usage syntax') with Doc::transform(dn.children, method_page_transformer)
							]
					}
					'example':  F(dn:DocNode) {
							DocNode('section', class='example') with [
								DocNode('pre', class='example', title='Example') with Doc::transform(dn.children, method_page_transformer)
							]
					}
					'returns':  F(dn:DocNode) {
							DocNode('tr', class='returns') with [
								DocNode('td') with [
									DocNode('span', class='non-literal') with [ DocText('Returns') ]
								]
								DocNode('td') with [
									DocText('-')
								]
								DocNode('td') with Doc::transform(dn.children, method_page_transformer)
							]
					}
					'description': F(dn:DocNode) {
						DocNode('section', class='method-description') with Doc::transform(dn.children, method_page_transformer)
					}
					'method-impl': F(dn:DocNode) {
						# dn.attrs.mi
						params = dn.children.filter(DocNode).filter({'name': 'params'})[0]
						_returns = dn.children.filter(DocNode).filter({'name': 'returns'}).Box(0)
						_auto = dn.children.filter(DocNode).filter({'name': 'auto'}).Box(0)
						src_ref = dn.children.filter(DocNode).filter({'name': 'source-ref'}).Box(0)
						DocNode('dl') with [
							DocNode('dt') with [
								DocText(dn.attrs.name)
								Doc::transform(params, params_inline_transformer)
								src_ref.map(F(s) Doc::transform(s, method_page_transformer)).get(DocGroup())
							]
							DocNode('dd') with
								Doc::transform(dn.children, method_page_transformer + {
									'source-ref': { DocGroup() }
									'returns': { DocGroup() }
									'params': F(dn:DocNode) {
										ret = DocNode('table', class='params') with [
											DocNode('tr') with [
												DocNode('th') with [
													DocText('Parameter')
												]
												DocNode('th') with [
													DocText('Type')
												]
												DocNode('th') with [
													DocText('Description')
												]
											]
										] + Doc::transform(dn.children, method_page_transformer)
										_returns.each(F(r) ret.push(Doc::transform(r, method_page_transformer)))
										ret
									}
								})
						]
					}
					'method': F(dn:DocNode) {
						# dn.attrs.name
						DocGroup() with [
							DocNode('h1') with [
								DocText(dn.attrs.name)
								DocNode('span', class='unobtrusive') with [ DocText(" (method)") ]
							]
						] + Doc::transform(dn.children, method_page_transformer)
					}
					'root': F(dn:DocNode) {
						# TODO: title
						DocNode('html') with [
							DocNode('head') with [
								DocNode('meta', charset='UTF-8')
								DocNode('link', rel='stylesheet', href='../main.css', type='text/css')
								DocNode('title') with [
									DocText("${dn.attrs.name} method - NGS documentation")
								]
							]
							DocNode('body', class='method-page') with [
								DocNode('nav') with [
									DocNode('ul') with [
										DocNode('li') with [
											DocNode('a', href='index.html') with [
												DocText('Methods index')
											]
										]
										DocNode('ul') with [
											DocNode('li') with [
												DocNode('span', class='nav-here') with [
													DocText(dn.attrs.name)
													DocNode('span', class='unobtrusive') with [ DocText(" (method)") ]
												]
											]
										]
									]
								]
								DocNode('main') with Doc::transform(dn.children, method_page_transformer)
							]
						]
					}
					DocText: F(t:DocText) t
				}

				method_page_html = Doc::transform(DocNode('root', name=method_node.attrs.name) with [method_node], method_page_transformer)
				status("Writing method page: name=${method_node.attrs.name} file=${method_node.attrs.name.safe_file_name()}.html")
				write(doc_root / 'methods' / method_node.attrs.name.safe_file_name() + '.html', Doc::HtmlRoot(method_page_html))


			}


			### # Detailed method implementations pages
			### method_impls_by_id.each(F(id, impls) {
			### 	assert('/' not in id)
			### 	assert('.' not in id)
			### 	local mdn = MethodsDocNode([process_method(impls[0], impls[1..null])])
			### 	local page = TopDocNode([mdn])
			### 	local html = Html(page, {'detailed_method_page': true})
			### 	# OLD # html.Str().write("method-impl-${id}.html")
			### })
		}

		F do_types() {

			# TODO: methods with this type
			# TODO: constructors
			# TODO: child types

			# Splat params will be Arr or Hash but they are not interesting
			F method_impl_has_arg_of_type(mi:Fun, t:Type) mi.params().reject(X.get('splat')).type.has(t)

			# We'll use it to list methods that have given
			# type as type of one of the parameters.
			methods = list_methods()

			types = globals().filterv(Type).filterk(is_public_name).filterk(not + is_phased_out_type).sortk(lte)

			# Init with ( type -> [] ) pairs
			types_direct_children = types.values().Hash({ [] })

			types.values().each(F(t) {
				t.parents.each(F(p) {
					types_direct_children[p].push(t)
				})
			})


			# TODO: straighten by using ParentTypeDocNode instead of 'full' / 'leaf' option.
			F type_to_doc_node(value:Type, full:Bool) {
				# echo("N $name")
				# ret = TypeDocNode([ParentTypesDocNode(value.parents.map())])
				ret = TypeDocNode()
				ret.type = value
				# ret.full = full
				process_type_impl_doc_attr(value, ret, '', DescDocNode)
				type_attrs_dns = ((try value.attrs().doc) or {}).without('').reject(X ~ /^%/).map(F(k, v) {
					TypeAttrDocNode(v.to_lines()).set('name', k)
				})
				ret.push(TypeAttrsDocNode(type_attrs_dns))

				if full {
					process_type_impl_doc_attr(value, ret, '%EX', ExampleDocNode)
					ret.push(ParentTypesDocNode(value.parents.map(type_to_doc_node(X, false))))
					ret.push(ChildTypesDocNode(types_direct_children[value].map(type_to_doc_node(X, false))))
					methods_of_type_dns = collector
						methods.each() do F(name, impls) {
							relevant_impls = impls.filter(method_impl_has_arg_of_type(X, value)).map() do F(mi) {
								dn = TypeMethodImplDocNode([])
								dn.mi = mi
								process_method_impl_doc_attr(mi, dn, '', DescDocNode)
								dn.push(ParamsDocNode(mi.params().map(process_param(X, mi.attrs().doc or {}))))
								dn
							}
							if relevant_impls {
								dn = TypeMethodDocNode(relevant_impls)
								dn.method = name
								collect(dn)
							}
						}
					constructors_dns = value.constructors.reject(NormalTypeConstructor).map() do F(c) {
						dn = TypeMethodImplDocNode([])
						# dn.method = value.name
						dn.mi = c
						process_method_impl_doc_attr(c, dn, '', DescDocNode)
						dn.push(ParamsDocNode(c.params().map(process_param(X, c.attrs().doc or {}))))
						dn
					}
					ret.push(TypeMethodsDocNode(methods_of_type_dns))
					ret.push(TypeConstructorsDocNode(constructors_dns).set('method', value.name))
				}
				ret
			}

			types .= map(F(name, value) {
				type_to_doc_node(value, true)
			})

			# Index page
			tdn = TypesDocNode(types)
			page = TopDocNode([tdn])

			# Detailed types pages
			types.each(F(t) {
				assert('/' not in t.type.name)
				assert('.' not in t.type.name)
				local tdn = TypesDocNode([t])
				local page = TopDocNode([tdn])
				local html = Html(page, {'detailed_type_page': true})
				# OLD # html.Str().write("type-${t.type.name}.html")
			})

		}

		do_methods()

		# echo(page)
		# inspect(html_page, 5) % echo
		# each_idx_val(page.children[0].children[0].children, F(idx, val) {
		# 	log("IDX $idx")
		# 	log("KEYS ${val.Hash().keys()}")
		# 	inspect(val.Hash()).each(echo)
		# 	Str(val)
		# 	# log("ELT $val")
		# })
		# echo(hash(page))
		# echo(hash(page.children[0]))
		# echo(hash(page.children[0].children[0]))
		# echo(hash(page.children[0].children[0].children[0]))
		# echo(hash(page.children[0].children[0].children[0].children[0]))
		# echo(hash(page.children[0].children[0].children[0].children[0].children[0]))
		# echo(page.children[0].children[0].children[0].children[0].name)
		# echo(Data::find_cycle(page)[1].name)

		# echo(methods.children[-100])
	}
}


