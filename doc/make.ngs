#!/usr/bin/env ngs
{

	# Autoload
	AWS
	ArgvMatcher
	DelimStr
	Doc
	Iter
	KV
	Lock
	Res
	ResDef
	Stats
	Table
	Thread
	test

	# Use anonymous function to exclude methods in this file
	# The inner functions are local
	ns(DocPart=Doc::DocPart, DocNode=Doc::Node, DocTopLevel=Doc::TopLevel) {

		global Arr, Str, init, push, each

		commit = `line: git rev-parse HEAD`

		mode = ARGV[0]
		assert(mode == 'methods' or mode == 'types')

		# --- Html ---

		F is_public_name(s:Str) s ~ /^[^_]/
		F is_phased_out_type(s:Str) s ~ Pfx('Aws')

		F to_lines(s:Str) [s]
		F to_lines(a:Arr) a

		### F encode_id(s:Str) s.replace(/[^-_a-zA-Z0-9]/, F(char) '%' + encode_hex(char))
		F method_impl_id(name:Str, mi:Fun) (name + '-' + mi.params().type.name.join('-'))

		F list_methods()
			collector/{}
				globals().filterk(is_public_name).sortk(lte).each(F(name, value) {
					cond {
						(value is Arr) and value.all(Fun) {
							collect(name, value)
						}
						value is NormalType {
							# NormalType has special constructor which we can't handle for now
							# so skipping that one
							collect(name, value.constructors[1..null])
						}
						value is Type {
							collect(name, value.constructors)
						}
					}
				})

		F process_param(param:Hash, doc:Hash) {
			# echo("P $param")
			### dflt = if 'dflt' in param {
			### 	FullBox(ematch param.dflt {
			### 		Fun Doc::Node('default-is-fun')
			### 		Any Doc::Node('default-value', text=param.dflt.Str())
			### 	})
			### } else {
			### 	EmptyBox()
			### }
			dflt = param.Box('dflt').map({ematch A {
				Fun Doc::Node('default-is-fun')
				Any Doc::Node('default-value', text=param.dflt.Str())
			}})
			DocNode('param', name=param.name, type=param.get('type', Any), splat=dn.get('splat'), dflt=dflt, doc=doc.get(param.name))
		}

		### F process_method_impl_doc_attr(mi:Fun, dn:DocNode, doc_attr:Str, doc_node_type:Type) {
		### 	d = mi.attrs().doc or {}
		### 	if doc_attr in d {
		### 		dn.push(doc_node_type(d[doc_attr].to_lines()))
		### 	}
		### }

		### F process_type_impl_doc_attr(t:Type, dn:DocNode, doc_attr:Str, doc_node_type:Type) {
		### 	a = t.attrs()
		### 	'doc' not in a returns null
		### 	d = t.attrs().doc or {}
		### 	if doc_attr in d {
		### 		dn.push(doc_node_type(d[doc_attr].to_lines()))
		### 	}
		### }

		method_impls_by_id = {}

		# F process_params

		pfx = Pfx("$NGS_DIR/")
		F process_method_impl(name:Str, mi:Fun) {
			method_impls_by_id.dflt(method_impl_id(name, mi), [name]).push(mi)

			### process_method_impl_doc_attr(mi, dn, '', DescDocNode)
			### dn.push(ParamsDocNode(mi.params().map(process_param(X, mi.attrs().doc or {}))))
			### process_method_impl_doc_attr(mi, dn, '%EX', ExampleDocNode)
			### process_method_impl_doc_attr(mi, dn, '%RET', RetDocNode)

			dn = DocNode('method-impl', mi=mi)
			if mi is Closure {
				# Handling Closure, not handling built-ins yet
				location_info = mi.ip().resolve_instruction_pointer()
				if m = location_info.file ~ pfx {
					dn.push(DocNode('location', file=m.after, line=location_info.first_line))
				}
			}
			dn
		}

		F process_method(name, value) DocNode('method', name=name) with value.map(process_method_impl(name, X))

		eswitch mode {

			'methods' {

				# Index page
				methods = DocNode('methods') with list_methods().limit(3) / process_method
				page = DocTopLevel() with [methods]

				html_page = Doc::transform(page, {
					'location': F(dp:DocPart, children, parents) {
						# dp.attrs.file
						# dp.attrs.line
						DocNode('a', href="https://github.com/ilyash/ngs/blob/$commit/lib/${dp.attrs.file}#L${dp.attrs.line}", class='location') with [
							Doc::Text("${dp.attrs.file}:${dp.attrs.line}")

						]
					}
					'method-impl': F(dp:DocPart, children, parents) {
						# dp.attrs.mi
						DocNode('section', class='method-impl') with [
							DocNode('h') with [
								Doc::Text('method impl. todo: method name')
							]
						] + children
					}
					'method': F(dp:DocPart, children, parents) {
						# dp.attrs.name
						DocNode('section', class='method') with [
							DocNode('h') with [
								Doc::Text("Method: ${dp.attrs.name}")
							]
						] + children
					}
					'methods': F(dp:DocPart, children, parents) {
						# dp.attrs.name
						DocNode('section', class='methods') with [
							DocNode('h') with [
								Doc::Text('Methods')
							]
						] + children
					}
					Doc::TopLevel: F(dp:DocPart, children, parents) {
						DocTopLevel() with children
					}
				})

				Doc::visit(html_page, F(dp:DocPart, parents) {
					if Doc::name(dp) == 'h' {
						dp.name = "h${count(parents, {Doc::name(A) == 'section'})}"
					}
				})

				### # Detailed method implementations pages
				### method_impls_by_id.each(F(id, impls) {
				### 	assert('/' not in id)
				### 	assert('.' not in id)
				### 	local mdn = MethodsDocNode([process_method(impls[0], impls[1..null])])
				### 	local page = TopDocNode([mdn])
				### 	local html = Html(page, {'detailed_method_page': true})
				### 	# OLD # html.Str().write("method-impl-${id}.html")
				### })

			}

			'types' {

				# TODO: methods with this type
				# TODO: constructors
				# TODO: child types

				# Splat params will be Arr or Hash but they are not interesting
				F method_impl_has_arg_of_type(mi:Fun, t:Type) mi.params().reject(X.get('splat')).type.has(t)

				# We'll use it to list methods that have given
				# type as type of one of the parameters.
				methods = list_methods()

				types = globals().filterv(Type).filterk(is_public_name).filterk(not + is_phased_out_type).sortk(lte)

				# Init with ( type -> [] ) pairs
				types_direct_children = types.values().Hash({ [] })

				types.values().each(F(t) {
					t.parents.each(F(p) {
						types_direct_children[p].push(t)
					})
				})


				# TODO: straighten by using ParentTypeDocNode instead of 'full' / 'leaf' option.
				F type_to_doc_node(value:Type, full:Bool) {
					# echo("N $name")
					# ret = TypeDocNode([ParentTypesDocNode(value.parents.map())])
					ret = TypeDocNode()
					ret.type = value
					# ret.full = full
					process_type_impl_doc_attr(value, ret, '', DescDocNode)
					type_attrs_dns = ((try value.attrs().doc) or {}).without('').reject(X ~ /^%/).map(F(k, v) {
						TypeAttrDocNode(v.to_lines()).set('name', k)
					})
					ret.push(TypeAttrsDocNode(type_attrs_dns))

					if full {
						process_type_impl_doc_attr(value, ret, '%EX', ExampleDocNode)
						ret.push(ParentTypesDocNode(value.parents.map(type_to_doc_node(X, false))))
						ret.push(ChildTypesDocNode(types_direct_children[value].map(type_to_doc_node(X, false))))
						methods_of_type_dns = collector
							methods.each() do F(name, impls) {
								relevant_impls = impls.filter(method_impl_has_arg_of_type(X, value)).map() do F(mi) {
									dn = TypeMethodImplDocNode([])
									dn.mi = mi
									process_method_impl_doc_attr(mi, dn, '', DescDocNode)
									dn.push(ParamsDocNode(mi.params().map(process_param(X, mi.attrs().doc or {}))))
									dn
								}
								if relevant_impls {
									dn = TypeMethodDocNode(relevant_impls)
									dn.method = name
									collect(dn)
								}
							}
						constructors_dns = value.constructors.reject(NormalTypeConstructor).map() do F(c) {
							dn = TypeMethodImplDocNode([])
							# dn.method = value.name
							dn.mi = c
							process_method_impl_doc_attr(c, dn, '', DescDocNode)
							dn.push(ParamsDocNode(c.params().map(process_param(X, c.attrs().doc or {}))))
							dn
						}
						ret.push(TypeMethodsDocNode(methods_of_type_dns))
						ret.push(TypeConstructorsDocNode(constructors_dns).set('method', value.name))
					}
					ret
				}

				types .= map(F(name, value) {
					type_to_doc_node(value, true)
				})

				# Index page
				tdn = TypesDocNode(types)
				page = TopDocNode([tdn])

				# Detailed types pages
				types.each(F(t) {
					assert('/' not in t.type.name)
					assert('.' not in t.type.name)
					local tdn = TypesDocNode([t])
					local page = TopDocNode([tdn])
					local html = Html(page, {'detailed_type_page': true})
					# OLD # html.Str().write("type-${t.type.name}.html")
				})
			}

		}

		echo(Doc::Html(html_page))
		# echo(page)
		# inspect(html_page, 5) % echo
		# each_idx_val(page.children[0].children[0].children, F(idx, val) {
		# 	log("IDX $idx")
		# 	log("KEYS ${val.Hash().keys()}")
		# 	inspect(val.Hash()).each(echo)
		# 	Str(val)
		# 	# log("ELT $val")
		# })
		# echo(hash(page))
		# echo(hash(page.children[0]))
		# echo(hash(page.children[0].children[0]))
		# echo(hash(page.children[0].children[0].children[0]))
		# echo(hash(page.children[0].children[0].children[0].children[0]))
		# echo(hash(page.children[0].children[0].children[0].children[0].children[0]))
		# echo(page.children[0].children[0].children[0].children[0].name)
		# echo(Data::find_cycle(page)[1].name)

		# echo(methods.children[-100])
	}
}


