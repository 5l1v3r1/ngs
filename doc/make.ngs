#!/usr/bin/env ngs
{

	# Autoload
	AWS
	ArgvMatcher
	DelimStr
	Doc
	Iter
	KV
	Lock
	Res
	ResDef
	Stats
	Table
	Thread
	test

	F main(doc_root:Str) {

		DocPart = Doc::Part
		DocNode = Doc::Node
		DocText = Doc::Text
		DocGroup = Doc::Group
		doc_visit = Doc::visit

		commit = `line: git rev-parse HEAD`

		F is_public_name(s:Str) s ~ /^[^_]/
		F is_phased_out_type(s:Str) s ~ Pfx('Aws')

		F to_lines(s:Str) [s]
		F to_lines(a:Arr) a

		F safe_file_name(s:Str) {
			s == 'index' returns 'index-'
			s.replace(/[^-_a-zA-Z0-9]/, F(char) '%' + encode_hex(char))
		}
		F method_impl_id(name:Str, mi:Fun) (name + '-' + mi.params().type.name.join('-'))

		F list_methods()
			collector/{}
				globals().filterk(is_public_name).sortk(lte).each(F(name, value) {
					cond {
						(value is Arr) and value.all(Fun) {
							collect(name, value)
						}
						value is Type {
							# NormalTypeConstructor is built-in. We are not documenting it here.
							collect(name, value.constructors.reject(NormalTypeConstructor))
						}
					}
				})

		F process_param(param:Hash, doc:Hash) {
			{
				'name':  param.name
				'type':  param.get('type', Any)
				'dflt':  param.Box('dflt')
				'splat': param.Box('splat')
				'doc':   doc.Box(param.name).map(to_lines)
			}
		}

		F process_doc_attr(mi:Fun, attr:Str, cb:Fun) {
			a = mi.attrs()
			not(a) returns
			a.get('doc', {}).Box(attr).map(to_lines).each(cb)
		}

		F doc_attr(x, attr:Str) {
			a = x.attrs()
			not(a) returns
			(a.get('doc') or {}).Box(attr).map(to_lines)
		}

		method_impls_by_id = {}

		# F process_params

		pfx = Pfx("$NGS_DIR/")
		F process_method_impl(name:Str, mi:Fun) {

			mi_doc = mi.attrs().doc or {}
			ret = {
				'name': name
				'mi': mi
				'description': doc_attr(mi, '')
				'auto': doc_attr(mi, '%AUTO').each(F(lines) assert(lines.len() == 1, '%AUTO must be used at most once per method'))
				'params': mi.params().map(process_param(X, mi_doc))
				'source_ref': Box(if mi is Closure {
					# Handling Closure, not handling built-ins yet
					location_info = mi.ip().resolve_instruction_pointer()
					if m = location_info.file ~ pfx {
						{
							'file': m.after
							'line': location_info.first_line
						}
					}
				})
				'returns': doc_attr(mi, '%RET').each(F(lines) assert(lines.len() == 1, '%RET must be used at most once per method'))
				'example': doc_attr(mi, '%EX').map(to_lines)
				'ext_links': doc_attr(mi, '%EXTLINK').map(to_lines)
			}
			method_impls_by_id.dflt(method_impl_id(name, mi), [name]).push(ret)
			ret

		}

		F process_method(name, implementations) {
			status("Processing method: $name")
			{
				'name': name
				'implementations': implementations.map(process_method_impl(name, X))
			}
		}

		F param_to_inline_html_doc(param:Hash) {
			DocNode('span', class='inline-param') with [
				DocText(param.name)
				DocText(':')
				DocText(param.type.name)
				param.dflt.map(F(d) {
					DocGroup() with [
						DocText('=')
						ematch d {
							Fun DocNode('span', class='non-literal') with [ DocText('method') ]
							Any DocText(d.code())
						}
					]
				}).get(DocGroup())
			]
		}

		F params_to_inline_html_doc(params:Arr) {
			DocGroup() with
				[
					DocText('('),
					*params.map(param_to_inline_html_doc).intersperse(DocText(', '))
					DocText(')')
				]
		}

		F make_page_head_doc(title:Str) {
			DocNode('head') with [
				DocNode('meta', charset='UTF-8')
				DocNode('link', rel='stylesheet', href='../main.css', type='text/css')
				DocNode('title') with [
					DocText(title)
				]
			]
		}

		F method_impl_to_index_html_doc(name:Str, mi:Hash) {

			DocNode('div') with [
				DocNode('a', href=method_impl_id(name, mi.mi).safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with
					[
						DocText(name),
						*params_to_inline_html_doc(mi.params)
						DocText(' - ')
						mi.description.map(X.join('\n')).map(DocText).get(DocText('Undocumented'))
					]
			]

			DocNode('dl') with [
				DocNode('dt') with [
					DocText(name),
					*params_to_inline_html_doc(mi.params)
				]
				DocNode('dd') with [
					DocNode('section', class='method-description') with [
						mi.description.map(X.join('\n')).map(DocText).get(DocText('Undocumented'))
					]
					DocNode('div', class='link-to-method-impl-page') with [
						DocNode('a', href='../methods/' + method_impl_id(name, mi.mi).safe_file_name().encode_uri_component() + '.html') with
							[
								DocText('more'),
							]
					]
				] # dd
			]

		}

		F method_to_index_html_doc(method:Hash) {
			status("Preparing HTML doc for method ${method.name}")
			DocNode('div', style='index-page-method') with [
				# DocNode('a', href=method.name.safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with [
				# 	DocText(method.name)
				# ]
				*method.implementations.map(method_impl_to_index_html_doc(method.name, X))
			]
		}

		F methods_to_index_html_doc(methods:Arr) {
			DocNode('html') with [
				make_page_head_doc('Methods - NGS documentation')
				DocNode('body', class='methods-index-page') with [
					DocNode('nav') with [
						DocNode('ul') with [
							DocNode('li') with [
								DocNode('span', class='nav-here') with [
									DocText('Methods')
								]
							]
						]
					]
					DocNode('main') with [
						DocGroup() with [
							DocNode('h1') with [
								DocText('Methods')
							]
						] + methods.map(method_to_index_html_doc)
					]
				]
			]
		}

		F method_impl_to_method_page_html_doc(name:Str, mi:Hash, opts:Hash) {
			DocNode('dl') with [
				DocNode('dt') with [
					DocText(name),
					*params_to_inline_html_doc(mi.params)
					mi.source_ref.map(F(r) {
						DocNode('span', class="source-ref") with [
							DocText('Source: ')
							DocNode('a', href="https://github.com/ilyash/ngs/blob/$commit/lib/${r.file}#L${r.line}") with [
								DocText("${r.file}:${r.line}")

							]
						]
					}).get(DocGroup())
				]
				DocNode('dd') with [
					DocNode('section', class='method-description') with [
						mi.description.map(X.join('\n')).map(DocText).get(DocText('Undocumented'))
					]
					mi.auto.map(F(a) {
						DocNode('section', class='auto unobtrusive') with [
							DocText('Automatically called by NGS for syntax:')
							DocNode('code', class='auto', title='Usage syntax') with [
								a[0].DocText()
							]
						]
					}).get(DocGroup())
					if mi.params.any({A.doc}) or mi.returns {
						DocNode('table', class='params') with
							mi.params.filter({A.doc}).map(F(param) {
								DocNode('tr', class='param') with [
									DocNode('td') with [
										DocText(param.name)
									]
									DocNode('td') with [
										param.doc.map(X.join('\n')).map(DocText).get(DocText('-'))
									]
								]
							}) + [
								mi.returns.map(F(rets) {
									DocNode('tr', class='returns') with [
										DocNode('td') with [
											DocNode('span', class='non-literal') with [ DocText('Returns') ]
										]
										DocNode('td') with [
											rets.join('\n').DocText()
										]
									]
								}).get(DocGroup())
							]
					} else {
						DocGroup()
					}
					mi.example.map(F(ex) {
						DocNode('section', class='example') with [
							DocNode('pre', class='example', title='Example') with [
								ex.join('\n').DocText()
							]
						]
					}).get(DocGroup())
					mi.ext_links.filter({opts.get('detailed')}).map(F(links) {
						DocNode('div') with [
							DocText('External links')
							DocNode('ul', class='external-links') with links.map(F(link) {
								parts = link.split(' ', 2)
								href = parts[0]
								text = parts.Box(1).get(href)
								DocNode('li') with [
									DocNode('a', href=href) with [ DocText(text) ]
								]
							})

						]
					}).get(DocGroup())
					if opts.get('detailed') {
						DocGroup()
					} else {
						DocNode('div', class='link-to-method-impl-page') with [
							DocNode('a', href='../methods/' + method_impl_id(name, mi.mi).safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with
								[
									DocText(name),
									*params_to_inline_html_doc(mi.params)
								]
						]
					}
				] # dd
			]
		}

		F methods_impls_to_doc(impls:Arr, opts:Hash={}) {
			DocGroup() with
				impls.map(F(i) {
					method_impl_to_method_page_html_doc(i.name, i, opts)
				})
		}


		F method_to_method_page_html_doc(method:Hash, opts:Hash={}) {
			# TODO: title
			DocNode('html') with [
				make_page_head_doc("${method.name} method - NGS documentation")
				DocNode('body', class='method-page') with [
					DocNode('nav') with [
						DocNode('ul') with [
							DocNode('li') with [
								DocNode('a', href='index.html') with [
									DocText('Methods')
								]
							]
							if opts.get('detailed') {
								DocNode('ul') with [
									DocNode('li') with [
										DocNode('a', href=method.name.safe_file_name().encode_uri_component() + '.html') with [
											DocText(method.name)
										]
										DocNode('ul') with [
											DocNode('li') with [
												DocNode('span', class='nav-here') with [
													DocText(method.name + " implementation ${opts.counter[0]}/${opts.counter[1]}")
												]
											]
										]
									]
								]
							} else {
								DocNode('ul') with [
									DocNode('li') with [
										DocNode('span', class='nav-here') with [
											DocText(method.name)
										]
									]
								]
							}
						]
					]
					DocNode('main') with [
						DocNode('h1') with [
							DocText(method.name)
							DocNode('span', class='unobtrusive') with [ DocText(" (method)") ]
						]
					] + method.implementations.map(method_impl_to_method_page_html_doc(method.name, X, opts))
				]
			]

		}


		# XXX: "index" method file name collision with the index!
		F do_methods() {
			methods_index_html_doc = methods.methods_to_index_html_doc()
			$(mkdir -p ${doc_root / 'methods'})
			status("Writing methods (overview) page")
			write(doc_root / 'methods/index.html', Doc::HtmlRoot(methods_index_html_doc))

			for m in methods {
				status("Making page for method ${m.name}")
				# m.implementations
				method_page_html_doc = method_to_method_page_html_doc(m)
				write(doc_root / 'methods' / m.name.safe_file_name() + '.html', Doc::HtmlRoot(method_page_html_doc))
			}

			method_impls_page_count_by_method_name = method_impls_by_id.values().map(X[0]).Stats()
			method_impls_name_counter = Stats()

			method_impls_by_id.each(F(id, implementations) {
				name = implementations[0]
				impls = implementations[1..null]
				method_impls_name_counter.push(name)


				status("Making page for method id ${id}")
				# m.implementations
				method_id_page_html_doc = method_to_method_page_html_doc({'name': name, 'implementations': impls}, {
					'detailed': true
					'counter': [method_impls_name_counter[name], method_impls_page_count_by_method_name[name]]
				})
				write(doc_root / 'methods' / id.safe_file_name() + '.html', Doc::HtmlRoot(method_id_page_html_doc))
			})
		}

		F process_type(name:Str, t:Type) {
			# 'attrs': t.attrs().Box().map(X.doc).
			{
				'name': name
				'type': t
				'description': doc_attr(t, '')
				'attrs': (t.attrs() or {}).get('doc').Box().get({}).without('').reject(X ~ /^%/).mapv(to_lines)
				'example': doc_attr(t, '%EX').map(to_lines)
			}
		}

		F type_to_index_entry_doc(t:Hash) {
			DocNode('dl', style='method') with [
				DocNode('dt') with [
					DocNode('a', href=t.name.safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with [
						DocText(t.name)
					]
				]
				DocNode('dd') with [
					t.description.map(F(d) {
						DocText(d.join('\n'))
					}).get(DocText('Undocumented'))
				]
			]
		}

		F types_to_index_html_doc(types:Arr) {
			DocNode('html') with [
				make_page_head_doc("Types - NGS documentation")
				DocNode('body', class='types-index-page') with [
					DocNode('nav') with [
						DocNode('ul') with [
							DocNode('li') with [
								DocNode('a', href='../methods/index.html') with [
									DocText('Methods')
								]
							]
							DocNode('li') with [
								DocNode('span', class='nav-here') with [
									DocText('Types')
								]
							]
						]
					]
					DocNode('main') with [
						DocNode('h1') with [ DocText('Types') ]
					] + types.map(type_to_index_entry_doc)
				]
			]
		}

		F type_to_type_page_doc(t:Hash) {
			DocNode('html') with [
				make_page_head_doc("${t.name} type - NGS documentation")
				DocNode('body', class='types-index-page') with [
					DocNode('nav') with [
						DocNode('ul') with [
							DocNode('li') with [
								DocNode('a', href='../methods/index.html') with [
									DocText('Methods')
								]
							]
							DocNode('li') with [
								DocNode('a', href='index.html') with [
									DocText('Types')
								]
								DocNode('ul') with [
									DocNode('li') with [
										DocNode('span', class='nav-here') with [
											DocText(t.name)
										]
									]
								]
							]
						]
					]
					DocNode('main') with [
						DocNode('h1') with [ DocText(t.name) ]
						DocNode('section') with [
							t.description.map(F(d) {
								DocText(d.join('\n'))
							}).get(DocText('Undocumented'))
						]
						if t.parents {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Direct parent types') ]
								DocNode('ul') with t.parents.map(F(p) {
									DocNode('li') with [
										DocNode('a', href=p.name.safe_file_name().encode_uri_component() + '.html') with [
											DocText(p.name)
										]
									]
								})
							]
						} else {
							DocGroup()
						}
						if t.children {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Direct children types') ]
								DocNode('ul') with t.children.map(F(c) {
									DocNode('li') with [
										DocNode('a', href=c.name.safe_file_name().encode_uri_component() + '.html') with [
											DocText(c.name)
										]
									]
								})
							]
						} else {
							DocGroup()
						}
						if t.attrs {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Attributes') ]
								DocNode('table', class='params') with
									t.attrs.map(F(name, desc) {
										DocNode('tr') with [
											DocNode('td') with [
												DocText(name)
											]
											DocNode('td') with [
												DocText(desc.join('\n') or '-')
											]
										]
									})
							]
						} else {
							DocGroup()
						}
						t.example.map(F(ex) {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Example') ]
								DocNode('pre', class='example', title='Example') with [
									ex.join('\n').DocText()
								]
							]
						}).get(DocGroup())
						if t.constructors {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Constructors') ]
								methods_impls_to_doc(t.constructors)
							]
						} else {
							DocGroup()
						}
						if t.methods {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Methods') ]
								methods_impls_to_doc(t.methods)
							]
						} else {
							DocGroup()
						}
					]
				]
			]
		}

		F do_types() {

			# Splat params will be Arr or Hash but they are not interesting
			F method_impl_has_arg_of_type(mi:Fun, t:Type) mi.params().reject(X.get('splat')).type.has(t)

			# We'll use it to list methods that have given
			# type as type of one of the parameters.
			methods = list_methods()

			types = globals().filterv(Type).filterk(is_public_name).rejectk(is_phased_out_type).sortk(lte)

			# Init with ( type -> [] ) pairs
			types_direct_children = types.values().Hash({ [] })

			types.values().each(F(t) {
				t.parents.each(F(p) {
					types_direct_children[p].push(t)
				})
			})

			types .= map(process_type)
			types_hash = types.map(F(t) [t.type, t]).Hash()

			for t in types {
				status("Augmenting type information: ${t.name}")
				t.parents = t.type.parents.map(types_hash[X]).sort('name')
				t.children = types_direct_children[t.type].map(types_hash[X])
				# maybe find it in methods variable instead of re-doing process_method_impl()
				t.constructors = t.type.constructors.reject(NormalTypeConstructor).map(process_method_impl(t.name, X))

				t.methods = collector
					methods.each(F(name, impls) {
						impls.filter(method_impl_has_arg_of_type(X, t.type)).map() do F(mi) {
							i = method_impl_id(name, mi)
							method_impls_by_id.Box(i).map(F(mis) {
								mis[1..null].each(collect)
							})
						}
					})
			}

			status("Preparing types HTML")
			types_index_html_doc = types_to_index_html_doc(types)
			$(mkdir -p ${doc_root / 'types'})
			status("Writing types (overview) page")
			write(doc_root / 'types/index.html', Doc::HtmlRoot(types_index_html_doc))

			for t in types {
				status("Making page for type ${t.name}")
				type_page_doc = type_to_type_page_doc(t)
				write(doc_root / 'types' / t.name.safe_file_name() + '.html', Doc::HtmlRoot(type_page_doc))

			}
		}

		$(cp main.css "$doc_root/")
		methods = list_methods().limit(60).map(process_method)
		do_methods()
		do_types()

	}
}


