#!/usr/bin/env ngs
{

	# Autoload
	AWS
	AWS2
	ArgvMatcher
	DelimStr
	Doc
	Iter
	Res
	ResDef
	Set
	Stats
	Table
	Thread
	test

	# TODO: Do not list all types on the namespace page,
	# just up to TYPES_THRESHOLD, probably the parents.
	TYPES_THRESHOLD = 10
	g = globals()

	# TODO: types trees pages

	F main(doc_root:Str) {

		global init, Str, Bool

		DocPart = Doc::Part
		DocNode = Doc::Node
		DocText = Doc::Text
		DocGroup = Doc::Group

		commit = `line: git rev-parse HEAD`

		F is_public_name(s:Str) s ~ /^[^_]/
		F is_phased_out_type(s:Str) s ~ Pfx('Aws')

		F safe_file_name(s:Str) s.replace(/[^-._a-zA-Z0-9]/, F(char) '%' + encode_hex(char))

		F object_attr(x, a:Str) (x.attrs() or {}).get(a).Box()
		F object_doc(x) x.object_attr('doc')
		F object_doc_attr(x, a:Str) object_doc(x).filter(a in X).map(X[a]).map(ensure_array)

		F head_fragment(title:Str, dotdots:Int=1) {
			\head [
				\meta charset='UTF-8'
				\link rel='stylesheet' href='../' * dotdots + 'main.css' type='text/css'
				\title [ title ]
			]
		}

		obj_to_description = {}

		type Description

			F generate(d:Description) {
				# status("Generating page for descriptors ${d}")
				dst = (d.path_as_item().map(safe_file_name)).reduce(doc_root, (/))
				p = page(d)
				file_content = Doc::HtmlRoot(p)
				log("Writing file=${dst} description=${d} len=${file_content.len()} hash=${file_content.hash()}")
				write(dst, file_content)

				children = get_chilren(d)

				if children {
					d = d.path_as_container().map(safe_file_name).reduce(doc_root, (/))
					log("Ensuring directory $d exists")
					$(mkdir -p $d)
					children.each(generate)
				}
			}

			F get_chilren(d:Description) []

			F Bool(d:Description) true

			F Str(d:Description) {
				"<${d.typeof().name} ${d.name}>"
			}

			F path_as_item(d:Description) d.containing_nd.path_as_container() + [(if d.name == 'index' then '_index' else d.name) + '.html']
			F path_as_container(d:Description) d.containing_nd.path_as_container() + [d.name]

			F nav_fragment(d:Description) {
				DocGroup() with [
					\div class='header' [
						"NGS version $VERSION auto-generated documentation"
					]
					\nav [
						"[ TODO: Navigation ]"
					]
				]
			}

			F description_fragment(d:Description)
				\section class='description' [
					d.description.map(F(desc) {
						desc.join('\n')
					}).get('Undocumented')
				]

			F example_fragment(d:Description) {
				d.example.map(F(ex) {
					\section [
						\h2 ['Example']
						\pre class='example' title='Example' [
							ex.join('\n')
						]
					]
				})
			}

			F page(d:Description) \html [ \body [ "NOT-READY-YET" ] ]


		type NamespaceDescription(Description)

			F fqname(nd:NamespaceDescription) fqname(nd.containing_nd) +? '::' + nd.name

			F init(nd:NamespaceDescription, namespace:Hash) {
				nd.fqname = nd.fqname()
				nd.description = object_doc_attr(namespace, '')
				nd.example = object_doc_attr(namespace, '%EX')
				# 'ext_links': doc_attr(ns, '%EXTLINK').map(ensure_array)
				# 'methods': ns.filterv(Fun).rejectv(Type).map(F(name, impls) {
				# 	# STDLIB_FILE_TYPE namespace has numbers as keys
				# 	impls = if impls is MultiMethod {
				# 		impls.Arr()
				# 	} else {
				# 		[impls]
				# 	}
				# 	process_method(Str(name), impls.filter(is_in_ns(X, ns)))
				# })
				nd.attrs = namespace.attrs().Box().get({}).get('doc', {}).without('').reject(X ~ /^%/).mapv(ensure_array)
				nd.objects_descriptions = {}
				nd.objects_by_type = {
					MultiMethodDescription: []
					MethodDescription: []
					TypeDescription: []
					NamespaceDescription: []
				}
				type_translations = {
					NativeMethod: 1
				}
				namespace.each(F(k, v) {
					# echo("K=$k")
					if t = Description(nd, k, v) {
						# echo("YES ${typeof(t)}")
						# echo("KV1 $k $t")
						if t is TypeDescription and nd is not GlobalNamespaceDescription {
							# Skip global types which are also in a namespace when showing the namespace
							g.get(k) === v returns
						}
						nd.objects_descriptions[k] = t
						nd.objects_by_type[t.typeof()].push(t)
					}
				})
			}

			F init(nd:NamespaceDescription, containing_nd:NamespaceDescription, name:Str, namespace:Hash) {
				init(args())
				obj_to_description[namespace] = nd
				super(nd, namespace)
			}

			F page_title(nd:NamespaceDescription) "${nd.fqname} namespace - NGS documentation"
			F page_heading(nd:NamespaceDescription) "${nd.fqname} namespace - NGS documentation"

			F index_fragment(nd:NamespaceDescription) {

				\dl [
					\dt [
						\a href=nd.path_as_item().map(safe_file_name).map(encode_uri_component).join('/') [nd.name]
					]
					\dd [
						description_fragment(nd)
						\div class='unobtrusive' [
							{
								'sub-namespaces':     NamespaceDescription
								'types':              TypeDescription
								'multimethods':       MultiMethodDescription
								'top level methods':  MethodDescription
							}.mapv({nd.objects_by_type[A].len()}).filterv(X>0).map("$Y $X").join(', ')
						]
						example_fragment(nd)
					] # dd
				]
			}

			# Not sure yet
			F top_level_types(nd:NamespaceDescription) {
				types = nd.objects_by_type[TypeDescription]
				all_types_count = len(types)
				types .= reject(F(t) {
					t.parents.any(F(p) {
						p.containing_nd === nd
					})
				})
				{
					'types': types
					'hidden': all_types_count - len(types)
				}
			}

			# TODO: MethodDescription (bootstrap_debug for example)
			F page(nd:NamespaceDescription) {
				tlt = top_level_types(nd)
				\html [
					head_fragment(page_title(nd))
					\body class='namespace-page' [
						nav_fragment(nd)
						\main [
							\h1 [page_heading(nd)]
							description_fragment(nd)
							example_fragment(nd)
							if nd.objects_by_type[NamespaceDescription] {
								DocGroup() with [
									\h2 ['Sub-namespaces']
									*nd.objects_by_type[NamespaceDescription].map(index_fragment)
								]
							}
							if tlt.types {
								DocGroup() with [
									\h2 ['Types']
									if tlt.hidden {
										\section class='unobtrusive' ["${tlt.hidden} types, which are descendants of types listed below, are not shown for brevity"]
									} else {
										DocGroup()
									}
									*tlt.types.map(index_fragment)
								]
							}
							if nd.objects_by_type[MultiMethodDescription] or nd.objects_by_type[MethodDescription] {
								DocGroup() with [
									\h2 ['Methods and Multimethods']
									*nd.objects_by_type[MultiMethodDescription].map(index_fragment)
									*nd.objects_by_type[MethodDescription].map(index_fragment)
								]
							}
						]
					]
				]
			}

			F get_chilren(nd:NamespaceDescription) {
				nd.objects_descriptions.values()
			}

			F Str(nd:NamespaceDescription) {
				"<${nd.typeof().name} ${nd.name} with ${nd.objects_descriptions.len()} items>"
			}

		type GlobalNamespaceDescription(NamespaceDescription)

			F fqname(gnd:GlobalNamespaceDescription) ''

			F init(gnd:GlobalNamespaceDescription) {
				super(gnd, g.without('main').filterk(is_public_name).rejectk(is_phased_out_type).sortk(lte))
			}

			F page_title(gnd:GlobalNamespaceDescription) "The global namespace - NGS documentation"
			F page_heading(gnd:GlobalNamespaceDescription) "The global namespace - NGS documentation"

			F path_as_item(gnd:GlobalNamespaceDescription) ['index.html']
			F path_as_container(gnd:GlobalNamespaceDescription) []

			F description_fragment(gnd:GlobalNamespaceDescription) null

			F Str(gnd:GlobalNamespaceDescription) {
				"<${gnd.typeof().name} with ${gnd.objects_descriptions.len()} items>"
			}


		type TypeDescription(Description)

			F init(td:TypeDescription, containing_nd:NamespaceDescription, name:Str, type:Type) {
				init(args())
				obj_to_description[type] = td
				td.constructor = MultiMethodDescription(containing_nd, name, type.constructors)
				td.description = object_doc_attr(type, '')
				td.example = object_doc_attr(type, '%EX')
				td.parents = []
				td.children = []
			}

			F index_fragment(td:TypeDescription) {
				alt_name = ' (' +? (if td.name != td.type.name then td.type.name else '') +? ')'
				\dl [
					\dt [
						\a href=td.path_as_item().map(safe_file_name).map(encode_uri_component).join('/') [td.name + alt_name]
					]
					\dd [
						\section [
							td.description.map(F(d) {
								DocText(d.join('\n'))
							}).get('Undocumented')
						]
						if td.children {
							\div class='unobtrusive' [
								"Direct subtypes: ${td.children.len()}"
							]
						} else {
							DocGroup()
						}
					]
				]
			}

			F page_title(td:TypeDescription) "${td.name} type - NGS documentation"
			F page_heading(td:TypeDescription) "${td.name} type - NGS documentation"

			F directly_related_types_fragment(td:TypeDescription, related_types:Arr, rel:Str) {
				if related_types {
					\section [
						\h2 [ "Direct ${rel} types" ]
						*related_types.map(index_fragment)
					]
				} else {
					DocGroup()
				}

			}

			F page(td:TypeDescription) {
				\html [
					head_fragment(page_title(td))
					\body class='type-page' [
						nav_fragment(td)
						\main [
							\h1 [page_heading(td)]
							description_fragment(td)
							example_fragment(td)
							directly_related_types_fragment(td, td.parents, 'parent')
							directly_related_types_fragment(td, td.children, 'children')
						]
					]
				]
			}

		type MultiMethodDescription(Description)

			F init(mmd:MultiMethodDescription, containing_nd:NamespaceDescription, name:Str, multimethod:MultiMethod) {
				init(args())
				obj_to_description[multimethod] = mmd
				mmd.methods = multimethod.Arr().reject(NormalTypeConstructor).map(MethodDescription(containing_nd, name, mmd, X))
				# mmd.methods = multimethod.Arr().map(MethodDescription(containing_nd, name, mmd, X))
			}

			F index_fragment(mmd:MultiMethodDescription) {
				\dl [
					\dt [
						\a href=mmd.name.safe_file_name().encode_uri_component() + '.FIXME.html' class='underline-on-hover-only' [
							mmd.name
						]
					]
					\dd [
						\section class='unobtrusive' [
							"MultiMethod with ${mmd.methods.len()} methods"
						]
					]
				]
			}

			F index_fragment(mmd:MultiMethodDescription) {
				guard mmd.methods.len() == 1
				mmd.methods[0].index_fragment()
			}




		type MethodDescription(Description)

			F init(md:MethodDescription, method:Fun) {
				obj_to_description[method] = md
				md.description = object_doc_attr(method, '')
				md.status = object_doc_attr(method, '%STATUS')
			}


			F init(md:MethodDescription, containing_nd:NamespaceDescription, name:Str, mmd:MultiMethodDescription, method:Fun) {
				super(md, method)
				init(args())
				md.mmd = FullBox(mmd)
			}

			F init(md:MethodDescription, containing_nd:NamespaceDescription, name:Str, method:Fun) {
				super(md, method)
				init(args())
				md.mmd = EmptyBox()
			}

			F has_own_page(md:MethodDescription) {
				die("Every method must have it's own page. At least for the parameters.")
				md.object_doc().without('').without('%STATUS')

			}

			F index_fragment(md:MethodDescription) {
				# DocGroup() with mi.status.get([]).map(F(s) {
				# 	DocNode('span', class="method-status") with [ DocText(s) ]
				# })
				\dl [
					\dt [
						\a href=md.name.safe_file_name().encode_uri_component() + '.FIXME.html' class='underline-on-hover-only' [
							md.name
						]
						DocGroup() with md.status.get([]).map(F(s) {
							\span class="method-status" [ s ]
						})
					]
					\dd [
						md.description.map(F(d) {
							DocText(d.join('\n'))
						}).get('Undocumented')
					]
				]
			}



		F Description(containing_nd:NamespaceDescription, name:Str, x) {
			if ENV.get('SHOW_IGNORED') {
				warn("Ignoring ${containing_nd} ${x.typeof()} ${name}")
			}
			null
		}

		F Description(containing_nd:NamespaceDescription, name:Str, method:Fun) {
			MethodDescription(containing_nd, name, method)
		}

		F Description(containing_nd:NamespaceDescription, name:Str, multimethod:MultiMethod) {
			MultiMethodDescription(containing_nd, name, multimethod)
		}

		F Description(containing_nd:NamespaceDescription, name:Str, t:Type) {
			TypeDescription(containing_nd, name, t)
		}

		F Description(containing_nd:NamespaceDescription, name:Str, maybe_namespace:Hash) {
			F is_namespace(x) {
				not(object_doc(x)) returns false
				x.keys().all(Int) returns false # STDLIB_FILE_TYPE, possibly others in future
				x.values().any(F(v) v is Type or v is Fun)
			}
			not(is_namespace(maybe_namespace)) returns null
			NamespaceDescription(containing_nd, name, maybe_namespace)
		}

		F augment_types() {
			status("Augmenting types information")

			tds = obj_to_description.values().filter(TypeDescription)

			# .parents
			for t in tds {
				t.parents = t.type.parents.map(obj_to_description[X])
			}

			# .children
			for t in tds {
				t.parents.each(F(p) {
					p.children.push(t)
				})
			}

			# # maybe find it in methods variable instead of re-doing process_method_impl()
			# t.constructors = t.type.constructors.Arr().reject(NormalTypeConstructor).register_constructors_mis().map(process_method_impl(t.name, X))
			# t.methods = types_methods[t.type].map(processed_methods[X]).reject({'is_constructor': true})

		}


		status("Building descriptors")
		global_ns = GlobalNamespaceDescription()

		status("Writing files")
		$(cp main.css "$doc_root/")

		augment_types()

		global_ns.generate()




		status("OK")

	}
}
