#!/usr/bin/env ngs
{

	# Autoload
	AWS
	ArgvMatcher
	DelimStr
	Doc
	Iter
	KV
	Lock
	Res
	ResDef
	Stats
	Table
	Thread
	test

	F main(doc_root:Str) {

		DocPart = Doc::Part
		DocNode = Doc::Node
		DocText = Doc::Text
		DocGroup = Doc::Group
		doc_visit = Doc::visit

		commit = `line: git rev-parse HEAD`
		limited = ENV.Box('LIMIT').map(Int).get(INT_MAX)

		F is_public_name(s:Str) s ~ /^[^_]/
		F is_phased_out_type(s:Str) s ~ Pfx('Aws')

		F to_lines(s:Str) [s]
		F to_lines(a:Arr) a

		F safe_file_name(s:Str) {
			s == 'index' returns 'index-'
			s.replace(/[^-_a-zA-Z0-9]/, F(char) '%' + encode_hex(char))
		}
		F method_impl_id(name:Str, mi:Fun) (name + '-' + mi.params().type.name.join('-'))

		F list_methods()
			collector/{}
				globals().filterk(is_public_name).sortk(lte).each(F(name, value) {
					cond {
						(value is Arr) and value.all(Fun) {
							collect(name, value)
						}
						value is Type {
							# NormalTypeConstructor is built-in. We are not documenting it here.
							collect(name, value.constructors.reject(NormalTypeConstructor))
						}
					}
				})

		F process_param(param:Hash, doc:Hash) {
			{
				'name':  param.name
				'type':  param.get('type', Any)
				'dflt':  param.Box('dflt')
				'splat': param.Box('splat')
				'doc':   doc.Box(param.name).map(to_lines)
			}
		}

		F doc_attr(x, attr:Str) {
			a = x.attrs()
			not(a) returns EmptyBox()
			(a.get('doc') or {}).Box(attr).map(to_lines)
		}

		method_impls_by_id = {}

		pfx = Pfx("$NGS_DIR/")
		F process_method_impl(name:Str, mi:Fun) {

			mi_doc = mi.attrs().doc or {}
			ret = {
				'name': name
				'mi': mi
				'description': doc_attr(mi, '')
				'auto': doc_attr(mi, '%AUTO').each(F(lines) assert(lines.len() == 1, '%AUTO must be used at most once per method'))
				'params': mi.params().map(process_param(X, mi_doc))
				'source_ref': Box(if mi is Closure {
					# Handling Closure, not handling built-ins yet
					location_info = mi.ip().resolve_instruction_pointer()
					if m = location_info.file ~ pfx {
						{
							'file': m.after
							'line': location_info.first_line
						}
					}
				})
				'returns': doc_attr(mi, '%RET').each(F(lines) assert(lines.len() == 1, '%RET must be used at most once per method'))
				'example': doc_attr(mi, '%EX').map(to_lines)
				'ext_links': doc_attr(mi, '%EXTLINK').map(to_lines)
			}
			method_impls_by_id.dflt(method_impl_id(name, mi), [name]).push(ret)
			ret

		}

		F process_method(name, implementations) {
			status("Processing method: $name")
			{
				'name': name
				'implementations': implementations.map(process_method_impl(name, X))
			}
		}

		F param_to_inline_html_doc(param:Hash) {
			DocNode('span', class='inline-param') with [
				DocText(param.name)
				DocText(':')
				DocText(param.type.name)
				param.dflt.map(F(d) {
					DocGroup() with [
						DocText('=')
						ematch d {
							Fun DocNode('span', class='non-literal') with [ DocText('method') ]
							Any DocText(d.code())
						}
					]
				}).get(DocGroup())
			]
		}

		F params_to_inline_html_doc(params:Arr) {
			DocGroup() with
				[
					DocText('('),
					*params.map(param_to_inline_html_doc).intersperse(DocText(', '))
					DocText(')')
				]
		}

		F make_page_head_doc(title:Str) {
			DocNode('head') with [
				DocNode('meta', charset='UTF-8')
				DocNode('link', rel='stylesheet', href='../main.css', type='text/css')
				DocNode('title') with [
					DocText(title)
				]
			]
		}

		F make_nav_doc(branch:Arr) {

			F nav_item_to_doc(item:Hash) DocNode('a', href=item.href) with [ DocText(item.title) ]
			F nav_item_to_doc(item:Str) DocNode('span', class='nav-here') with [ DocText(item) ]

			F make_nav_branch_doc(data:Arr) {
				len(data) == 1 returns DocNode('li') with [ data[0].nav_item_to_doc() ]
				DocGroup() with [
					DocNode('li') with [ data[0].nav_item_to_doc() ]
					DocNode('ul') with [ make_nav_branch_doc(data[1..null]) ]
				]
			}

			root_nav = [
				[{'title': 'Methods', 'href':  '../methods/index.html'}]
				[{'title': 'Types', 'href':  '../types/index.html'}]
				[{'title': 'Namespaces', 'href':  '../namespaces/index.html'}]
			]

			# echo("BRANCH $branch")
			nav = if branch {
				root_nav.map(F(x) {
					x[0].title != branch[0] returns x
					branch.len() == 1 returns branch
					x + branch[1..null]
				})
			} else {
				root_nav
			}

			DocNode('nav') with [
				DocNode('ul') with nav.map(make_nav_branch_doc)
			]
		}

		F method_impl_to_index_html_doc(name:Str, mi:Hash) {

			DocNode('div') with [
				DocNode('a', href=method_impl_id(name, mi.mi).safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with
					[
						DocText(name),
						*params_to_inline_html_doc(mi.params)
						DocText(' - ')
						mi.description.map(X.join('\n')).map(DocText).get(DocText('Undocumented'))
					]
			]

			DocNode('dl') with [
				DocNode('dt') with [
					DocText(name),
					*params_to_inline_html_doc(mi.params)
				]
				DocNode('dd') with [
					DocNode('section', class='method-description') with [
						mi.description.map(X.join('\n')).map(DocText).get(DocText('Undocumented'))
					]
					DocNode('div', class='link-to-method-impl-page') with [
						DocNode('a', href='../methods/' + method_impl_id(name, mi.mi).safe_file_name().encode_uri_component() + '.html') with
							[
								DocText('more'),
							]
					]
				] # dd
			]

		}

		F method_to_index_html_doc(method:Hash) {
			status("Preparing HTML doc for method ${method.name}")
			DocNode('div', style='index-page-method') with [
				# DocNode('a', href=method.name.safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with [
				# 	DocText(method.name)
				# ]
				*method.implementations.map(method_impl_to_index_html_doc(method.name, X))
			]
		}

		F methods_to_index_html_doc(methods:Arr) {
			DocNode('html') with [
				make_page_head_doc('Methods - NGS documentation')
				DocNode('body', class='methods-index-page') with [
					make_nav_doc(['Methods'])
					DocNode('main') with [
						DocGroup() with [
							DocNode('h1') with [
								DocText('Methods')
							]
						] + methods.map(method_to_index_html_doc)
					]
				]
			]
		}

		F method_impl_to_method_page_html_doc(name:Str, mi:Hash, opts:Hash) {
			DocNode('dl') with [
				DocNode('dt') with [
					DocText(name),
					*params_to_inline_html_doc(mi.params)
					mi.source_ref.map(F(r) {
						DocNode('span', class="source-ref") with [
							DocText('Source: ')
							DocNode('a', href="https://github.com/ilyash/ngs/blob/$commit/lib/${r.file}#L${r.line}") with [
								DocText("${r.file}:${r.line}")

							]
						]
					}).get(DocGroup())
				]
				DocNode('dd') with [
					DocNode('section', class='method-description') with [
						mi.description.map(X.join('\n')).map(DocText).get(DocText('Undocumented'))
					]
					mi.auto.map(F(a) {
						DocNode('section', class='auto unobtrusive') with [
							DocText('Automatically called by NGS for syntax:')
							DocNode('code', class='auto', title='Usage syntax') with [
								a[0].DocText()
							]
						]
					}).get(DocGroup())
					if mi.params.any({A.doc}) or mi.returns {
						DocNode('table', class='params') with
							mi.params.filter({A.doc}).map(F(param) {
								DocNode('tr', class='param') with [
									DocNode('td') with [
										DocText(param.name)
									]
									DocNode('td') with [
										param.doc.map(X.join('\n')).map(DocText).get(DocText('-'))
									]
								]
							}) + [
								mi.returns.map(F(rets) {
									DocNode('tr', class='returns') with [
										DocNode('td') with [
											DocNode('span', class='non-literal') with [ DocText('Returns') ]
										]
										DocNode('td') with [
											rets.join('\n').DocText()
										]
									]
								}).get(DocGroup())
							]
					} else {
						DocGroup()
					}
					mi.example.map(F(ex) {
						DocNode('section', class='example') with [
							DocNode('pre', class='example', title='Example') with [
								ex.join('\n').DocText()
							]
						]
					}).get(DocGroup())
					mi.ext_links.filter({opts.get('detailed')}).map(F(links) {
						DocNode('div') with [
							DocText('External links')
							DocNode('ul', class='external-links') with links.map(F(link) {
								parts = link.split(' ', 2)
								href = parts[0]
								text = parts.Box(1).get(href)
								DocNode('li') with [
									DocNode('a', href=href) with [ DocText(text) ]
								]
							})

						]
					}).get(DocGroup())
					if opts.get('detailed') {
						DocGroup()
					} else {
						DocNode('div', class='link-to-method-impl-page') with [
							DocNode('a', href='../methods/' + method_impl_id(name, mi.mi).safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with
								[
									DocText(name),
									*params_to_inline_html_doc(mi.params)
								]
						]
					}
				] # dd
			]
		}

		F methods_impls_to_doc(impls:Arr, opts:Hash={}) {
			DocGroup() with
				impls.map(F(i) {
					method_impl_to_method_page_html_doc(i.name, i, opts)
				})
		}


		F method_to_method_page_html_doc(method:Hash, opts:Hash={}) {
			# TODO: title
			nav = ['Methods']
			if opts.get('detailed') {
				nav += [{'title': method.name, 'href': method.name.safe_file_name().encode_uri_component() + '.html'}, method.name + " implementation ${opts.counter[0]}/${opts.counter[1]}"]
			} else {
				nav.push(method.name)
			}
			DocNode('html') with [
				make_page_head_doc("${method.name} method - NGS documentation")
				DocNode('body', class='method-page') with [
					make_nav_doc(nav)
					DocNode('main') with [
						DocNode('h1') with [
							DocText(method.name)
							DocNode('span', class='unobtrusive') with [ DocText(" (method)") ]
						]
					] + method.implementations.map(method_impl_to_method_page_html_doc(method.name, X, opts))
				]
			]

		}


		# XXX: "index" method file name collision with the index!
		F do_methods() {
			methods_index_html_doc = methods.methods_to_index_html_doc()
			$(mkdir -p ${doc_root / 'methods'})
			status("Writing methods (overview) page")
			write(doc_root / 'methods/index.html', Doc::HtmlRoot(methods_index_html_doc))

			for m in methods {
				status("Making page for method ${m.name}")
				# m.implementations
				method_page_html_doc = method_to_method_page_html_doc(m)
				write(doc_root / 'methods' / m.name.safe_file_name() + '.html', Doc::HtmlRoot(method_page_html_doc))
			}

			method_impls_page_count_by_method_name = method_impls_by_id.values().map(X[0]).Stats()
			method_impls_name_counter = Stats()

			method_impls_by_id.each(F(id, implementations) {
				name = implementations[0]
				impls = implementations[1..null]
				method_impls_name_counter.push(name)


				status("Making page for method id ${id}")
				# m.implementations
				method_id_page_html_doc = method_to_method_page_html_doc({'name': name, 'implementations': impls}, {
					'detailed': true
					'counter': [method_impls_name_counter[name], method_impls_page_count_by_method_name[name]]
				})
				write(doc_root / 'methods' / id.safe_file_name() + '.html', Doc::HtmlRoot(method_id_page_html_doc))
			})
		}

		F process_type(name:Str, t:Type) {
			# 'attrs': t.attrs().Box().map(X.doc).
			{
				'name': name
				'type': t
				'description': doc_attr(t, '')
				'attrs': (t.attrs() or {}).get('doc').Box().get({}).without('').reject(X ~ /^%/).mapv(to_lines)
				'example': doc_attr(t, '%EX').map(to_lines)
			}
		}

		F type_to_index_entry_doc(t:Hash) {
			DocNode('dl', style='method') with [
				DocNode('dt') with [
					DocNode('a', href=t.name.safe_file_name().encode_uri_component() + '.html', class='underline-on-hover-only') with [
						DocText(t.name)
					]
				]
				DocNode('dd') with [
					t.description.map(F(d) {
						DocText(d.join('\n'))
					}).get(DocText('Undocumented'))
				]
			]
		}

		F types_to_index_html_doc(types:Arr) {
			DocNode('html') with [
				make_page_head_doc("Types - NGS documentation")
				DocNode('body', class='types-index-page') with [
					make_nav_doc(['Types'])
					DocNode('main') with [
						DocNode('h1') with [ DocText('Types') ]
					] + types.map(type_to_index_entry_doc)
				]
			]
		}

		F type_to_type_page_doc(t:Hash) {
			DocNode('html') with [
				make_page_head_doc("${t.name} type - NGS documentation")
				DocNode('body', class='types-index-page') with [
					make_nav_doc(['Types', t.name])
					DocNode('main') with [
						DocNode('h1') with [ DocText(t.name) ]
						DocNode('section') with [
							t.description.map(F(d) {
								DocText(d.join('\n'))
							}).get(DocText('Undocumented'))
						]
						if t.parents {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Direct parent types') ]
								DocNode('ul') with t.parents.map(F(p) {
									DocNode('li') with [
										DocNode('a', href=p.name.safe_file_name().encode_uri_component() + '.html') with [
											DocText(p.name)
										]
									]
								})
							]
						} else {
							DocGroup()
						}
						if t.children {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Direct children types') ]
								DocNode('ul') with t.children.map(F(c) {
									DocNode('li') with [
										DocNode('a', href=c.name.safe_file_name().encode_uri_component() + '.html') with [
											DocText(c.name)
										]
									]
								})
							]
						} else {
							DocGroup()
						}
						if t.attrs {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Attributes') ]
								DocNode('table', class='params') with
									t.attrs.map(F(name, desc) {
										DocNode('tr') with [
											DocNode('td') with [
												DocText(name)
											]
											DocNode('td') with [
												DocText(desc.join('\n') or '-')
											]
										]
									})
							]
						} else {
							DocGroup()
						}
						t.example.map(F(ex) {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Example') ]
								DocNode('pre', class='example', title='Example') with [
									ex.join('\n').DocText()
								]
							]
						}).get(DocGroup())
						if t.constructors {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Constructors') ]
								methods_impls_to_doc(t.constructors)
							]
						} else {
							DocGroup()
						}
						if t.methods {
							DocNode('section') with [
								DocNode('h2') with [ DocText('Methods') ]
								methods_impls_to_doc(t.methods)
							]
						} else {
							DocGroup()
						}
					]
				]
			]
		}

		F do_types() {

			# Splat params will be Arr or Hash but they are not interesting
			F method_impl_has_arg_of_type(mi:Fun, t:Type) mi.params().reject(X.get('splat')).type.has(t)

			# We'll use it to list methods that have given
			# type as type of one of the parameters.
			methods = list_methods()

			types = globals().filterv(Type).filterk(is_public_name).rejectk(is_phased_out_type).sortk(lte).limit(limited)

			# Init with ( type -> [] ) pairs
			types_direct_children = types.values().Hash({ [] })

			types.values().each(F(t) {
				t.parents.each(F(p) {
					# "if" is good for test runs, where not all types are present in types_direct_children
					if p in types_direct_children {
						types_direct_children[p].push(t)
					}
				})
			})

			types .= map(process_type)
			types_hash = types.map(F(t) [t.type, t]).Hash()

			for t in types {
				status("Augmenting type information: ${t.name}")
				t.parents = t.type.parents.filter(X in types_hash).map(types_hash[X]).sort('name')
				t.children = types_direct_children[t.type].map(types_hash[X])
				# maybe find it in methods variable instead of re-doing process_method_impl()
				t.constructors = t.type.constructors.reject(NormalTypeConstructor).map(process_method_impl(t.name, X))

				t.methods = collector
					methods.each(F(name, impls) {
						impls.filter(method_impl_has_arg_of_type(X, t.type)).map() do F(mi) {
							i = method_impl_id(name, mi)
							method_impls_by_id.Box(i).map(F(mis) {
								mis[1..null].each(collect)
							})
						}
					})
			}

			status("Preparing types HTML")
			types_index_html_doc = types_to_index_html_doc(types)
			$(mkdir -p ${doc_root / 'types'})
			status("Writing types (overview) page")
			write(doc_root / 'types/index.html', Doc::HtmlRoot(types_index_html_doc))

			for t in types {
				status("Making page for type ${t.name}")
				type_page_doc = type_to_type_page_doc(t)
				write(doc_root / 'types' / t.name.safe_file_name() + '.html', Doc::HtmlRoot(type_page_doc))

			}
		}

		F process_namespace(name:Str, ns:Hash) {
			{
				'name': name
				'ns': ns
				'description': doc_attr(ns, '')
				'example': doc_attr(ns, '%EX').map(to_lines)
				'ext_links': doc_attr(ns, '%EXTLINK').map(to_lines)
				'types': ns.filterv(Type).map(F(name, t) {
					# STDLIB_FILE_TYPE namespace has numbers as keys
					process_type(Str(name), t)
				})
				'methods': ns.filterv(Fun).rejectv(Type).map(F(name, impls) {
					# STDLIB_FILE_TYPE namespace has numbers as keys
					if impls is not Arr {
						impls = [impls]
					}
					process_method(Str(name), impls)
				})
			}
		}

		F namespace_to_html_doc(ns:Hash, opts:Hash={}) {
			DocNode('dl') with [
				DocNode('dt') with [
					DocText(ns.name),
				]
				DocNode('dd') with [
					DocNode('section') with [
						ns.description.map(F(d) {
							DocText(d.join('\n'))
						}).get(DocText('Undocumented'))
					]
					ns.example.map(F(ex) {
						DocNode('section') with [
							DocNode('h2') with [ DocText('Example') ]
							DocNode('pre', class='example', title='Example') with [
								ex.join('\n').DocText()
							]
						]
					}).get(DocGroup())
					DocNode('div', class='link-to-method-impl-page') with [
						DocNode('a', href='../namespaces/' + ns.name.safe_file_name().encode_uri_component() + '.html') with
							[
								{
									'methods': len(ns.methods)
									'types': len(ns.types)
								}.filterv(X>0).map("$Y $X").join(', ').DocText()
							]
					]
				] # dd
			]
		}

		F namespaces_to_index_html_doc(namespaces:Arr) {
			DocNode('html') with [
				make_page_head_doc('Namespaces - NGS documentation')
				DocNode('body', class='namespaces-index-page') with [
					make_nav_doc(['Namespaces'])
					DocNode('main') with [
						DocGroup() with [
							DocNode('h1') with [
								DocText('Namespaces')
							]
						] + namespaces.map(namespace_to_html_doc)
					]
				]
			]
		}

		F do_namespaces() {

			# Heuristic for detecting namespaces
			# Should be changed if Namespace type is introduced
			F is_namespace(x) {
				x is not Hash returns false
				x.values().any(F(v) v is Type or v is Fun)
			}

			namespaces = globals().filterv(is_namespace).map(process_namespace).sort('name')

			status("Preparing namespaces HTML")
			namespaces_index_html_doc = namespaces_to_index_html_doc(namespaces)
			$(mkdir -p ${doc_root / 'namespaces'})
			status("Writing namespaces (overview) page")
			write(doc_root / 'namespaces/index.html', Doc::HtmlRoot(namespaces_index_html_doc))
		}

		$(cp main.css "$doc_root/")
		methods = list_methods().limit(limited).map(process_method)
		do_methods()
		do_types()
		do_namespaces()

	}
}


