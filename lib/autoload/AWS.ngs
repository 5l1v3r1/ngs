ns(GlobalRes=Res, GlobalResDef=ResDef, global_test=test) {

	# TODO: alert or handle somehow the special case when anchor properties are changed,
	#       this might be a programming error.

	# TODO: track newly added resources and provide a method to list them or have a callback

	# TODO: Use JSON tags. Currently special symbols in tag name or value will cause problems.
	# http://docs.aws.amazon.com/cli/latest/userguide/shorthand-syntax.html

	# TODO: log describe AWS CLI commands too

	# Methods with added implementations
	global Str, init, find, latest, create, update, delete, users_ids, run, id, ids, (==), subset

	# --------------------------------------------------
	# Constants
	# --------------------------------------------------

	# From https://wiki.debian.org/Cloud/AmazonEC2Image/Jessie
	AMI_OWNER_DEBIAN = '379101102735'
	AMI_OWNER_AMAZON = '801119661308'

	# --------------------------------------------------
	# Misc utilities
	# --------------------------------------------------

	F cli_tags(h:Hash) h / "Key=$X,Value=$Y"

	doc Convert Hash with AWS filters to command line arguments.
	doc Key-value pairs in which value is null or instance of EmptyBox are discarded.
	doc TODO: make it JSON when keys or values contain special characters such as = or ,
	F cli_filters(h:Hash) {
		filtered = h.rejectv(Null).rejectv(EmptyBox)
		unboxed = filtered.mapv(only(Box, get))
		unboxed.mapv(only(Pfx, { "${A.val}*" })).map("Name=$X,Values=$Y")
	}

	TEST AWS::cli_filters({}) == []
	TEST AWS::cli_filters({"x": "y", "z": null, "w": FullBox("ww")}) == ['Name=x,Values=y', 'Name=w,Values=ww']
	TEST AWS::cli_filters({"x": Pfx("aa"), "z": EmptyBox()}) == ['Name=x,Values=aa*']

	F cli_tags_filters(h:Hash) h / "Name=tag-key,Values=$X,Name=tag-value,Values=$Y"
	TEST AWS::cli_tags_filters({}) == []
	TEST AWS::cli_tags_filters({"x": "y"}) == ['Name=tag-key,Values=x,Name=tag-value,Values=y']

	_aws_cached_regions = null

	# --- regions ---
	_regions = cached({ ``aws ec2 describe-regions``.RegionName.sort() })
	F regions() _regions()

	F regions(cb:Fun) {
		regs = regions()
		regs.pmap(F(r) {
			data = cb(r)
			data % { A.Region = r }
			data
		}).flatten()
	}

	# --- zones ---
	# TODO: support regions
	_zones = cached({ ``aws ec2 describe-availability-zones``.ZoneName.sort() })
	F zones() _zones()

	# --------------------------------------------------
	# Res
	# --------------------------------------------------

	type Res(GlobalRes)

	F run(r:Res, log_pfx:Str, cmd:Command) r.def.run(log_pfx, cmd)

	F update_tags(r:Res, props:Hash) {
		target_tags = r.def.opt_prop('Tags', props).get({})
		current_tags = r.props.get('Tags', {})

		if current_tags == target_tags {
			r.def.log('update_tags/info', "Current tags: $current_tags are same as target tags, not updating")
			return
		}

		r.def.log('update_tags/info', "Current tags: $current_tags. Target tags: $target_tags")
		diff = cmp(current_tags, target_tags)

		# Tags might be only in Anchor
		# so we should create them during first update
		if (tags = cli_tags(diff.add + diff.change)) {
			r.run('update_tags/add', %(aws ec2 create-tags --resources ${r.id()} --tags $*tags))
		}

		# Tags might be only in Anchor
		# so we should not delete other tags
		if 'Tags' in props {
			if (tags = diff.remove / "Key=$X") {
				r.run('update_tags/remove', %(aws ec2 delete-tags --resources ${r.id()} --tags $*tags))
			}
		}
	}

	# --------------------------------------------------
	# ResDef
	# --------------------------------------------------

	type ResDef(GlobalResDef)

	F init(rd:ResDef, **kw)           super(rd, {'regions': null, 'Tags': {}} + kw)
	F init(rd:ResDef, _ngs_name:Str)  super(rd, {'regions': null, 'Tags': {}, 'name': _ngs_name})
	F init(rd:ResDef, _ngs_tags:Hash) super(rd, {'regions': null, 'Tags': _ngs_tags})

	F run(rd:ResDef, log_pfx:Str, cmd:Command) {
		if rd.dry_run {
			rd.log("run/$log_pfx", "would run: ${cmd.argv.join(' ')}")
			null
		} else {
			rd.log("run/$log_pfx", "running: ${cmd.argv.join(' ')}")
			``$cmd``
		}
	}

	F _assert_anchor_has_only_known_keys(rd:ResDef, *known_keys) {
		rd.anchor.without('regions', null).without('Tags', {}).each(F(k, v) {
			k not in known_keys throws InvalidArgument("Anchor contains unknown key '$k'. Known keys are: $known_keys")
		})
	}

	F _assert_props_has_only_known_keys(rd:ResDef, props:Hash, *known_keys) {
		props.without('META').each(F(k, v) {
			k not in known_keys throws InvalidArgument("Props contains unknown key '$k'. Known keys are: $known_keys")
		})
	}

	# --------------------------------------------------
	# Vpc
	# --------------------------------------------------

	type Vpc(ResDef)
	type VpcRes(Res)

	F id(r:VpcRes) r.props.VpcId

	F find(rd:Vpc) {
		rd.log('Find', 'VPC')
		rd._assert_anchor_has_only_known_keys('Tags', 'CidrBlock')
		filters = ['--filters'] +? (rd.anchor.Tags.cli_tags_filters() + cli_filters({'cidr': rd.anchor.get('CidrBlock')}))
		rd.resources = ``aws ec2 describe-vpcs $*filters``.map(VpcRes(rd, X))
		rd
	}

	F create(rd:Vpc, props:Hash) {
		rd._assert_props_has_only_known_keys(props, 'Tags', 'CidrBlock')
		cidr = rd.req_prop('CidrBlock', props)
		result = rd.run('Create VPC', %(aws ec2 create-vpc --cidr-block $cidr))
		rd.resources = rd.resources or []
		if not(rd.dry_run) {
			filters = cli_filters({'vpc-id': result.Vpc.VpcId})
			rd.resources += ``aws ec2 describe-vpcs --filters $*filters``.map(VpcRes(rd, X))
		}
	}

	F update(r:VpcRes, props:Hash) {
		r.def._assert_props_has_only_known_keys(props, 'Tags', 'CidrBlock')
		r.update_tags(props)
	}

	F delete(r:VpcRes) {
		r.def.run('Delete VPC', %(aws ec2 delete-vpc --vpc-id ${r.props.VpcId}))
	}

	F Str(r:Vpc) {
		t = if r.resources is Null {
			''
		} else {
			" ${r.ids().join(',')}"
		}
		"<Aws::Vpc$t anchor=${r.anchor}>"
	}

	# --- Extract VPC ID ---
	F _eval_vpc_id(x) x
	F _eval_vpc_id(rd:Vpc) rd.ids().the_one()

	# --------------------------------------------------
	# Internet Gateway
	# --------------------------------------------------

	type Igw(ResDef)
	type IgwRes(Res)

	F id(r:IgwRes) r.props.InternetGatewayId

	F find(rd:Igw) {
		rd.log('Find', 'IGW')
		rd._assert_anchor_has_only_known_keys('Tags', 'Attachments')
		filters = rd.anchor.Tags.cli_tags_filters()
		rd.anchor.get('Attachments', []).map(F(att) {
			filters += cli_filters({'attachment.vpc-id': _eval_vpc_id(att.VpcId)})
		})
		filters = ['--filters'] +? filters
		rd.resources = ``aws ec2 describe-internet-gateways $*filters``.map(IgwRes(rd, X))
		rd
	}

	F create(rd:Igw, props:Hash) {
		rd.log('Create', 'IGW')
		rd._assert_anchor_has_only_known_keys('Tags', 'Attachments')
		result = rd.run('Create IGW', %(aws ec2 create-internet-gateway))
		rd.resources = rd.resources or []
		if not(rd.dry_run) {
			filters = cli_filters({'internet-gateway-id': result.InternetGateway.InternetGatewayId})
			rd.resources += ``aws ec2 describe-internet-gateways --filters $*filters``.map(IgwRes(rd, X))
		}
	}

	F update(r:IgwRes, props:Hash) {
		r.def.log('Update', 'IGW')
		r.def._assert_anchor_has_only_known_keys('Tags', 'Attachments')
		r.update_tags(props)
		r.def.opt_prop('Attachments', props).each(F(target_attachments) {
			target_vpcs_ids = target_attachments.VpcId.map(_eval_vpc_id)
			current_vpcs_ids = r.props.Attachments.VpcId
			if current_vpcs_ids == target_vpcs_ids {
				r.def.log('update_attachments/info', "Current attachments: $current_vpcs_ids are same as target attachments, not updating")
				return
			}
			r.def.log('update_attachments/info', "Current attachments: $current_vpcs_ids. Target attachments: $target_vpcs_ids")
			diff = cmp(current_vpcs_ids, target_vpcs_ids)

			diff.add.each(F(vpc_id) {
				r.run('update_attachments/add', %(aws ec2 attach-internet-gateway --internet-gateway-id ${r.id()} --vpc-id $vpc_id))
			})

			# Attachments might be only in Anchor
			# so we should not delete other attachments
			if 'Attachments' in props {
				diff.remove.each(F(vpc_id) {
					r.run('update_attachments/remove', %(aws ec2 detach-internet-gateway --internet-gateway-id ${r.id()} --vpc-id $vpc_id))
				})
			}
		})

	}

	F delete(r:IgwRes) {
		r.def.run('Delete IGW', %(aws ec2 delete-internet-gateway --internet-gateway-id ${r.id()}))
	}

	# --------------------------------------------------
	# RouteTable (WIP)
	# --------------------------------------------------

	type RouteTable(ResDef)
	type RouteTableRes(Res)

	F id(r:RouteTableRes) r.props.RouteTableId

	F find(rd:RouteTable) {
		# TODO: route.gateway-id, route.instance-id
		rd.log('Find', 'VPC')
		rd._assert_anchor_has_only_known_keys('Tags', 'VpcId')
		filters = ['--filters'] +? (rd.anchor.Tags.cli_tags_filters() + cli_filters({'vpc-id': rd.anchor.Box('VpcId').map(_eval_vpc_id)}))
		rd.resources = ``aws ec2 describe-route-tables $*filters``.map(RouteTableRes(rd, X))
		rd
	}


	# --------------------------------------------------
	# SecGroup
	# --------------------------------------------------

	type SecGroup(ResDef)
	type SecGroupRes(Res)

	F init(rd:SecGroup, anchor:Arr) {
		warn("Using deprecated SecGroup anchor - array. Should use SecGroup(name, vpc) form.")
		super(rd, name=anchor[0], vpc_id=anchor[1])
	}

	F init(rd:SecGroup, name:Str, vpc_id) {
		guard vpc_id is Str or vpc_id is Vpc
		super(rd, name=name, vpc_id=vpc_id)
	}

	F id(r:SecGroupRes) r.props.GroupId

	F users_ids(r:SecGroup) r.resources / F(res) { {'GroupId': res.props.GroupId, 'UserId': res.props.OwnerId} }

	# TODO: refactor - start
	F vpc_id(rd:SecGroup) rd.anchor.get('vpc_id')

	F vpc_id(rd:SecGroup) {
		guard rd.anchor.get('vpc_id') is ResDef
		rd.anchor.vpc_id.ids().the_one()
	}

	F vpc_id_args(rd:SecGroup) ['--vpc-id', vpc_id(rd)]

	F vpc_id_args(rd:SecGroup) {
		guard vpc_id(rd) is Null
		[]
	}

	F vpc_id_filter(rd:SecGroup) ['--filters', "Name=vpc-id,Values=${vpc_id(rd)}"]

	F vpc_id_filter(rd:SecGroup) {
		guard vpc_id(rd) is Null
		[]
	}
	# TODO: refactor - end

	F find(rd:SecGroup) {
		rd.log('find', 'SG')
		rd._assert_anchor_has_only_known_keys('vpc_id', 'name', 'Tags')
		filters = ['--filters'] +? rd.anchor.Tags.cli_tags_filters()
		# XXX: check with default VPC / EC2 classic
		# Can not use --group-names as it will assume default VPC / EC2 classic
		resources = ``aws ec2 describe-security-groups $*{vpc_id_filter(rd)} $*filters``
		if 'name' in rd.anchor {
			resources .= filter(F(sg) sg.GroupName == rd.anchor.name)
		}
		rd.resources = resources.map(SecGroupRes(rd, X))
		rd
	}

	type IpPermBox(FullBox)

	# Cleans up AWS Security Group IpPermissions so it's possible to compare current and desired states of IpPermissions
	F cleanup(x:IpPermBox) {
		ret = x.val
		ret .= filter(F(k, v) (v is not Arr) or v)
		ret .= without('IpRanges', [{"CidrIp": "0.0.0.0/0"}])
		if 'UserIdGroupPairs' in ret {
			# Hash is ordered. The right order for comparison is GroupId and then UserId
			ret.UserIdGroupPairs .= map(F(pair) { {'GroupId': pair.GroupId, 'UserId': pair.UserId } })
		}
		ret
	}

	F ==(a:IpPermBox, b:IpPermBox) {
		a .= cleanup()
		b .= cleanup()
		a.len() != b.len() returns false
		diff = cmp(a, b)
		not(diff.add or diff.remove or diff.change)
	}

	# TOOD: continue here
	F subset(smaller:IpPermBox, larger:IpPermBox) {
		a .= cleanup()
		b .= cleanup()

	}

	F create(rd:SecGroup, props:Hash) {
		rd.log('Create', 'SG')
		rd.run('Create SG', %(aws ec2 create-security-group --group-name ${rd.anchor.name} --description ${rd.req_prop('Description', props)} $*{vpc_id_args(rd)}))
		if not(rd.dry_run) {
			rd.find()
		}
	}

	F update(sg:SecGroupRes, props:Hash) {

		sg.def.log('update', 'SG')

		if 'IpPermissions' in props {
			# PrefixListIds - http://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_IpPermission.html
			# (Valid for AuthorizeSecurityGroupEgress, RevokeSecurityGroupEgress and DescribeSecurityGroups only)
			# sg.props.IpPermissions.each(F(perm) perm.del('PrefixListIds'))
			diff = compare(sg.props.IpPermissions/IpPermBox, props.IpPermissions/IpPermBox)
			if diff.add {
				sg.run('add SG ingress rules', %(aws ec2 authorize-security-group-ingress --group-id ${sg.props.GroupId} --ip-permissions $*{diff.add.val / encode_json}))
			}
			if diff.remove {
				sg.run('remove SG ingress rules', %(aws ec2 revoke-security-group-ingress --group-id ${sg.props.GroupId} --ip-permissions $*{diff.remove.val / encode_json}))
			}
		}

		sg.update_tags(props)
	}

	F delete(r:SecGroupRes) {
		r.def.run('Delete security group', %(aws ec2 delete-security-group --group-id ${r.props.GroupId}))
	}

	# --------------------------------------------------
	# Subnet
	# --------------------------------------------------

	type Subnet(ResDef)
	type SubnetRes(Res)

	F id(r:SubnetRes) r.props.SubnetId

	F find(rd:Subnet) {
		rd.log('find', 'Subnet')
		rd._assert_anchor_has_only_known_keys('Tags', 'VpcId', 'CidrBlock', 'AvailabilityZone')
		filters = ['--filters'] +? ( rd.anchor.Tags.cli_tags_filters() + cli_filters({
			'vpc-id':             rd.anchor.Box('VpcId').map(_eval_vpc_id)
			'cidr':               rd.anchor.Box('CidrBlock')
			'availability-zone':  rd.anchor.Box('AvailabilityZone')
		}))
		rd.resources = ``aws ec2 describe-subnets $*filters``.map(SubnetRes(rd, X))
		rd
	}

	# TODO: Support multiple subnets so one could easily set up new VPC for RDS and ELB
	F create(rd:Subnet, props:Hash) {
		rd._assert_props_has_only_known_keys(props, 'VpcId', 'CidrBlock', 'AvailabilityZone')
		vpcid = rd.req_prop('VpcId', props)._eval_vpc_id()
		cidr = rd.req_prop('CidrBlock', props)
		az = rd.opt_prop('AvailabilityZone', props).map({ ['--availability-zone', A] }).get([])
		result = rd.run('Create Subnet', %(aws ec2 create-subnet --vpc-id $vpcid --cidr-block $cidr $*az))
		rd.resources = rd.resources or []
		if not(rd.dry_run) {
			filters = cli_filters({'subnet-id': result.Subnet.SubnetId})
			rd.resources += ``aws ec2 describe-subnets --filters $*filters``.map(SubnetRes(rd, X))
		}
	}

	F update(r:SubnetRes, props:Hash) {
		r.def.log('update', 'Subnet')
		r.def._assert_props_has_only_known_keys(props, 'Tags')
		r.update_tags(props)
	}

	F delete(r:SubnetRes) {
		r.def.run('Delete Subnet', %(aws ec2 delete-subnet --subnet-id ${r.props.SubnetId}))
	}

	# --------------------------------------------------
	# Image
	# --------------------------------------------------

	type Image(ResDef)
	type ImageRes(Res)

	# debian-jessie-amd64-hvm
	F find(rd:Image) {
		rd._assert_anchor_has_only_known_keys('OwnerId', 'Name', 'State', 'RootDeviceType', 'VolumeType')
		owners = ['--owners', rd.anchor.OwnerId] tor []
		filters = ['--filters'] +? cli_filters({
			'state':                            rd.anchor.get('State', 'available')
			'virtualization-type':              'hvm'
			'name':                             rd.anchor.Box('Name').filter({A is Str or A is Pfx})
			'root-device-type':                 rd.anchor.Box('RootDeviceType')
			'block-device-mapping.volume-type': rd.anchor.Box('VolumeType')
		})
		resources = ``aws ec2 describe-images $*owners $*filters``
		if 'Name' in rd.anchor {
			resources .= filter({A.Name ~ rd.anchor.Name})
		}
		rd.resources = resources / ImageRes(rd, X)
		rd.log('find', "found ${resources.len()} ${rd.typeof().name} resources")
		rd
	}

	# TODO: convert it to something more uniform,
	#       a property in Anchor for example, so one
	#       could just select the latest image with Anchor
	F latest(rd:Image) {
		if rd.resources is Null {
			rd.find()
		}
		assert(rd.resources.len() >= 1, "Can not find latest() image because there are no images")
		rd.resources = [rd.resources.sort({ A.props.CreationDate <= B.props.CreationDate })[-1]]
		rd
	}

	F id(r:ImageRes) r.props.ImageId


	# --------------------------------------------------
	# Instance
	# --------------------------------------------------

	type Instance(ResDef)
	type InstanceRes(Res)

	F find(rd:Instance) {
		filters = ['--filters', 'Name=instance-state-name,Values=running']
		filters += rd.anchor.Tags.cli_tags_filters()
		debug("Filters: $filters")

		regs = cond {
			rd.anchor.regions is Arr { rd.anchor.regions }
			rd.anchor.regions == '*' { regions() }
		}

		resources = if regs {
			instances = regs.pmap(F(r) {
				ins = ``aws ec2 describe-instances --region $r $*filters``
				ins % F(i) i.Region = r
				ins
			}).flatten()
			# .filter(F(i) try i.PublicIpAddress)
		} else {
			``aws ec2 describe-instances $*filters``
		}

		if regs {
			rd.log('find', "found ${resources.len()} ${rd.typeof().name} resources in ${resources.group({A.Region}).len()} regions (${resources.group({A.Placement.AvailabilityZone}).len()} zones)")
		} else {
			rd.log('find', "found ${resources.len()} ${rd.typeof().name} resources in ${resources.group({A.Placement.AvailabilityZone}).len()} zones)")
		}

		rd.resources = resources / InstanceRes(rd, X)
		rd
	}

	F id(r:InstanceRes) r.props.InstanceId

	# TODO: Support multiple NICs?
	F create(rd:Instance, props:Hash) {
		rd.log('create', 'Instance')
		assert(rd.resources is not Null, "Creating an instance assumes find() already run")
		%[ImageId].each(F(prop_name) {
			prop_name not in rd.anchor throws InvalidArgument("Anchor must contain $prop_name")
		})

		args = []
		args += ['--key-name', props.KeyName] tor []

		sgs = _sgs(rd).map_true(['--security-group-ids'] + X)

		# TODO: Support Res SubnetId?
		args += ['--subnet-id', props.SubnetId] tor []

		if props.get('PublicIpAddress', null) is Bool {
			args += [if props.PublicIpAddress '--associate-public-ip-address' '--no-associate-public-ip-address']
		}


		result = rd.run('Create Instance', %(aws ec2 run-instances --image-id ${rd._image_id()} $*args))
		if not(rd.dry_run) {
			rd.resources += result.Instances / InstanceRes(rd, X)
		}
	}

	# TODO: Support EC2 classic?
	F update(instance:InstanceRes, props:Hash) {
		instance.def.log('update', 'Instance')
		instance.update_tags(props)

		current_sgs = instance.props.SecurityGroups.GroupId
		target_sgs = _sgs(instance.def)
		diff = cmp(current_sgs, target_sgs)
		if diff.add or diff.remove {
			diff.add    % { instance.def.log('update', "${instance.id()} - Adding SG $A") }
			diff.remove % { instance.def.log('update', "${instance.id()} - Removing SG $A") }
			instance.def.run('Set security groups', %(aws ec2 modify-instance-attribute --instance-id ${instance.id()} --groups $*target_sgs))
		}
	}

	# Needed for update_tags()
	F id(instance:InstanceRes) instance.props.InstanceId

	# TODO: Support EC2 classic?
	# TODO: Handle SGS in Anchor?
	F _sgs(rd:Instance, props:Hash) {
		if 'SecurityGroups' in props {
			ret = props.SecurityGroups
			if ret is ResDef {
				ret .= ids()
			}
			return ret
		}
		[]
	}

	F _image_id(rd:Instance) {
		guard rd.anchor.ImageId is Image
		assert(rd.anchor.ImageId.resources.len() == 1, "Expecting exacty one image described by Image resource defeinition")
		rd.anchor.ImageId.ids()[0]
	}

	F _image_id(rd:Instance) {
		guard rd.anchor.ImageId is Str
		rd.anchor.ImageId
	}

	# --------------------------------------------------
	# Elb
	# --------------------------------------------------

	type Elb(ResDef)
	type ElbRes(Res)

	F id(rd:Elb) rd.resource.LoadBalancerName

	F find(rd:Elb) {
		rd.log('find', "ELB")
		resources = ``aws elb describe-load-balancers``
		if rd.anchor.get('name') is Str {
			resources .= filter(F(desc) desc.LoadBalancerName == rd.anchor.name)
		}
		# TODO: make tags fetching lazy
		rd.resources = resources.pmap(F(props) {
			ret = props
			ret.Instances = props.Instances.InstanceId
			rd.log('find', "Fetching ELB tags for LB ${props.LoadBalancerName}")
			ret.Tags = ``aws elb describe-tags --load-balancer-names ${props.LoadBalancerName}``[0].Tags
			ElbRes(rd, ret)
		})
		rd.resources .= reject(F(r) {
			not(rd.anchor.Tags.subset(r.props.Tags))
		})
		rd
	}

	F create(rd:Elb, props:Hash) {
		rd.log('create', "creating an ELB")
		rd.anchor.get('name') is not Str throws InvalidArgument("ELB name and must be a string, not ${rd.anchor.get('name')}")
		'ListenerDescriptions' not in props throws InvalidArgument("Elb must have 'listeners' property")

		('AvailabilityZones' not in props) and ('Subnets' not in props) throws InvalidArgument("Either 'AvailabilityZones' or 'Subnets' must be in Elb properties")
		'AvailabilityZones' in props throws NotImplemented("'AvailabilityZones' Elb property")
		subnets = try props.Subnets
		# TODO: subnets .= only(ResDef, ids)
		if subnets is ResDef {
			subnets .= ids()
		}
		# TODO: map_true()
		if subnets {
			subnets = ['--subnets', *subnets]
		}
		rd.run('create ELB', %(aws elb create-load-balancer --load-balancer-name ${rd.anchor.name} --listeners ${props.ListenerDescriptions.encode_json()} $*subnets))
		# TODO: Use specific find, with the name
		if not(rd.dry_run) {
			rd.find()
		}
	}

	F update(elb:ElbRes, props:Hash) {
		elb.def.log('update', 'ELB')
		elb.def.anchor.get('name') is not Str throws InvalidArgument("Elb is the ELB name and must be a string, not ${elb.def.anchor.get('name')}")

		# Tags
		if 'Tags' in props {
			diff = cmp(elb.props.get('Tags', {}), props.Tags)

			if (tags = cli_tags(diff.add + diff.change)) {
				elb.run('add ELB tags', %(aws elb add-tags --load-balancer-names ${elb.def.anchor.name} --tags $*tags))
			}

			if (tags = diff.remove) {
				elb.run('remove ELB tags', %(aws elb remove-tags --load-balancer-names ${elb.def.anchor.name} --tags $*tags))
			}

			# Health check. Note: only updates given properties and keeps the rest as they were.
			if 'HealthCheck' in props {
				diff = cmp(elb.props['HealthCheck'], props['HealthCheck'])
				assert(not(diff.add), "Can't handle additional health check properties ${diff.add}")
				if diff.change {
					elb.def.log('update', "ELB health check change: ${diff.change}")
					t = elb.props['HealthCheck'] + diff.change
					elb.run(
						'update ELB health check',
						%(aws elb configure-health-check --load-balancer-name ${elb.def.anchor.name} --health-check ${t.encode_json()})
					)
				}
			}
		}

		# Instances
		if 'Instances' in props {
			instances = props.Instances
			if instances is ResDef {
				instances .= ids()
			}
			diff = cmp(elb.props.Instances, instances)
			if diff.add {
				elb.run(
					'register instances with ELB',
					%(aws elb register-instances-with-load-balancer --load-balancer-name ${elb.def.anchor.name} --instances $*{diff.add})
				)
			}
			if diff.remove {
				elb.run(
					'deregister instances from ELB',
					%(aws elb deregister-instances-from-load-balancer --load-balancer-name ${elb.def.anchor.name} --instances $*{diff.remove})
				)
			}
		}

		# Security groups
		if 'SecurityGroups' in props {
			sgs = props.SecurityGroups
			if sgs is ResDef {
				if sgs.resources is Null {
					sgs.find()
				}
				sgs .= ids()
			}
			diff = cmp(elb.props.SecurityGroups, sgs)
			if diff.add or diff.remove {
				elb.run(
					'update ELB SGs',
					%(aws elb apply-security-groups-to-load-balancer --load-balancer-name ${elb.def.anchor.name} --security-groups $*{sgs})
				)
			}
		}

		# TODO: listeners
		if 'ListenerDescriptions' in props {
			diff = cmp(elb.props.ListenerDescriptions, props.ListenerDescriptions)
			# echo("DIFF $diff")
		}
	}

	F delete(elb:Elb) {
		elb.run('delete ELB', %(aws elb delete-load-balancer --load-balancer-name ${elb.anchor.name}))
	}

	# --------------------------------------------------
	# RecordSet
	# --------------------------------------------------

	# http://docs.aws.amazon.com/cli/latest/reference/route53/change-resource-record-sets.html

	# Anchor: [record_name, domain_name]. Most specific first to be unifrom with Subnet
	# Maybe support array or *-style wildcard for record_name?
	# Maybe support anchor hosted-zone-id in the future? Don't currently see how this could be useful.

	type RecordSet(ResDef)
	type RecordSetRes(Res)

	F validate(rd:RecordSet) {
		%[Name ZoneName].each(F(prop_name) {
			prop_name not in rd.anchor throws InvalidArgument("Anchor must contain $prop_name")
			not(rd.anchor[prop_name] ~ Sfx('.')) throws InvalidArgument("$prop_name (${rd.anchor[prop_name]}) must end with a dot")
		})
		"todo"
	}

	F find(rd:RecordSet) {
		rd.log('find', 'RecordSet')
		anchor = rd.anchor
		zones = ``aws route53 list-hosted-zones-by-name --dns-name ${anchor.ZoneName} --max-items 1``

		assert(zones.len() == 1 and zones[0].Name == anchor.ZoneName, "Zone ${anchor.ZoneName} not found when trying to create an RecordSet in it")
		zone_id = zones[0].Id
		rd.zone_id = zone_id

		type_args = if 'Type' in anchor {
			['--start-record-type', anchor.Type]
		} else {
			[]
		}

		rrs = ``aws route53 list-resource-record-sets --hosted-zone-id $zone_id --start-record-name ${anchor.Name} $*type_args``

		rrs .= filter({A.Name == anchor.Name})

		if 'Type' in anchor {
			rrs .= filter({A.Type == anchor.Type})
		}

		if 'SetIdentifier' in anchor {
			rrs .= filter({A.SetIdentifier == anchor.SetIdentifier})
		}

		rd.resources = rrs / RecordSetRes(rd, X)
		rd
	}

	F _get_props(rd:RecordSet, props:Hash) {
		ret = {}
		ret.update(props)
		%[Name Type SetIdentifier].each(F(prop) {
			if prop in rd.anchor and prop not in ret {
				ret[prop] = rd.anchor[prop]
			}
		})
		ret
	}

	F create(rd:RecordSet, props:Hash) {
		change_batch = {
			'Comment': props.get('Comment', "Added by AWS.ngs")
			'Changes': [{
				'Action': 'CREATE'
				'ResourceRecordSet': _get_props(rd, props)
			}]
		}
		rd.run('create RecordSet', %(aws route53 change-resource-record-sets --hosted-zone-id ${rd.zone_id} --change-batch ${change_batch.encode_json()}))
		if not(rd.dry_run) {
			rd.find()
		}
	}

	F update(rrset:RecordSetRes, props:Hash) {
		props = _get_props(rrset.def, props)
		diff = cmp(rrset.props, props)
		# NOT DONE AND NOT SURE!
		if diff.add or diff.change or diff.remove {
			change_batch = {
				'Comment': props.get('Comment', "Updated by AWS.ngs")
				'Changes': [{
					'Action': 'UPSERT'
					'ResourceRecordSet': _get_props(rrset.def)
				}]
			}
			rrset.run('update RecordSet', %(aws route53 change-resource-record-sets --hosted-zone-id ${rrset.def.zone_id} --change-batch ${change_batch.encode_json()}))
		}
	}

	# --------------------------------------------------
	# Bucket
	# --------------------------------------------------

	# TODO

	# ==================================================
	# Backwards compatibility with bunch of global variables
	# ==================================================

	# "global x = y" is not exported as it's syntactically
	# different from "x = y" (which is exported)
	global AWS_AMI_OWNER_DEBIAN = AMI_OWNER_DEBIAN
	global AWS_AMI_OWNER_AMAZON = AMI_OWNER_AMAZON
	global stdlib_aws_tags = cli_tags
	global aws_regions = regions
	global AwsRes = Res, AwsResDef = ResDef
	global AwsVpc = Vpc, AwsVpcRes = VpcRes
	global AwsSecGroup = SecGroup, AwsSecGroupRes = SecGroupRes
	global AwsSubnet = Subnet, AwsSubnetRes = SubnetRes
	global AwsImage = Image, AwsImageRes = ImageRes
	global AwsInstance = Instance, AwsInstanceRes = InstanceRes
	global AwsElb = Elb, AwsElbRes = ElbRes
	global AwsRecordSet = RecordSet, AwsRecordSetRes = RecordSetRes

	# ==================================================
	# Quick and dirty - set global variables
	# ==================================================

	F pollute(do_warn=true) {

		vars =
			_exports.filterk(/^AMI_OWNER/) +
			_exports.filterv(Type).without('Res').without('ResDef') +
			{
				'regions': regions
				'zones': zones
			}

		if do_warn {
			warn("Polluting global namespace with AWS-specific variables: ${vars.keys().join(', ')}")
		}

		vars.mapk(resolve_global_variable).each(set_global_variable)
	}
}
