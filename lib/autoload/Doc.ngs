ns {

	global init, push, inspect

	# Maybe add: NodesGroup - logical group, producing only children in the output

	doc EXPERIMENTAL! Do not use!
	type DocPart
		type Container(DocPart)
			type Node(Container)
			type Group(Container)
		type Textual(DocPart)
			type Comment(Textual)
			type Text(Textual)

	F init_children(c:Container) {
		if c.children is Null {
			c.children = []
		}
	}

	F init(n:Node, name:Str, children:Arr=null, **attrs) {
		init(args())
		init_children(n)
	}

	F init(g:Group, children:Arr=null, **attrs) {
		init(args())
		init_children(g)
	}


	F init(t:Textual, txt:Str) init(args())

	F push(c:Container, dp:DocPart) c.children.push(dp)

	F name(dp:DocPart) null
	F name(n:Node) n.name

	F children(dp:DocPart) []
	F children(c:Container) c.children

	F each_child(dp:DocPart, cb:Fun) dp.children().each(cb)
	F map_children(dp:DocPart, mapper:Fun) dp.children().map(mapper)

	# Open issue: what should be the correct order of "parents" when passed to transformer() in transform() and to cb() in visit()

	F Transformer(x:Fun) x

	F Transformer(x:Hash) {
		t = F generated_transformer(dp) {
			k = if dp is Node then dp.name else dp.typeof()
			k not in x throws NotImplemented("Doc::transform was not given transformer for Doc::DocPart '$k'").set('key', k)
			x[k](dp)
		}
	}

	# TODO: maybe remove options?
	# Children are visited first so when parent is visited it has the transformed children to pack into result
	F transform(dp:DocPart, transformer) {
		t = Transformer(transformer)
		t(dp)
	}

	F transform(dps:Arr, transformer) {
		guard dps.all(DocPart)
		t = Transformer(transformer)
		dps.map(transform(X, t))
	}

	F visit(dp:DocPart, cb:Fun, parents:Arr=[]) {
		p = parents + [dp]
		dp.each_child({visit(A, cb, p)})
		cb(dp, parents)
	}

	F Html(n:Node) {

		ret = collector/'' {
			collect("<${n.name}")
			n.attrs.each(F(k, v) {
				collect(" $k=\"${encode_html_attr(Str(v))}\"")
			})

			if n.children {
				collect(">")
				n.map_children(Html).each(F(child_text) {
					collect(child_text)
				})
				collect("</${n.name}>")
			} else {
				collect("/>")
			}
		}
	}

	F HtmlRoot(n:Node) {
		'<!DOCTYPE html>\n' + Html(n)
	}

	F Html(t:Text) encode_html(t.txt)

	F Html(g:Group) g.map_children(Html).join('')

	F inspect(n:Node, levels=2) {
		collector {
			c = collect
			c("Doc::" + n.typeof().name + (if 'name' in n then " ${n.name}" else "")) # later - maybe typeof can return namespace name?

			n.attrs.each(F(k, v) {
				c("  Attribute [${SafeStr(k)}] = ${SafeStr(v)}")
			})

			if levels > 0 {
				n.children.each_idx_val(F(idx, val) {
					# echo("child $levels - $idx")
					("  Child $idx: " + inspect(val, levels-1)) % c
				})
			} else {
				n.children.each_idx_val(F(idx, val) {
					c("  Child $idx: ${SafeStr(val)}")
				})
			}
		}
	}

}
