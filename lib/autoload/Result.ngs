# TODO: think about multi-valued results (say 10 hosts, 8 succeeded and 2 failed)
# TODO: think about Argv cooperation. Maybe Failure is NoData and Success is FullBox?
{
	doc Thrown by get(Failure) as it has no value to get
	type ResultFail(Error)

	doc Result of a computation
	doc val - computed value or exception
	type Result

		doc Successful computation
		doc val - computed value
		type Success(Result)

		doc Failed computation
		doc val - exception
		type Failure(Result)
	
	doc Runs the computation and wraps the result: a value is wrapped in Success and an exception is wrapped in Failure.
	doc %RET - Success or Failure
	F Result(fun:Fun) {
		try {
			Success(fun())
		} catch(e) {
			# if e is Null {
			# 	throw Error("E IS NULL").set('cause', e)
			# }
			Failure(e)
		}
	}

	F init(r:Result, v) r.val = v

	doc Gets wrapped value
	F get(s:Success) s.val

	doc Throws ResultFail
	F get(f:Failure) {
		e = ResultFail("Can not get value of Failure")
		if f.val is Exception {
			e.cause = f.val
		} else {
			e.failure = f.val
		}
		throw e
	}

	doc Gets wrapped value
	F get(s:Success, dflt) s.val

	doc Retruns dflt
	F get(f:Failure, dflt) dflt

	doc Run fun with wrapped value. If exception is thrown, Failure is returned; otherwise Success with new vaule is returned.
	doc %RET - Result
	F map(s:Success, fun:Fun) {
		try {
			Success(fun(s.val))
		} catch(e) {
			Failure(e)
		}
	}

	doc No-op, returns f
	doc %RET - f
	F map(f:Failure, fun:Fun) f

	doc Run predicate on wrapped value.
	doc %RET - s or Failure
	F filter(s:Success, predicate) { p = Pred(predicate); if p(s.val) s else Failure(ResultFail("Success filtered out, resulting Failure").set('filter', predicate)) }

	doc No-op, returns f
	doc %RET - f
	F filter(f:Failure, predicate) f

	doc %RET - true
	F Bool(s:Success) true

	doc %RET - false
	F Bool(f:Failure) false

	doc EXPERIMENTAL! Do not use!
	F to_exit_code(r:Result) r.Bool().to_exit_code()
}

TEST {read("/etc/passwd")}.Result() is Success
TEST {read("NO-SUCH-FILE")}.Result() is Failure
TEST Success(10).map(X*2).get() == 20
