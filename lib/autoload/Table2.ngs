# === Table ======================================
# TODO: namespace

ns {
	global init, push, each, len, echo

	doc Table cell. Array of rows.
	type Cell(ArrLike)

	doc Any unknown value is a table cell with one row, Str(val)
	F init(c:Cell, val) {
		super(c)
		c.val = val
		c.push(Str(val))
	}

	doc A null value is a table cell with one row, "-"
	F init(c:Cell, val:Null) {
		super(c)
		c.val = val
		c.push("-")
	}

	doc An Eachable1 value is a table cell with all elements one below the other.
	doc Converts elements to strings using Cell().
	F init(c:Cell, val:Eachable1) {
		guard val is not Str
		guard val is not Int
		super(c)
		c.val = val
		# TODO: If array elements are more than one line, put a separator
		val.each(F(v) {
			t = Cell(v)
			t.each(c.push(X))
		})
		# cells = val.map(Cell)
		# do_separators = cells.max(len) > 1

		# aws ec2 describe-route-tables
		# WIP # cells = val.each(Cell)
		# WIP # do_sep = any(cells, {A.height() > 1})
	}

	doc An Eachable2 value is a table cell with all pairs one below the other.
	doc Converts values to strings using Cell().
	F init(c:Cell, val:Eachable2) {
		guard val is not Str
		super(c)
		c.val = val
		val.each(F(k, v) {
			assert(k is Str)
			c.push("${k}:")
			t = Cell(v)
			t.each({ c.push("  ${A}") })
		})
	}

	doc Make a cell of given width. Uses Cell(val).
	F init(c:Cell, val, width:Int) {
		init(c, val)
		c.items .= map(Str(X, width))
	}

	doc Get cell with, defaults to zero.
	F width(c:Cell) (c or [""]).map(len).max()

	doc Get cell height.
	F height(c:Cell) len(c)

	doc Holds tabular data
	doc name - Table name to display and for configuration lookup
	doc cols_enum - Enum for columns names
	type Table(Eachable1)

	doc Initialize rows to an empty array
	F init(t:Table, name=null) {
		guard name is Str or name is Null
		init(args())
		t.cols_enum = Enum()
		t.rows = []

		conf = config(if t.name "table_${t.name}" "table") or []
		debug("Table", "Table config is $conf")
		conf % register_column(t, X)
	}

	# TODO: smarter algorithm
	F columns_names_best_order(cols:Arr) {
		a = [/^id$/i, /id$/i, /^stat/i, /^name$/i, /description$/i, /name$/i]

		F weight(col) {
			idx = 0
			for x in a {
				idx += 1
				if col ~ x {
					return [1000, idx, col]
				}
			}
			[2000, 0, col]
		}

		weighted = cols.map(F(col) {
			{
				'name': col
				'weight': weight(col)
			}
		})

		weighted.sort('weight').name
	}

	doc Create named table containing provided rows
	doc name - name of the table for display and for configuration purposes
	doc rows_hashes - rows, each row is a Hash
	F init(t:Table, name, rows_hashes:Arr) {
		guard name is Str or name is Null
		guard rows_hashes.all(Hash)
		super(t, name)

		if not(t.cols_enum) {
			# rows_hashes.map(keys).flatten().each(register_column(t, X))
			cols_names = rows_hashes.map(keys).flatten().uniq()
			columns_names_best_order(cols_names).each(register_column(t, X))
		}
		debug("Table", "Table created with fields: ${t.cols_enum}")
		rows_hashes % push(t, X)
	}

	doc Create unnamed table containing provided rows
	F init(t:Table, rows_hashes:Arr) super(t, null, rows_hashes)

	doc Create single-line table
	F init(t:Table, row_hash:Hash) super(t, null, [row_hash])

	TEST Table2::columns(Table2::Table({"a": 1, "b": 2})) == [[1], [2]]

	doc Internal method. Please do not use.
	F register_column(t:Table, k) t.cols_enum.push(k)

	doc Append give row to the table
	doc %RET - t
	F push(t:Table, row_arr:Arr) {
		# TODO: handle mismatch in number of columns
		t.rows.push(row_arr)
		t
	}

	doc Append give row to the table
	doc %RET - t
	F push(t:Table, row_hash:Hash) {
		# TODO: handle mismatch of columns
		row = t.cols_enum / get(row_hash, X, null)
		t.push(row)
		t
	}

	doc Internal method. Please do not use.
	F width(t:Table) t.cols_enum.len()

	doc Get values in the given table column.
	doc %RET - Arr
	F column(t:Table, k:Str) t.column(t.cols_enum[k])

	doc Get values in the given table column.
	doc %RET - Arr
	F column(t:Table, n:Int) t.rows.map(X[n])

	doc Get values in all table columns.
	doc %RET - Arr of Arr
	F columns(t:Table) t.width().map(t.column(X))

	doc Please do not use. This method might change.
	doc Call cb with each table row.
	F each(t:Table, cb:Fun) t.rows.each(cb)

	# --- Conversions ---

	doc Get number of rows in the table.
	F len(t:Table) t.rows.len()

	doc Check whether there are any rows in the table.
	F Bool(t:Table) t.len().Bool()

	doc Internal method. Please do not use.
	F calculate_num_cols_to_show(t:Table, max_colums_widths:Arr, available_cols:Int) {
		cols_to_show = 0
		for(i; max_colums_widths.len()) {
			# TODO: unhardcode the "+1" spacing width
			cols_to_show += max_colums_widths[i] + 1
			cols_to_show > available_cols returns i
		}
		i
	}

	# TODO: echo(t:Table) for non-tty. Alternatives JSON or greppable.

	doc Displays a table. Implemented only for tty output (or output_format=text configuration)
	F echo(t:Table) {
		guard 1.isatty() or (config('output_format') == 'text')
		lines = (ENV.get('LINES')   or `tput lines`).Int()
		cols  = (ENV.get('COLUMNS') or `tput cols`).Int()
		# TODO: special treatment for tmux? can print any width and tmux can be adjusted later.
		# TODO: support Arr in headers
		# TODO: handle Hash type of cell (maybe allow configuring order of keys etc)
		# TODO: handle limiting width of a cell, probably using subtype of TableMeta

		do_output_headers = config('output_headers') in [null, true]
		max_colums_widths = t.cols_enum.map(F(k, idx) {
			col = t.column(idx)
			((if do_output_headers [k] []) + col).map(Cell).max(width)
		})

		# How much full table columns fit on the screen
		showing_n_columns = t.calculate_num_cols_to_show(max_colums_widths, cols)

		# Setup line spacing
		do_line_spacing = t.any(F(row) {
			row.any(F(cell) {
				Cell(cell).height() > 1
			})
		})

		do_line_spacing = if do_line_spacing F() echo('') else nop

		# Title
		if t.name and (config('output_title') in [null, true]) {
			echo("=== ${t.name} ===")
			do_line_spacing()
		}

		# Headers
		# WARNING: Headers assumed to be Str
		if(do_output_headers) {
			t.cols_enum.limit(showing_n_columns).map(F(k, idx) Cell(k, max_colums_widths[idx])[0]).join(' ').echo()
			do_line_spacing()
		}

		# Rows
		t.rows.each(F(row) {
			row_cells = row.limit(showing_n_columns).map_idx_val(F(idx, cell) {
				Cell(cell, max_colums_widths[idx])
			})
			screen_lines_for_row = row_cells.max(height)
			for(screen_line; screen_lines_for_row) {
				screen_line_items = row_cells.map_idx_val(F(idx, cell) {
					cell.get(screen_line, Str('', max_colums_widths[idx]))
				})
				echo(screen_line_items.join(' '))
			}
			do_line_spacing()
		})

		# TODO: remove, make per-page
		if(do_output_headers) {
			t.cols_enum.limit(showing_n_columns).map(F(k, idx) Cell(k, max_colums_widths[idx])[0]).join(' ').echo()
			do_line_spacing()
		}
	}

	doc Output (echo) CSV table with cells that contain arrays converted to columns.
	doc TODO: data escaping.
	F echo(t:Table) {
		guard config('output_format') == 'csv-flat'
		col_elts = t.cols_enum.values().Hash(F(col_name) {
			col = t.column(col_name).map(only(X is not Arr, F(x) [x]))
			(col.map(len) + [0]).max()
		})
		# echo(col_elts)
		field_names = t.cols_enum.map(F(col_name, col_idx) {
			field_names = map_base_idx(col_name, col_elts[col_idx], { "${A}_${B+1}" })
		}).flatten()

		# Headers
		echo(field_names.join(','))

		t.rows.each(F(row) {
			cols_to_display = row.map_idx_val(F(col_idx, cell) {
				val = ematch cell {
					Arr  cell
					Null ['']
					Any  [cell]
				}
				n = col_elts[col_idx]
				val
			}).flatten()
			echo(cols_to_display.join(','))
		})
	}

	TEST Table2::column(Table2::Table([{"a": 1}, {"a": 2}]), "a") == [1,2]
	TEST Table2::columns(Table2::Table([{"a": 1}, {"a": 2}])) == [[1,2]]
	TEST Table2::Table([{"a": 1}, {"a": 2}]).len() == 2
}
