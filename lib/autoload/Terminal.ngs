ns {

	# TODO: move stdin(0) and stdout(1) to constants... but where?

	global inherit
	global Terminal, AnsiTerminal, NoTerminal
	global init, read, write
	global echo, status

	# Should typically be up to two
	# * stdin:stdout
	# * stdin:stderr
	terminals = {}

	doc %STATUS - experimental
	type Terminal

		# TODO: more flexible, correct and extensible terminal type selection
		F Terminal(fd_in:Int, fd_out:Int) {
			k = "${fd_in}:${fd_out}"
			k in terminals returns terminals[k]
			terminals[k] = NoTerminal(fd_in, fd_out)
		}

		F Terminal(fd_in:Int, fd_out:Int) {
			guard isatty(fd_out)
			k = "${fd_in}:${fd_out}"
			k in terminals returns terminals[k]
			terminals[k] = AnsiTerminal(fd_in, fd_out)
		}

		F Terminal() Terminal(0,1)

		F init(t:Terminal, fd_in:Int, fd_out:Int) {
			t.term = null
			t.ver = null
			t.fd_in = fd_in
			t.fd_out = fd_out
		}

		F init(t:Terminal) t.init(0, 1)

		F read(t:Terminal, count:Int=1) t.fd_in.read(count)

		F write(t:Terminal, s:Str) {
			t.fd_out.write(s)
			t
		}

		F echo(t:Terminal, s:Str) {
			t.fd_out.write(s)
			t.fd_out.write(STDLIB_EOL)
			t
		}

		F status(t:Terminal, s:Str) {
			echo(stdlib_error_fd, "[STATUS ${Time()}] $s")
			t
		}
		doc Represents output not connected to a terminal but to
		doc a file or a pipe.
		doc %STATUS - experimental
		type NoTerminal(Terminal)

		doc %STATUS - experimental
		type AnsiTerminal(Terminal)

			F init(at:AnsiTerminal, *args) {
				super(at, *args)
				at._fd_pos = null
			}

			F write_csi(at:AnsiTerminal) at.write("\e[")
			F write_csi(at:AnsiTerminal, s:Str) at.write("\e[${s}")

			F write_st(at:AnsiTerminal) at.write("\e\\")

			# https://en.wikipedia.org/wiki/ANSI_escape_code#Examples
			# "Some terminals require the DEC sequences ESC 7 / ESC 8 instead which is more widely supported."
			# XXX consider moving to ANSI codes
			global save_cursor
			F save_cursor(at:AnsiTerminal) at.write("\e7")

			global restore_cursor
			F restore_cursor(at:AnsiTerminal) at.write("\e8")

			global set_scroll_area
			F set_scroll_area(at:AnsiTerminal, start:Int, end:Int) at.write_csi("${start};${end}r")

			global move_cursor_up
			F move_cursor_up(at:AnsiTerminal, n:Int=1) at.write_csi("${n}A")

			global erase_in_line
			F erase_in_line(at:AnsiTerminal, n:Int=0) at.write_csi("${n}K")


			global arrange_scroll_area
			# See apt/apt-pkg/install-progress.cc
			doc %STATUS - experimental
			F arrange_scroll_area(at:AnsiTerminal, start:Int, end:Int) {
				at.write("\n")        # avoid glitch
				at.save_cursor().set_scroll_area(start, end).restore_cursor().move_cursor_up(1)
				# TODO: flush
				# TODO: ioctl(pty, TIOCSWINSZ, (char *)&win);
				null
			}

			F status(at:AnsiTerminal, s:Str) {
				# TODO maybe: F pos(...) c_lseek(..., 0, "cur")
				new_fd_pos = c_lseek(at.fd_out, 0, "cur")
				if at._fd_pos == new_fd_pos {
					at.move_cursor_up().erase_in_line()
				}
				super(at, s)
				at._fd_pos = c_lseek(at.fd_out, 0, "cur")
				null
			}

			doc %STATUS - experimental
			type ItermTerminal(AnsiTerminal)

				# iTerm2 detection is based on iTerm2/tests/isiterm2.sh
				F AnsiTerminal(fd_in:Int, fd_out:Int) {
					guard 'NGS_NO_ITERM' not in ENV
					saved_stty=`stty -g`
					F read_dsr() {
						debug("file", "AnsiTerminal() read_dsr() reading 2 bytes spam")
						spam = fd_in.read(2)
						collector/'' {
							debug("file", "AnsiTerminal() read_dsr() reading till 'n'")
							while (byte = fd_in.read(1)) != 'n' {
								collect(byte)
							}
						}
					}
					$(stty -echo -icanon raw 0<${fd_in} 1>${fd_out})
					fd_out.write("\e[1337n") # iTerm2 proprietary code
					fd_out.write("\e[5n")    # report device status 
					version_string = read_dsr()
					if 'ITERM' in version_string {
						# The seen response was from DSR 1337. Discarding response to DSR 5.
						read_dsr()
					} else {
						# No response to DSR 1337. We are seing response to DSR 5.
						version_string = null
					}
					$(stty $saved_stty 0<${fd_in} 1>${fd_out})
					guard version_string
					parts = version_string.split(' ')
					ItermTerminal(fd_in, fd_out).set('term', parts[0]).set('ver', parts[1])
				}

				F init(it:ItermTerminal, *args) {
					super(it, *args)
					it._status_set_badge_format_done = false

				}

				F write_iterm_csi(it:ItermTerminal) it.write("\e]1337;")
				F write_iterm_csi(it:ItermTerminal, s:Str) it.write_iterm_csi().write(s)
				F write_iterm_cmd(it:ItermTerminal, s:Str) it.write_iterm_csi(s).write_st()

				# https://www.iterm2.com/documentation-badges.html
				global set_badge_format
				F set_badge_format(it:ItermTerminal, fmt:Str) it.write_iterm_cmd("SetBadgeFormat=${fmt.encode_base64()}")

				global set_user_var
				F set_user_var(it:ItermTerminal, k:Str, v:Str) it.write_iterm_cmd("SetUserVar=${k}=${v.encode_base64()}")

				# TODO: Issue #205 - make status() configurable
				F status(it:ItermTerminal, s:Str) {
					if not(it._status_set_badge_format_done) {
						it.set_badge_format("\\(user.status)")
						it._status_set_badge_format_done = true
						exit_hook["iterm_clear_status_badge:${it.fd_in}:${it.fd_out}"] = {
							it.set_badge_format("")
						}
					}
					it.set_user_var('status', s)
				}

				# TODO: https://iterm2.com/documentation-escape-codes.html

			doc %STATUS - experimental
			type TmuxTerminal(AnsiTerminal)

				F AnsiTerminal(*args) {
					guard 'NGS_NO_TMUX' not in ENV
					# XXX: How to distingush between tmux and screen?
					#      Locally TMUX environment variable should be enough.
					#      How about remote (local tmux connected to a remote using SSH)?
					#      Do we care?
					guard ENV.get('TERM') == 'screen'
					TmuxTerminal(*args)
				}

}
