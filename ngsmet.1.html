<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Ilya Sher" />
  <meta name="date" content="2016-01-01" />
  <title>NGSMET(1) NGS User Manual</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">NGSMET(1) NGS User Manual</h1>
<h2 class="author">Ilya Sher</h2>
<h3 class="date">2016</h3>
</div>
<h1 id="name">NAME</h1>
<p>ngsmet - Next Generation Shell built-in and standard library methods.</p>
<p>This page is work in progress and is now at very early stage. It is automatically generated from the <em>doc</em> directives in the source code.</p>
<ul>
<li><strong>!=</strong>
<ul>
<li>!=(a:Any, b:Any)</li>
</ul></li>
<li><strong>!==</strong>
<ul>
<li>!==(a:Any, b:Any)</li>
</ul></li>
<li><strong>$()</strong>
<ul>
<li>$()(c:Command)</li>
</ul></li>
<li><strong>%</strong>
<ul>
<li><p>%(a:Int, b:Int)</p></li>
<li><p>%(x:Any, cb:Fun)</p>
<p><em>Description</em></p>
<p>Each operator<br />
Syntax: % is similar to /</p>
<p><em>Example</em></p>
<pre><code>[1,2,3,4] % echo</code></pre></li>
</ul></li>
<li><strong>%()</strong>
<ul>
<li>%()(c:Command)</li>
</ul></li>
<li><strong>*</strong>
<ul>
<li><p>*(a:Real, b:Real)</p></li>
<li><p>*(a:Int, b:Int)</p></li>
<li><p>*(arr:Arr, n:Int)</p></li>
<li><p>*(s:Str, n:Int)</p></li>
<li><p>*(cb:Fun, n:Int, *args:Arr)</p></li>
</ul></li>
<li><strong>+</strong>
<ul>
<li><p>+(a:Real, b:Real)</p></li>
<li><p>+(a:Arr, b:Arr)</p></li>
<li><p>+(a:Int, b:Int)</p></li>
<li><p>+(s1:Str, s2:Str)</p></li>
<li><p>+(a:Hash, b:Hash)</p></li>
<li><p>+(s:Str, a:Arr)</p>
<p><em>Description</em></p>
<p>Prepend each line in a with s</p></li>
<li><p>+(a:Arr, s:Str)</p>
<p><em>Description</em></p>
<p>Append s to each line in a</p></li>
</ul></li>
<li><strong>-</strong>
<ul>
<li><p>-(a:Real, b:Real)</p></li>
<li><p>-(a:Int, b:Int)</p></li>
<li><p>-(a:Arr, b:Arr)</p></li>
<li><p>-(s:Str, pfx:Pfx)</p></li>
<li><p>-(s:Str, sfx:Sfx)</p></li>
<li><p>-(s:Str, r:RegExp)</p>
<p><em>Description</em></p>
<p>Returns the string with the regexp cut out of it.</p></li>
</ul></li>
<li><strong>.</strong>
<ul>
<li><p>.(regexp:RegExp, attr:Str)</p></li>
<li><p>.(pa:c_pthread_attr_t, attr:Str)</p></li>
<li><p>.(obj:BasicType, attr:Str)</p></li>
<li><p>.(obj:NormalType, attr:Str)</p></li>
<li><p>.(obj:NormalTypeInstance, attr:Str)</p></li>
<li><p>.(h:Hash, attr:Str)</p></li>
<li><p>.(a:Arr, attr:Str)</p></li>
<li><p>.(p:Process, attr:Str)</p></li>
<li><p>.(p:Process, attr:Str)</p></li>
</ul></li>
<li><strong>..</strong>
<ul>
<li>..(start:Any, end:Any)</li>
</ul></li>
<li><strong>...</strong>
<ul>
<li>...(start:Any, end:Any)</li>
</ul></li>
<li><strong>.=</strong>
<ul>
<li><p>.=(obj:NormalTypeInstance, attr:Str, v:Any)</p></li>
<li><p>.=(h:Hash, attr:Str, v:Any)</p></li>
<li><p>.=(p:Process, attr:Str, v:Any)</p></li>
<li><p>.=(p:Process, attr:Str, v:Any)</p></li>
</ul></li>
<li><strong>/</strong>
<ul>
<li><p>/(a:Real, b:Real)</p></li>
<li><p>/(a:Int, b:Int)</p></li>
<li><p>/(x:Any, mapper:Fun)</p>
<p><em>Description</em></p>
<p>Map operator<br />
Syntax: / is on same key as ? and similar to |</p>
<p><em>Example</em></p>
<pre><code>[1,2,3,4] / F(x) x * 10</code></pre></li>
<li><p>/(a:Str, b:Str)</p></li>
<li><p>/(a:Path, b:Path)</p></li>
</ul></li>
<li><strong>//</strong>
<ul>
<li>//(regexp:Str, flags:Str)</li>
</ul></li>
<li><strong>&lt;</strong>
<ul>
<li><p>&lt;(a:Real, b:Real)</p></li>
<li><p>&lt;(a:Int, b:Int)</p></li>
</ul></li>
<li><strong>&lt;=</strong>
<ul>
<li><p>&lt;=(a:Real, b:Real)</p></li>
<li><p>&lt;=(a:Int, b:Int)</p></li>
<li><p>&lt;=(a:Str, b:Str)</p></li>
</ul></li>
<li><strong>==</strong>
<ul>
<li><p>==(a:Any, b:Any)</p></li>
<li><p>==(a:Type, b:Type)</p></li>
<li><p>==(a:Closure, b:Closure)</p></li>
<li><p>==(a:Real, b:Real)</p></li>
<li><p>==(a:Bool, b:Bool)</p></li>
<li><p>==(a:Str, b:Str)</p></li>
<li><p>==(a:Int, b:Int)</p></li>
<li><p>==(a:Null, b:Any)</p></li>
<li><p>==(a:Any, b:Null)</p></li>
<li><p>==(a:Null, b:Null)</p></li>
<li><p>==(a:Arr, b:Arr)</p></li>
<li><p>==(a:Hash, b:Hash)</p></li>
<li><p>==(a:IpPermBox, b:IpPermBox)</p></li>
</ul></li>
<li><strong>===</strong>
<ul>
<li>===(a:Any, b:Any)</li>
</ul></li>
<li><strong>&gt;</strong>
<ul>
<li><p>&gt;(a:Real, b:Real)</p></li>
<li><p>&gt;(a:Int, b:Int)</p></li>
</ul></li>
<li><strong>&gt;=</strong>
<ul>
<li><p>&gt;=(a:Real, b:Real)</p></li>
<li><p>&gt;=(a:Int, b:Int)</p></li>
</ul></li>
<li><strong>?</strong>
<ul>
<li><p>?(x:Any, predicate:Fun)</p>
<p><em>Description</em></p>
<p>Filter operator<br />
Syntax mnemonic: ? for predicate</p>
<p><em>Example</em></p>
<pre><code>[1,2,3,4] ? F(x) x &gt; 2</code></pre></li>
</ul></li>
<li>**<span class="citation">@*</span>*
<ul>
<li><p>@(hook:Hook, handler:Closure)</p></li>
<li><p>@(hd:HookDecorator, handler:Closure)</p></li>
<li><p>@(amd:ArgvMatcherDecorator, f:Closure)</p></li>
</ul></li>
<li><strong>[]</strong>
<ul>
<li><p>[](lib:CLib, symbol:Str)</p></li>
<li><p>[](arr:Arr, range:ExclusiveRange)</p></li>
<li><p>[](arr:Arr, idx:Int)</p></li>
<li><p>[](s:Str, range:ExclusiveRange)</p></li>
<li><p>[](h:Hash, k:Any)</p></li>
<li><p>[](hook:Hook, name:Str)</p></li>
<li><p>[](arr:Arr, idx:Int)</p></li>
<li><p>[](arr:Arr, indexes:Arr)</p></li>
<li><p>[](s:Str, i:Int)</p></li>
<li><p>[](s:Str, i:Int)</p></li>
<li><p>[](my:MatchY, idx:Int)</p></li>
<li><p>[](s:Str, r:RegExp)</p></li>
</ul></li>
<li><strong>[]=</strong>
<ul>
<li><p>[]=(arr:Arr, range:ExclusiveRange, replacement:Arr)</p></li>
<li><p>[]=(arr:Arr, idx:Int, v:Any)</p></li>
<li><p>[]=(s:Str, range:ExclusiveRange, replacement:Str)</p></li>
<li><p>[]=(h:Hash, k:Any, v:Any)</p></li>
<li><p>[]=(hook:Hook, name:Str, handler:Closure)</p></li>
</ul></li>
<li><strong>\</strong>
<ul>
<li><p>\(x:Any, f:Fun)</p>
<p><em>Description</em></p>
<p>Call operator</p>
<p><em>Example</em></p>
<pre><code>[1,2,3,4] \ echo</code></pre></li>
</ul></li>
<li><strong><code>``</code></strong>
<ul>
<li>``(c:Command)</li>
</ul></li>
<li><strong><code>````</code></strong>
<ul>
<li>````(c:Command)</li>
</ul></li>
<li><strong>acquire</strong>
<ul>
<li><p>acquire(l:Lock)</p></li>
<li><p>acquire(l:Lock, cb:Fun)</p></li>
</ul></li>
<li><strong>all</strong>
<ul>
<li><p>all(arr:Arr, predicate:Fun, *args:Arr)</p></li>
<li><p>all(h:Hash, predicate:Fun, *args:Arr)</p></li>
</ul></li>
<li><strong>any</strong>
<ul>
<li>any(arr:Arr, predicate:Fun, *args:Arr)</li>
</ul></li>
<li><strong>args</strong>
<ul>
<li>args()</li>
</ul></li>
<li><strong>ArgvMatcher</strong>
<ul>
<li>ArgvMatcher(option:Str, value:Any)</li>
</ul></li>
<li><strong>assert</strong>
<ul>
<li><p>assert(condition:Bool, msg:Str)</p></li>
<li><p>assert(condition:Bool)</p></li>
</ul></li>
<li><strong>attrs</strong>
<ul>
<li><p>attrs(m:NativeMethod)</p>
<p><em>Description</em></p>
<p>Gets native method attribues. Usually a Hash with name and doc keys.</p></li>
<li><p>attrs(m:NativeMethod, datum:Any)</p>
<p><em>Description</em></p>
<p>Sets native method attribues. Should be a Hash.</p></li>
<li><p>attrs(c:Closure)</p></li>
<li><p>attrs(c:Closure, datum:Any)</p></li>
<li><p>attrs(t:Type)</p></li>
<li><p>attrs(t:Type, datum:Any)</p></li>
</ul></li>
<li><strong>aws_regions</strong>
<ul>
<li><p>aws_regions()</p></li>
<li><p>aws_regions()</p></li>
<li><p>aws_regions(cb:Fun)</p></li>
</ul></li>
<li><strong>band</strong>
<ul>
<li>band(a:Int, b:Int)</li>
</ul></li>
<li><strong>basename</strong>
<ul>
<li>basename(s:Str)</li>
</ul></li>
<li><strong>bootstrap</strong>
<ul>
<li><p>bootstrap()</p>
<p><em>Description</em></p>
<p>Main entry point. Executed on NGS boot.</p></li>
</ul></li>
<li><strong>bootstrap_exception_catch_wrapper</strong>
<ul>
<li>bootstrap_exception_catch_wrapper()</li>
</ul></li>
<li><strong>bootstrap_find_ngs_dir</strong>
<ul>
<li><p>bootstrap_find_ngs_dir()</p></li>
<li><p>bootstrap_find_ngs_dir()</p></li>
</ul></li>
<li><strong>bor</strong>
<ul>
<li>bor(a:Int, b:Int)</li>
</ul></li>
<li><strong>bxor</strong>
<ul>
<li>bxor(a:Int, b:Int)</li>
</ul></li>
<li><strong>c_access</strong>
<ul>
<li>c_access(pathname:Str, mode:Int)</li>
</ul></li>
<li><strong>c_close</strong>
<ul>
<li>c_close(fd:Int)</li>
</ul></li>
<li><strong>c_dlopen</strong>
<ul>
<li>c_dlopen(filename:Str, flags:Int)</li>
</ul></li>
<li><strong>c_dup2</strong>
<ul>
<li><p>c_dup2(oldfd:Int, newfd:Int)</p></li>
<li><p>c_dup2(oldfd:Int, newfd:Int)</p></li>
</ul></li>
<li><strong>c_execve</strong>
<ul>
<li>c_execve(filename:Str, argv:Arr, envp:Arr)</li>
</ul></li>
<li><strong>c_exit</strong>
<ul>
<li>c_exit(status:Int)</li>
</ul></li>
<li><strong>c_ffi_call</strong>
<ul>
<li>c_ffi_call(cif:c_ffi_cif, fn:CSym, argv:Arr)</li>
</ul></li>
<li><strong>c_ffi_prep_cif</strong>
<ul>
<li>c_ffi_prep_cif(rtype:c_ffi_type, atypes:Arr)</li>
</ul></li>
<li><strong>c_fork</strong>
<ul>
<li>c_fork()</li>
</ul></li>
<li><strong>c_getpid</strong>
<ul>
<li>c_getpid()</li>
</ul></li>
<li><strong>c_isatty</strong>
<ul>
<li>c_isatty(fd:Int)</li>
</ul></li>
<li><strong>c_lseek</strong>
<ul>
<li><p>c_lseek(fd:Int, offset:Int, whence:Str)</p>
<p><em>Parameter</em> <strong>whence:Str</strong></p>
<p>One of: set, cur, end</p></li>
</ul></li>
<li><strong>c_open</strong>
<ul>
<li><p>c_open(pathname:Str, flags:Str)</p>
<p><em>Parameter</em> <strong>flags:Str</strong></p>
<p>r - O_RDONLY; w - O_WRONLY | O_CREAT | O_TRUNC; a - O_WRONLY | O_CREAT | O_APPEND</p></li>
</ul></li>
<li><strong>c_pcre_compile</strong>
<ul>
<li>c_pcre_compile(regexp:Str, flags:Int)</li>
</ul></li>
<li><strong>c_pcre_exec</strong>
<ul>
<li>c_pcre_exec(regexp:RegExp, subject:Str, offset:Int, options:Int)</li>
</ul></li>
<li><strong>c_pipe</strong>
<ul>
<li>c_pipe()</li>
</ul></li>
<li><strong>c_poll</strong>
<ul>
<li>c_poll(fds_evs:Arr, timeout:Int)</li>
</ul></li>
<li><strong>c_pthread_attr_init</strong>
<ul>
<li>c_pthread_attr_init(attr:c_pthread_attr_t)</li>
</ul></li>
<li><strong>c_pthread_create</strong>
<ul>
<li>c_pthread_create(attr:c_pthread_attr_t, start_routine:Closure, arg:Any)</li>
</ul></li>
<li><strong>c_pthread_join</strong>
<ul>
<li>c_pthread_join(thread:c_pthread_t)</li>
</ul></li>
<li><strong>c_pthread_mutex_init</strong>
<ul>
<li>c_pthread_mutex_init(mutex:c_pthread_mutex_t)</li>
</ul></li>
<li><strong>c_pthread_mutex_lock</strong>
<ul>
<li>c_pthread_mutex_lock(mutex:c_pthread_mutex_t)</li>
</ul></li>
<li><strong>c_pthread_mutex_unlock</strong>
<ul>
<li>c_pthread_mutex_unlock(mutex:c_pthread_mutex_t)</li>
</ul></li>
<li><strong>c_pthread_self</strong>
<ul>
<li>c_pthread_self()</li>
</ul></li>
<li><strong>c_read</strong>
<ul>
<li>c_read(fd:Int, count:Int)</li>
</ul></li>
<li><strong>c_strcasecmp</strong>
<ul>
<li>c_strcasecmp(a:Str, b:Str)</li>
</ul></li>
<li><strong>c_strcmp</strong>
<ul>
<li>c_strcmp(a:Str, b:Str)</li>
</ul></li>
<li><strong>c_waitpid</strong>
<ul>
<li>c_waitpid(pid:Int)</li>
</ul></li>
<li><strong>C_WEXITSTATUS</strong>
<ul>
<li>C_WEXITSTATUS(status:Int)</li>
</ul></li>
<li><strong>c_write</strong>
<ul>
<li>c_write(fd:Int, s:Str)</li>
</ul></li>
<li><strong>C_WTERMSIG</strong>
<ul>
<li>C_WTERMSIG(status:Int)</li>
</ul></li>
<li><strong>calculate_num_cols_to_show</strong>
<ul>
<li>calculate_num_cols_to_show(t:Table, max_colums_widths:Arr, available_cols:Int)</li>
</ul></li>
<li><strong>call</strong>
<ul>
<li><p>call(r:Return, v:Any=null)</p></li>
<li><p>call(hook:Hook, *args:Arr)</p></li>
</ul></li>
<li><strong>ceil</strong>
<ul>
<li>ceil(r:Real)</li>
</ul></li>
<li><strong>cell_display_width</strong>
<ul>
<li><p>cell_display_width(x:Any)</p>
<p><em>Description</em></p>
<p>Calculate cell display width - any Str()-able instance</p></li>
<li><p>cell_display_width(x:Arr)</p>
<p><em>Description</em></p>
<p>Calculate cell display width for an array</p></li>
<li><p>cell_display_width(x:Arr)</p>
<p><em>Description</em></p>
<p>Calculate cell display width for an empty array</p></li>
</ul></li>
<li><strong>child_fd</strong>
<ul>
<li><p>child_fd(p:Pipe)</p></li>
<li><p>child_fd(p:Pipe)</p></li>
</ul></li>
<li><strong>cleanup</strong>
<ul>
<li>cleanup(x:IpPermBox)</li>
</ul></li>
<li><strong>close</strong>
<ul>
<li>close(f:File)</li>
</ul></li>
<li><strong>close_reading_end</strong>
<ul>
<li>close_reading_end(p:Pipe)</li>
</ul></li>
<li><strong>close_writing_end</strong>
<ul>
<li>close_writing_end(p:Pipe)</li>
</ul></li>
<li><strong>cmp</strong>
<ul>
<li><p>cmp(a:Arr, b:Arr)</p></li>
<li><p>cmp(a:Hash, b:Hash)</p></li>
</ul></li>
<li><strong>code</strong>
<ul>
<li><p>code(a:Arr)</p></li>
<li><p>code(h:Hash)</p></li>
<li><p>code(n:Int)</p></li>
<li><p>code(s:Str)</p></li>
<li><p>code(n:Null)</p></li>
</ul></li>
<li><strong>collector</strong>
<ul>
<li><p>collector(a:Arr, code:Fun)</p></li>
<li><p>collector(h:Hash, code:Fun)</p></li>
<li><p>collector(n:Int, code:Fun)</p></li>
</ul></li>
<li><strong>column</strong>
<ul>
<li><p>column(t:Table, k:Str)</p></li>
<li><p>column(t:Table, n:Int)</p></li>
</ul></li>
<li><strong>columns</strong>
<ul>
<li>columns(t:Table)</li>
</ul></li>
<li><strong>compare</strong>
<ul>
<li><p>compare(a:Arr, b:Arr)</p>
<p><em>Description</em></p>
<p>Compare arrays without using Hash so that '==' is used for comparison<br />
and not internal '===' for Hash keys.</p></li>
</ul></li>
<li><strong>compile</strong>
<ul>
<li>compile(code:Str, fname:Str)</li>
</ul></li>
<li><strong>config</strong>
<ul>
<li><p>config(k:Str)</p></li>
<li><p>config(s:Str, x:Any)</p></li>
</ul></li>
<li><strong>converge</strong>
<ul>
<li>converge(r:ResDef)</li>
</ul></li>
<li><strong>copy</strong>
<ul>
<li><p>copy(arr:Arr)</p>
<p><em>Returns</em></p>
<p>Shallow copy of arr</p></li>
</ul></li>
<li><strong>count</strong>
<ul>
<li><p>count(arr:Arr, predicate:Fun, *args:Arr)</p></li>
<li><p>count(arr:Arr)</p></li>
<li><p>count(h:Hash, predicate:Fun, *args:Arr)</p></li>
</ul></li>
<li><strong>create</strong>
<ul>
<li><p>create(rd:AwsSecGroup)</p></li>
<li><p>create(rd:AwsInstance)</p></li>
<li><p>create(rd:AwsElb)</p></li>
<li><p>create(rd:AwsRecordSet)</p></li>
</ul></li>
<li><strong>debug</strong>
<ul>
<li>debug(s:Str)</li>
</ul></li>
<li><strong>decode_json</strong>
<ul>
<li>decode_json(s:Str)</li>
</ul></li>
<li><strong>del</strong>
<ul>
<li>del(h:Hash, k:Any)</li>
</ul></li>
<li><strong>delete</strong>
<ul>
<li>delete(elb:AwsElb)</li>
</ul></li>
<li><strong>dflt</strong>
<ul>
<li><p>dflt(i:NormalTypeInstance, k:Any, v:Any)</p></li>
<li><p>dflt(h:Hash, k:Any, v:Any)</p></li>
</ul></li>
<li><strong>die</strong>
<ul>
<li><p>die(a:Arr)</p></li>
<li><p>die(s:Str)</p></li>
</ul></li>
<li><strong>dump</strong>
<ul>
<li>dump(obj:Any)</li>
</ul></li>
<li><strong>dup2</strong>
<ul>
<li>dup2(oldfd:Int, newfd:Int)</li>
</ul></li>
<li><strong>dup2_reading_end</strong>
<ul>
<li>dup2_reading_end(p:Pipe, newfd:Int)</li>
</ul></li>
<li><strong>dup2_writing_end</strong>
<ul>
<li>dup2_writing_end(p:Pipe, newfd:Int)</li>
</ul></li>
<li><strong>each</strong>
<ul>
<li><p>each(r:Range, cb:Fun, *args:Arr)</p></li>
<li><p>each(arr:Arr, cb:Fun, *args:Arr)</p></li>
<li><p>each(arr:Arr, n:Int, cb:Fun, *args:Arr)</p>
<p><em>Description</em></p>
<p>Process each N elements of an Array at a time</p></li>
<li><p>each(h:Hash, cb:Fun, *args:Arr)</p></li>
<li><p>each(n:Int, cb:Fun, *args:Arr)</p></li>
<li><p>each(s:Str, cb:Fun, *args:Arr)</p></li>
<li><p>each(t:Table, cb:Fun, *args:Arr)</p></li>
</ul></li>
<li><strong>each_idx_key_val</strong>
<ul>
<li>each_idx_key_val(h:Hash, cb:Fun, *args:Arr)</li>
</ul></li>
<li><strong>each_idx_val</strong>
<ul>
<li>each_idx_val(arr:Arr, cb:Fun, *args:Arr)</li>
</ul></li>
<li><strong>echo</strong>
<ul>
<li><p>echo(s:Str)</p></li>
<li><p>echo(fd:Int, s:Str)</p></li>
<li><p>echo(x:Any)</p></li>
<li><p>echo(t:Table)</p>
<p><em>Description</em></p>
<p>Displays a table. Implemented only for tty output (or output_format=text configuration)</p></li>
</ul></li>
<li><strong>encode_json</strong>
<ul>
<li>encode_json(obj:Any)</li>
</ul></li>
<li><strong>ends_with</strong>
<ul>
<li>ends_with(haystack:Str, needle:Str)</li>
</ul></li>
<li><strong>error</strong>
<ul>
<li>error(s:Str)</li>
</ul></li>
<li><strong>exception_specific_message</strong>
<ul>
<li><p>exception_specific_message(e:Exception)</p></li>
<li><p>exception_specific_message(gnf:GlobalNotFound)</p></li>
</ul></li>
<li><strong>expect</strong>
<ul>
<li><p>expect(rd:ResDef, e:Int)</p></li>
<li><p>expect(rd:ResDef)</p></li>
</ul></li>
<li><strong>expose</strong>
<ul>
<li><p>expose(typ:NormalType, attr:Str)</p>
<p><em>Description</em></p>
<p>Exposes the given attribute so when ImplNotFound exception occurs and<br />
when the original call had instance of the given type as an argument<br />
the call is retried with the instance replaced by the given argument<br />
Currently only used in Stats type. Safe to ignore for beginners.</p>
<p><em>Parameter</em> <strong>typ:NormalType</strong></p>
<p>ImplNotFound with instance of this type will cause retry with the given attribute</p>
<p><em>Parameter</em> <strong>attr:Str</strong></p>
<p>The exposed attribute that will be used on call retry</p>
<p><em>Returns</em></p>
<p>typ</p>
<p><em>Example</em></p>
<pre><code>{
    type Stats
    Stats.expose(h)
}

F init(s:Stats) {
    s.h = {}
}

F Stats(a:Arr) {
    s = Stats()
    a.each(partial(push, s))
    s
}

F push(s:Stats, k) {
    s.h[k] = s.h.get(k, 0) + 1
    s
}

# Usage:
numbering = Stats()
numbering.push(hostname_base)
... numbering[hostname_base]} ...</code></pre></li>
</ul></li>
<li><strong>fetch</strong>
<ul>
<li><p>fetch(fname:Str)</p>
<p><em>Description</em></p>
<p>Fetches whole file</p>
<p><em>Parameter</em> <strong>fname:Str</strong></p>
<p>File name to fetch</p>
<p><em>Returns</em></p>
<p>Whole file as a string</p></li>
</ul></li>
<li><strong>filter</strong>
<ul>
<li><p>filter(something:Any, like:Any)</p></li>
<li><p>filter(something:Any, predicate:Fun, *args:Arr)</p></li>
<li><p>filter(something:Any)</p></li>
<li><p>filter(h:Hash, predicate:Fun, *args:Arr)</p></li>
</ul></li>
<li><strong>finally</strong>
<ul>
<li><p>finally(body:Fun, cleanup:Fun)</p>
<p><em>Description</em></p>
<p>EXPERIMENTAL</p></li>
</ul></li>
<li><strong>find</strong>
<ul>
<li><p>find(rd:AwsResDef)</p></li>
<li><p>find(rd:AwsSecGroup)</p></li>
<li><p>find(rd:AwsImage)</p></li>
<li><p>find(rd:AwsInstance)</p></li>
<li><p>find(rd:AwsElb)</p></li>
<li><p>find(rd:AwsRecordSet)</p></li>
</ul></li>
<li><strong>find_in_path</strong>
<ul>
<li>find_in_path(executable_name:Str)</li>
</ul></li>
<li><strong>finished_ok</strong>
<ul>
<li><p>finished_ok(p:Process)</p></li>
<li><p>finished_ok(p:Process)</p></li>
<li><p>finished_ok(p:Process)</p></li>
<li><p>finished_ok(p:Process)</p></li>
</ul></li>
<li><strong>first</strong>
<ul>
<li><p>first(r:Range, predicate:Fun, *args:Arr)</p></li>
<li><p>first(arr:Arr)</p></li>
<li><p>first(arr:Arr, predicate:Fun, *args:Arr)</p></li>
</ul></li>
<li><strong>flatten</strong>
<ul>
<li>flatten(arr:Arr)</li>
</ul></li>
<li><strong>floor</strong>
<ul>
<li>floor(r:Real)</li>
</ul></li>
<li><strong>get</strong>
<ul>
<li><p>get(arr:Arr, idx:Int, dflt:Any)</p></li>
<li><p>get(h:Hash, k:Any, dflt:Any)</p></li>
<li><p>get(h:Hash, k:Any)</p></li>
</ul></li>
<li><strong>get_c_errno</strong>
<ul>
<li>get_c_errno()</li>
</ul></li>
<li><strong>global_not_found_handler</strong>
<ul>
<li><p>global_not_found_handler(name:Str)</p>
<p><em>Description</em></p>
<p>Called when reading undefined global<br />
Implements autoloading</p></li>
</ul></li>
<li><strong>globals</strong>
<ul>
<li>globals()</li>
</ul></li>
<li><strong>group</strong>
<ul>
<li>group(a:Arr, cb:Fun, *args:Arr)</li>
</ul></li>
<li><strong>has</strong>
<ul>
<li>has(container:Any, element:Any)</li>
</ul></li>
<li><strong>hash</strong>
<ul>
<li>hash(x:Any)</li>
</ul></li>
<li><strong>Hashes</strong>
<ul>
<li>Hashes(t:Table)</li>
</ul></li>
<li><strong>hook</strong>
<ul>
<li>hook(h:Hook, *args:Arr)</li>
</ul></li>
<li><strong>id</strong>
<ul>
<li><p>id(thread:c_pthread_t)</p></li>
<li><p>id(sg:AwsSecGroupRes)</p></li>
<li><p>id(instance:AwsInstanceRes)</p></li>
</ul></li>
<li><strong>identity</strong>
<ul>
<li><p>identity(x:Any)</p>
<p><em>Returns</em></p>
<p>The given argument</p></li>
</ul></li>
<li><strong>ids</strong>
<ul>
<li><p>ids(r:Res)</p></li>
<li><p>ids(rd:AwsVpc)</p></li>
<li><p>ids(rd:AwsSecGroup)</p></li>
<li><p>ids(rd:AwsSubnet)</p></li>
<li><p>ids(rd:AwsImage)</p></li>
<li><p>ids(rd:AwsInstance)</p></li>
<li><p>ids(rd:AwsElb)</p></li>
</ul></li>
<li><strong>impl_not_found_handler</strong>
<ul>
<li><p>impl_not_found_handler(callable:Fun, *args:Arr)</p>
<p><em>Description</em></p>
<p>Called on ImplNotFound<br />
Implements expose() behaviour</p></li>
</ul></li>
<li><strong>in</strong>
<ul>
<li><p>in(symbol:Str, lib:CLib)</p></li>
<li><p>in(attr:Str, obj:NormalTypeInstance)</p></li>
<li><p>in(x:Any, h:Hash)</p></li>
<li><p>in(x:Any, arr:Arr)</p></li>
<li><p>in(needle:Str, haystack:Str)</p></li>
</ul></li>
<li><strong>index</strong>
<ul>
<li>index(arr:Arr, predicate:Fun, *args:Arr)</li>
</ul></li>
<li><strong>indexes</strong>
<ul>
<li>indexes(arr:Arr, predicate:Fun, *args:Arr)</li>
</ul></li>
<li><strong>inherit</strong>
<ul>
<li>inherit(t:NormalType, parent:NormalType)</li>
</ul></li>
<li><strong>init</strong>
<ul>
<li><p>init(e:Exception, message:Str)</p>
<p><em>Parameter</em> <strong>message:Str</strong></p>
<p>Goes into .message</p>
<p><em>Returns</em></p>
<p>Exception with .backtrace and .message</p></li>
<li><p>init(e:Exception, cause:Exception)</p>
<p><em>Returns</em></p>
<p>Exception with .backtrace and .cause</p></li>
<li><p>init(h:Hash)</p>
<p><em>Description</em></p>
<p>Trivial initialization helper for init(o, ...)<br />
Sets object fields from the supplied parameters</p>
<p><em>Example</em></p>
<pre><code># sets t.a and t.b
F init(t:MyType, a, b) init(args())</code></pre></li>
<li><p>init(e:IndexNotFound, message:Str, container:Any, key:Any)</p></li>
<li><p>init(hook:Hook, combiner:Any=[<Native method values\>])</p></li>
<li><p>init(hd:HookDecorator, hook:Hook)</p></li>
<li><p>init(hd:HookDecorator, hook:Hook, name:Str)</p></li>
<li><p>init(r:Range, start:Any, end:Any)</p></li>
<li><p>init(b:FullBox, *args:Arr)</p></li>
<li><p>init(b:FullBox, val:Any)</p></li>
<li><p>init(e:LockFail, op:Str, code:Int, msg:Str)</p></li>
<li><p>init(l:Lock)</p></li>
<li><p>init(pipe:Pipe)</p></li>
<li><p>init(pipe:Pipe, direction:Int)</p></li>
<li><p>init(fail:FileIOFail, name:Str, errno:Int, message:Str)</p></li>
<li><p>init(f:File, name:Str)</p></li>
<li><p>init(f:File, fd:Int)</p></li>
<li><p>init(p:Process, c:Command)</p></li>
<li><p>init(my:MatchY, matches:Arr)</p></li>
<li><p>init(mf:MatchFail, msg:Str, container:Any, pattern:Any)</p></li>
<li><p>init(s:SubSeq, val:Any)</p></li>
<li><p>init(a:Props, **kw:Hash)</p></li>
<li><p>init(a:AwsAncor, **kw:Hash)</p></li>
<li><p>init(c:AwsResFindCommand, cmd:Arr, supports_filters:Bool)</p></li>
<li><p>init(rnf:ResNotFound, rd:ResDef)</p></li>
<li><p>init(rd:ResDef, ancor:Any, props:Hash)</p></li>
<li><p>init(rd:ResDef, ancor:Any)</p></li>
<li><p>init(r:Res, def:ResDef, props:Hash)</p></li>
<li><p>init(amd:ArgvMatcherDecorator, option:Str, value:Any)</p></li>
<li><p>init(c:Counter)</p></li>
<li><p>init(i:ArrIter, arr:Arr)</p></li>
<li><p>init(i:HashIter, h:Hash)</p></li>
<li><p>init(kv:KV, k:Any, v:Any)</p></li>
<li><p>init(s:Stats)</p></li>
<li><p>init(x:TableMetaNotIfCol, col_name:Str, data:Any)</p></li>
<li><p>init(x:TableMetaNotIfCol, col_names:Arr, data:Any)</p></li>
<li><p>init(t:Table)</p>
<p><em>Description</em></p>
<p>Initialize rows to an empty array</p></li>
<li><p>init(t:Table, name:Str, rows_hashes:Arr)</p>
<p><em>Description</em></p>
<p>Create named table containing provided rows</p>
<p><em>Parameter</em> <strong>name:Str</strong></p>
<p>name of the table for display and for configuration purposes</p>
<p><em>Parameter</em> <strong>rows_hashes:Arr</strong></p>
<p>rows, each row is a Hash</p></li>
<li><p>init(t:Table, rows_hashes:Arr)</p></li>
<li><p>init(t:Thread, f:Fun, arg:Any)</p></li>
<li><p>init(t:Thread, f:Fun)</p></li>
</ul></li>
<li><strong>inspect</strong>
<ul>
<li><p>inspect(val:Any)</p></li>
<li><p>inspect(r:Real)</p></li>
<li><p>inspect(i:Int)</p></li>
<li><p>inspect(s:Str)</p></li>
<li><p>inspect(a:Arr)</p></li>
<li><p>inspect(h:Hash)</p></li>
<li><p>inspect(p:Process)</p></li>
</ul></li>
<li><strong>ip</strong>
<ul>
<li>ip(c:Closure)</li>
</ul></li>
<li><strong>is</strong>
<ul>
<li>is(obj:Any, t:Type)</li>
</ul></li>
<li><strong>is not</strong>
<ul>
<li>is not(a:Any, b:Any)</li>
</ul></li>
<li><strong>isatty</strong>
<ul>
<li>isatty(fd:Int)</li>
</ul></li>
<li><strong>join</strong>
<ul>
<li><p>join(arr:Arr, s:Str)</p></li>
<li><p>join(a:Arr, s:Str)</p></li>
<li><p>join(threads:Arr)</p></li>
<li><p>join(t:Thread)</p></li>
</ul></li>
<li><strong>keys</strong>
<ul>
<li>keys(h:Hash)</li>
</ul></li>
<li><strong>latest</strong>
<ul>
<li>latest(rd:AwsImage)</li>
</ul></li>
<li><strong>len</strong>
<ul>
<li><p>len(arr:Arr)</p></li>
<li><p>len(s:Str)</p>
<p><em>Returns</em></p>
<p>Length in bytes</p></li>
<li><p>len(h:Hash)</p></li>
<li><p>len(rd:ResDef)</p></li>
<li><p>len(rd:ResDef)</p></li>
<li><p>len(t:Table)</p></li>
</ul></li>
<li><strong>limit</strong>
<ul>
<li><p>limit(a:Arr, l:Int)</p></li>
<li><p>limit(h:Hash, l:Int)</p></li>
<li><p>limit(s:Str, n:Int, marker:Str=)</p></li>
</ul></li>
<li><strong>lines</strong>
<ul>
<li><p>lines(s:Str)</p></li>
<li><p>lines(a:Str, cb:Fun, *args:Arr)</p></li>
<li><p>lines(f:File, cb:Fun, *args:Arr)</p></li>
<li><p>lines(p:Process)</p></li>
<li><p>lines(p:Process, cb:Fun, *args:Arr)</p></li>
</ul></li>
<li><strong>load</strong>
<ul>
<li>load(bytecode:Str, func_name:Str)</li>
</ul></li>
<li><strong>log</strong>
<ul>
<li><p>log(s:Str)</p></li>
<li><p>log(rd:ResDef, method:Str, s:Str)</p></li>
</ul></li>
<li><strong>lte</strong>
<ul>
<li><p>lte(a:Str, b:Str)</p>
<p><em>Description</em></p>
<p>Case-insensitive LessThan or Equal comparison for strings</p></li>
</ul></li>
<li><strong>map</strong>
<ul>
<li><p>map(something:Any, mapper:Fun, *args:Arr)</p></li>
<li><p>map(arr:Arr, n:Int, cb:Fun, *args:Arr)</p>
<p><em>Description</em></p>
<p>Map each N elements of an Array at a time</p></li>
<li><p>map(h:Hash, mapper:Fun, *args:Arr)</p></li>
</ul></li>
<li><strong>map_idx_val</strong>
<ul>
<li>map_idx_val(arr:Arr, cb:Fun, *args:Arr)</li>
</ul></li>
<li><strong>mapk</strong>
<ul>
<li>mapk(h:Hash, mapper:Fun, *args:Arr)</li>
</ul></li>
<li><strong>mapkv</strong>
<ul>
<li>mapkv(h:Hash, mapper:Fun, *args:Arr)</li>
</ul></li>
<li><strong>mapv</strong>
<ul>
<li>mapv(h:Hash, mapper:Fun, *args:Arr)</li>
</ul></li>
<li><strong>max</strong>
<ul>
<li><p>max(arr:Arr)</p></li>
<li><p>max(arr:Arr, cb:Fun)</p></li>
</ul></li>
<li><strong>merge_sorted</strong>
<ul>
<li>merge_sorted(a:Arr, b:Arr, lte:Fun)</li>
</ul></li>
<li><strong>min</strong>
<ul>
<li><p>min(arr:Arr)</p></li>
<li><p>min(arr:Arr, cb:Fun)</p></li>
</ul></li>
<li><strong>n</strong>
<ul>
<li>n(h:Hash)</li>
</ul></li>
<li><strong>next</strong>
<ul>
<li><p>next(c:Counter)</p></li>
<li><p>next(i:ArrIter)</p></li>
<li><p>next(i:HashIter)</p></li>
</ul></li>
<li><strong>none</strong>
<ul>
<li>none(arr:Arr, predicate:Fun, *args:Arr)</li>
</ul></li>
<li><strong>not</strong>
<ul>
<li><p>not(x:Bool)</p></li>
<li><p>not(x:Any)</p></li>
</ul></li>
<li><strong>not in</strong>
<ul>
<li>not in(a:Any, b:Any)</li>
</ul></li>
<li><strong>nuke_null</strong>
<ul>
<li><p>nuke_null(a:Arr)</p>
<p><em>Description</em></p>
<p>Used for command line arguments such as ['--vpc-id', my_vpc_id()].nuke_null()<br />
If my_vpc_id() is null the whole array is not needed</p></li>
</ul></li>
<li><strong>open</strong>
<ul>
<li>open(f:File, flags:Str)</li>
</ul></li>
<li><strong>ord</strong>
<ul>
<li><p>ord(s:Str, idx:Int)</p></li>
<li><p>ord(s:Str)</p></li>
</ul></li>
<li><strong>params</strong>
<ul>
<li><p>params(m:NativeMethod)</p></li>
<li><p>params(c:Closure)</p></li>
</ul></li>
<li><strong>parent_fd</strong>
<ul>
<li><p>parent_fd(p:Pipe)</p></li>
<li><p>parent_fd(p:Pipe)</p></li>
</ul></li>
<li><strong>parse</strong>
<ul>
<li><p>parse(s:Str)</p></li>
<li><p>parse(s:Str, hints:Hash)</p></li>
<li><p>parse(s:Str, hints:Hash)</p></li>
<li><p>parse(s:Str, hints:Hash)</p></li>
</ul></li>
<li><strong>partial</strong>
<ul>
<li><p>partial(f:Fun, *bind_args:Arr)</p>
<p><em>Description</em></p>
<p>Returns partially-applied function</p>
<p><em>Parameter</em> <strong>f:Fun</strong></p>
<p>The base function</p></li>
</ul></li>
<li><strong>partial_tail</strong>
<ul>
<li><p>partial_tail(f:Fun, *bind_args:Arr)</p>
<p><em>Description</em></p>
<p>Same as partial() but the bound arguments are last ones</p></li>
</ul></li>
<li><strong>peek</strong>
<ul>
<li><p>peek(i:ArrIter)</p></li>
<li><p>peek(i:HashIter)</p></li>
</ul></li>
<li><strong>pmap</strong>
<ul>
<li><p>pmap(a:Arr, mapper:Fun)</p></li>
<li><p>pmap(n:Int, mapper:Fun)</p></li>
</ul></li>
<li><strong>pop</strong>
<ul>
<li>pop(arr:Arr)</li>
</ul></li>
<li><strong>pos</strong>
<ul>
<li><p>pos(haystack:Str, needle:Str, start:Int)</p></li>
<li><p>pos(haystack:Str, needle:Str)</p></li>
</ul></li>
<li><strong>preprocess</strong>
<ul>
<li><p>preprocess(t:Table)</p>
<p><em>Description</em></p>
<p>Preprocess a Table just before output</p></li>
</ul></li>
<li><strong>print_exception</strong>
<ul>
<li>print_exception(e:Exception, level:Int=0, parent:Exception=null)</li>
</ul></li>
<li><strong>ptimes</strong>
<ul>
<li>ptimes(n:Int, cb:Fun)</li>
</ul></li>
<li><strong>push</strong>
<ul>
<li><p>push(arr:Arr, v:Any)</p></li>
<li><p>push(hook:Hook, handler:Closure)</p></li>
<li><p>push(s:Stats, k:Any)</p>
<p><em>Description</em></p>
<p>Increment the named counter</p></li>
<li><p>push(t:Table, row_arr:Arr)</p></li>
<li><p>push(t:Table, row_hash:Hash)</p></li>
</ul></li>
<li><strong>read</strong>
<ul>
<li><p>read(fd:Int)</p>
<p><em>Description</em></p>
<p>Read all data</p>
<p><em>Parameter</em> <strong>fd:Int</strong></p>
<p>file descriptor to read from</p></li>
<li><p>read(p:Pipe)</p></li>
</ul></li>
<li><strong>reduce</strong>
<ul>
<li>reduce(something:Any, start:Any, f:Fun, *args:Arr)</li>
</ul></li>
<li><strong>release</strong>
<ul>
<li>release(l:Lock)</li>
</ul></li>
<li><strong>replace</strong>
<ul>
<li>replace(dst:Any, src:Any)</li>
</ul></li>
<li><strong>require</strong>
<ul>
<li><p>require(fname:Str)</p>
<p><em>Description</em></p>
<p>Runs the given file</p>
<p><em>Returns</em></p>
<p>Typically whatever the last expression in the file evaluates to</p></li>
</ul></li>
<li><strong>resolve_instruction_pointer</strong>
<ul>
<li><p>resolve_instruction_pointer(ip:Int)</p>
<p><em>Description</em></p>
<p>Resolves Instruction Pointer to source location</p>
<p><em>Returns</em></p>
<p>Hash with keys: file, first_line, first_column, last_line, last_column, ip</p></li>
</ul></li>
<li><strong>reverse</strong>
<ul>
<li>reverse(arr:Arr)</li>
</ul></li>
<li><strong>round</strong>
<ul>
<li>round(r:Real)</li>
</ul></li>
<li><strong>run</strong>
<ul>
<li><p>run(r:AwsRes, log_pfx:Str, cmd:Command)</p></li>
<li><p>run(rd:AwsResDef, log_pfx:Str, cmd:Command)</p></li>
</ul></li>
<li><strong>SafeStr</strong>
<ul>
<li><p>SafeStr(val:Any)</p>
<p><em>Description</em></p>
<p>Don't use, subject to change, including name</p></li>
</ul></li>
<li><strong>set</strong>
<ul>
<li>set(obj:Any, attr:Str, val:Any)</li>
</ul></li>
<li><strong>shift</strong>
<ul>
<li><p>shift(arr:Arr)</p></li>
<li><p>shift(arr:Arr, dflt:Any)</p></li>
</ul></li>
<li><strong>should_display_cell_item</strong>
<ul>
<li><p>should_display_cell_item(t:Table, item:Any)</p></li>
<li><p>should_display_cell_item(t:Table, item:TableMetaNotIfCol)</p></li>
</ul></li>
<li><strong>sort</strong>
<ul>
<li><p>sort(a:Arr)</p></li>
<li><p>sort(a:Arr, lte:Fun)</p></li>
<li><p>sort(a:Arr, attr:Str)</p></li>
</ul></li>
<li><strong>split</strong>
<ul>
<li><p>split(a:Arr, delim:Any)</p></li>
<li><p>split(s:Str, delim:Str)</p></li>
<li><p>split(s:Str, r:RegExp)</p></li>
</ul></li>
<li><strong>starts_with</strong>
<ul>
<li>starts_with(haystack:Str, needle:Str)</li>
</ul></li>
<li><strong>status</strong>
<ul>
<li>status(s:Str)</li>
</ul></li>
<li><strong>stdlib_aws_filters</strong>
<ul>
<li>stdlib_aws_filters(h:Hash)</li>
</ul></li>
<li><strong>stdlib_aws_instance_ancor</strong>
<ul>
<li>stdlib_aws_instance_ancor(rd:AwsInstance)</li>
</ul></li>
<li><strong>stdlib_aws_straighten_tags</strong>
<ul>
<li><p>stdlib_aws_straighten_tags(a:Arr)</p></li>
<li><p>stdlib_aws_straighten_tags(h:Hash)</p></li>
<li><p>stdlib_aws_straighten_tags(s:Str)</p></li>
</ul></li>
<li><strong>stdlib_aws_tags</strong>
<ul>
<li>stdlib_aws_tags(h:Hash)</li>
</ul></li>
<li><strong>StrForTable</strong>
<ul>
<li><p>StrForTable(x:Any)</p></li>
<li><p>StrForTable(x:Any, width:Int)</p></li>
<li><p>StrForTable(x:Null)</p></li>
<li><p>StrForTable(x:Null, width:Int)</p></li>
</ul></li>
<li><strong>Strs</strong>
<ul>
<li>Strs(h:Hash)</li>
</ul></li>
<li><strong>sum</strong>
<ul>
<li>sum(arr:Arr)</li>
</ul></li>
<li><strong>throw_if_no_next</strong>
<ul>
<li>throw_if_no_next(i:Iter)</li>
</ul></li>
<li><strong>time</strong>
<ul>
<li>time()</li>
</ul></li>
<li><strong>times</strong>
<ul>
<li>times(n:Int, cb:Fun, *args:Arr)</li>
</ul></li>
<li><strong>to_exit_code</strong>
<ul>
<li><p>to_exit_code(x:Any)</p>
<p><em>Returns</em></p>
<p>always 0</p></li>
<li><p>to_exit_code(b:Bool)</p>
<p><em>Returns</em></p>
<p>0 for true, 1 for false</p></li>
<li><p>to_exit_code(n:Int)</p>
<p><em>Returns</em></p>
<p>n</p></li>
<li><p>to_exit_code(e:Exception)</p>
<p><em>Returns</em></p>
<p>Always 200</p></li>
<li><p>to_exit_code(b:Box)</p></li>
<li><p>to_exit_code(p:Process)</p></li>
<li><p>to_exit_code(m:Match)</p></li>
</ul></li>
<li><strong>trunc</strong>
<ul>
<li>trunc(r:Real)</li>
</ul></li>
<li><strong>typeof</strong>
<ul>
<li><p>typeof(x:Any)</p>
<p><em>Description</em></p>
<p>Returns type of the given instance</p>
<p><em>Parameter</em> <strong>x:Any</strong></p>
<p>Instance (an object)</p></li>
</ul></li>
<li><strong>uniq</strong>
<ul>
<li>uniq(arr:Arr)</li>
</ul></li>
<li><strong>unshift</strong>
<ul>
<li>unshift(arr:Arr, elt:Any)</li>
</ul></li>
<li><strong>update</strong>
<ul>
<li><p>update(dst:Hash, src:Hash)</p></li>
<li><p>update(sg:AwsSecGroupRes)</p></li>
<li><p>update(instance:AwsInstanceRes)</p></li>
<li><p>update(elb:AwsElbRes)</p></li>
<li><p>update(rrset:AwsRecordSetRes)</p></li>
</ul></li>
<li><strong>update_tags</strong>
<ul>
<li>update_tags(r:AwsRes)</li>
</ul></li>
<li><strong>users_ids</strong>
<ul>
<li>users_ids(r:AwsSecGroup)</li>
</ul></li>
<li><strong>validate</strong>
<ul>
<li><p>validate(rd:AwsSecGroup)</p></li>
<li><p>validate(rd:AwsInstance)</p></li>
<li><p>validate(rd:AwsElb)</p></li>
<li><p>validate(rd:AwsRecordSet)</p></li>
</ul></li>
<li><strong>values</strong>
<ul>
<li>values(h:Hash)</li>
</ul></li>
<li><strong>vpc_id</strong>
<ul>
<li><p>vpc_id(rd:AwsSecGroup)</p></li>
<li><p>vpc_id(rd:AwsSecGroup)</p></li>
</ul></li>
<li><strong>vpc_id_args</strong>
<ul>
<li><p>vpc_id_args(rd:AwsSecGroup)</p></li>
<li><p>vpc_id_args(rd:AwsSecGroup)</p></li>
</ul></li>
<li><strong>vpc_id_filter</strong>
<ul>
<li><p>vpc_id_filter(rd:AwsSecGroup)</p></li>
<li><p>vpc_id_filter(rd:AwsSecGroup)</p></li>
</ul></li>
<li><strong>wait</strong>
<ul>
<li>wait(p:Process)</li>
</ul></li>
<li><strong>width</strong>
<ul>
<li>width(t:Table)</li>
</ul></li>
<li><strong>without</strong>
<ul>
<li><p>without(arr:Arr, without_elt:Any)</p></li>
<li><p>without(h:Hash, without_k:Any)</p></li>
<li><p>without(h:Hash, without_k:Any, without_v:Any)</p></li>
<li><p>without(s:Str, r:RegExp)</p></li>
</ul></li>
<li><strong>write</strong>
<ul>
<li><p>write(fd:Int, s:Str)</p></li>
<li><p>write(p:Pipe, s:Str)</p></li>
</ul></li>
<li><strong>zip</strong>
<ul>
<li>zip(*args:Arr)</li>
</ul></li>
<li><strong>~</strong>
<ul>
<li><p>~(a:Str, b:Str)</p></li>
<li><p>~(s:Str, pfx:Pfx)</p></li>
<li><p>~(s:Str, sfx:Sfx)</p></li>
<li><p>~(s:Str, r:RegExp, offset:Int=0, options:Int=0)</p></li>
<li><p>~(argv:Arr, c:Closure)</p></li>
</ul></li>
<li><strong>~~</strong>
<ul>
<li>~~(s:Str, r:RegExp)</li>
</ul></li>
</ul>
</body>
</html>
