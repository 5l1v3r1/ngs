# ********** Used for Lisp rewrire **********

# ----- Lang -----

defg 'is not'(o, t:Type) { not(o is t) }

defg '+'(s1:Seq, s2:Seq)  {
	 guard s1 is not String
	 [*s1, *s2]
}

defg repr(x) { String(x) }
defg 'not in'(*args) { not(in(*args)) }

defg has(container, item) {item in container}
defg has_no(container, item) {item not in container}

defg '|'(*args) { map(*args) }

typeg Command

# ----- Type system sugar - start -----

defg String(t:Type) { "<Type ${t.name}>" }

defg Type(name:String, *parents) {
	guard parents
	ret = Type(name)
	parents.each(@ ret.inherits(X))
	ret
}


# ----- Type system sugar - end -----


# ----- Loading code - start -----

# Should be defined for files fetched from remote locations, maybe
# in some other cases too.
defg validate_source_file(f:String, content:String) { true }

# TODO: path to search in
# TODO: specify version of the required file/module
defg require(f:String, *args) {
	content = File(f).fetch()
	not(validate_source_file(f, content)) throws ['runtime', "Failed to validate source file $f"]
	code = compile(content, f)
	lambda_ = load(code)
	lambda_(*args)
}

# ----- Loading code - end -----


# later # # ----- Process() sugar - start -----

defg Bool(c:Command) {
	($()).call(c)
	p = c.process
	# echo("Bool: [command: $c] [process: ${p is Process}]")
	p.finish()
	p.status == 'exited' and p.code == 0
}

defg finish(p:Process) {
	p.wait()
	ok = cmd_finished_ok_p(p)
	not(ok) throws ['runtime', 'Command execution failed: ' + String(p.argv)]
	p
}

# later # # XXX: Warning: should be per Context or it will bite you
# later # defg spawn_update_globals(args:Array, p:Process) {
# later # 	g = globals()
# later # 	g['P'] = p
# later # 	if 'PP' not in g {
# later # 		g['PP'] = {}
# later # 	}
# later # 	g['PP'][args[0]] = p
# later # 
# later # 	# Hack for CLI
# later # 	thread().locals()['P'] = p
# later # }
# later # 

defg Command(*args) {
	guard args
	c = Command()
	c.argv = args | String
	c.process = null
	c.stdout = null
	c.stderr = null
	c
}

defg '$()'(c:Command) {
	if c.process is Null {
		c.process = Process(*c.argv)
	}
	# later # spawn_update_globals(args, p)
	c
}

defg finish(c:Command) { c.process.finish(); c }

# Convert execution of (example) '-f somefile' to 'test -f somefile'
defg Command(*args) {
	  guard args.len() > 1
	  guard args[0].startsWith('-')
	  Command(*['test'] + args)
}


defg cmd_finished_ok_p(p:Process) { p.code == 0 }

defg cmd_finished_ok_p(p:Process) {
	guard p.argv[0] == 'test'
	p.code in [0,1]
}

defg cmd_finished_ok_p(p:Process) {
	guard p.argv[0] == 'false'
	p.code == 1
}

defg cmd_finished_ok_p(p:Process) {
	guard p.argv[0] == 'service'
	guard p.argv[1] == 'status'
	# Empirical
	p.code < 4
}

# ----- Process() sugar - end -----


# ----- Meta sugar - start -----
defg meta(x, k:String) {
	x.meta()[k]
}

defg meta_dflt(x, k:String, v) { x.meta().get(k, v) }

defg meta(x, k:String, v) {
	x.meta()[k] = v
	x
}

defg has_meta(x, k:String) {
	k in x.meta()
}
# ----- Meta sugar - end -----




# ----- Null - start -----
defg String(n:Null)   { 'null' }
# ----- Null - end -----

# ----- Bool - start -----

defg not(x) { if x {false}{true} }

defg __neq(a, b) { not(a==b) }

# Type transformations
defg String(b:Bool) { if b {'true'}{'false'} }
defg Number(b:Bool) { if b {1}{0} }

# ----- Bool - end -----

# ----- Number - start -----

# later #
defg Number(s:String) {
	# TODO: checks, negatives, floats, base
	ord_zero = ord('0')
	ret = 0
	s.each(F(ch) { ret = ret * 10 + ord(ch) - ord_zero })
	ret
}

defg min(a:Number, b:Number) { if a<b {a}{b} }
defg max(a:Number, b:Number) { if a<b {b}{a} }

# later #
defg max(s:Seq) {
	guard s.len() > 0
	s.reduce(s[0], max)
}

# Functional

defg each(n:Number, processor:F, *args) {
	for(i=0;i<n;i=i+1) {
		processor(i, *args)
	}
}

# TODO: Consider performance penalty for working with Lists here
defg map(n:Number, mapper:F, *args) {
	ret = []
	for(i=0;i<n;i=i+1) {
		ret.push(mapper(i, *args))
	}
	ret
}

# ----- Number - end -----


# ----- Files sugar - start -----

# later #
global __literal_f = File

defg '~'(f:File, r:Regexp) { f.String() ~ r }

# Reading
defg unserialize(f:File, content:String) { content }

defg unserialize(f:File, content:String) {
	guard f ~ /\\.json$/
	try {
		from_json(content)
	} catch(e) {
		throw ['runtime', "Failed to read json file ${f}"]
	}
}

defg read(f:File) {
	content = f.fetch()
	unserialize(f, content).meta('file', f)
}

defg read(f:String) { File(f).read() }

# Writing

defg store(f:String, content) { File(f).store(content) }

defg serialize(f:File, content) { String(content) }

defg write(f:File, content) {
	s = serialize(f, content)
	f.store(s)
}

defg write(content) { write(content.meta('file'), content) }
defg write(f:String, content) { File(f).write(content) }

defg lines(f:File) { f.read().lines() }

defg read_till(s:Stream, tillChar:String, max:Number=1024) {
	ret = ''
	while (ch = s.read_char()) != tillChar {
		ret = ret + ch
		ret.len() > max throws ['runtime', 'read_till epic fail']
		# echo("<CH thread=${thread().id} ord=${ch.ord()} ch=$ch ret=$ret>")
	}
	# echo("<READ_TILL thread=${thread().id} till=$tillChar ch=$ch ret=$ret>")
	ret
}

# Anything else will break $(ls $f) and probably other stuff
defg String(f:File) { f.name }

# later # defg Bool(p:Path) { $(-e $p).Bool() }

defg Bool(f:File) { $(-f $f).Bool() }
defg repr(f:File) { "File(${f.name.repr()})" }

# UNTESTED
defg dirs() {
	`find -maxdepth 1 -type d`.lines() @ slice(X,2,X.len()-2)
}

# ----- Files sugar - end -----


# later # # ----- Thread - start -----
# later # 
# later # defg thread(f:Array) { thread(f.one()) }
# later # 
# later # defg String(t:Thread) { "<Thread id=${t.id} state=${t.state}>" }
# later # 
# later # defg __eq(a:Thread, b:Thread) { a.id == b.id }
# later # 
# later # # ----- Thread - end -----

# ----- Process - start -----

# later # defg repr(p:Process) { "<Process pid=${p.pid} code=${p.code} id=${p.id} o=${p.stdout.len()} e=${p.stderr.len()}>" }

# ----- Process - end -----


# later # # ----- Lock sugar - start -----
# later # defg acquire(l:Lock, f:F, *args) {
# later # 	# TODO: maybe catch and rethrow after release()
# later # 	l.acquire()
# later # 	ret = f(*args)
# later # 	l.release()
# later # 	ret
# later # }
# later # # ----- Lock sugar - end -----



# ----- Seq - start -----

defg split(s:Seq, delim:Seq) {
	sl = s.len()
	dl = delim.len()
	ret = []
	start = 0
	while (i=s.pos(delim, start)) != null {
		ret.push(s.slice(start, i-start))
		start = i + dl
	}
	if start<sl {
		ret.push(s.slice(start, sl-start))
	}
	ret
}


defg zip(a:Seq, b:Seq) {
	l = len(a)
	l != b.len() throws ['args', 'Zip with different Seqs length']
	l@[a[X], b[X]]
}

defg flatten(s:Seq) {
	ret = []
	s.each(@X.each(@ret.push(X)))
	ret
}

defg chunk(s:Seq, n:Number, cb:F, *args) {
	# TODO: check why % has no higher precedence
	(s.len() % n) != 0 throws ['data', 'Chunk got invalid sequence length']
	for(i=0;i<s.len()/n;i=i+1) {
		cb(slice(s, i*n, n), *args)
	}
}

defg chunk(s:Seq, n:Number) {
	ret = []
	chunk(s, n, @ret.push(X))
	ret
}

# UNTESTED - start
defg first(s:Seq)  { s[0] }
defg second(s:Seq) { s[1] }
defg third(s:Seq)  { s[2] }
defg fourth(s:Seq) { s[3] }
defg fifth(s:Seq)  { s[4] }
# UNTESTED - end

defg last(s:Seq)   { s[-1] }


# Abstract usage example:
# servers.filter(F(x) {'unicorn' in x.tags}).one('Unicorn server').create_image('Unicorn backup')
defg one(s:Seq, msg:String='item') {
	# echo("SEQ: ${s.len()}")
	s.len() != 1 throws ['data', "Expected array with exactly one $msg but had ${s.len()}", s]
	s[0]
}

defg join(s:Seq, sep:String) {
	ret = ''
	j = s.len()
	for(i=0;i<j;i=i+1) {
		ret = ret + String(s[i])
		if i < j - 1 {
			ret = ret + sep
		}
	}
	ret
}

defg join(s:Seq) { join(s, '') }

# Predicates

defg '=='(s1:Seq, s2:Seq) {
	guard s1 is not String
	guard s2 is not String
	sl = s1.len()
	sl != s2.len() returns false
	for(i=0; i<sl; i=i+1) {
		s1[i] != s2[i] returns false
	}
	true
}

defg startsWith(s:Seq, pfx:Seq) {
	not(len(s) < len(pfx))
	and
	s.slice(0, pfx.len()) == pfx
}

defg endsWith(s:Seq, sfx:Seq) {
	l = sfx.len()
	len(s) < l returns false
	s.slice(s.len() - l, l) == sfx
}

# Functional

defg each(s:Seq, processor:F, *args) {
	j = s.len()
	for(i=0;i<j;i=i+1) {
		processor(s[i], *args)
	}
	s
}

defg each_star(s:Seq, processor:F, *args) { s.each(@processor(*X+args)) }

defg map(s:Seq, mapper:F, *args) { s.len() @ mapper(s[X], *args) }

defg map_star(s:Seq, mapper:F, *args) { s.len() @ mapper(*s[X] + args) }

defg reduce(s:Seq, start, reducer:F) {
	acc = start
	s.each(F(x) { acc = reducer(acc, x) })
	acc
}

defg any(s:Seq, predicate:F, *args) {
	j = s.len()
	for(i=0;i<j;i=i+1) {
		predicate(s[i], *args) returns true
	}
	false
}

defg all(s:Seq, predicate:F, *args) {
	j = s.len()
	for(i=0;i<j;i=i+1) {
		not(predicate(s[i], *args)) returns false
	}
	true
}

defg none(s:Seq, predicate:F, *args) {
	not(any(s, predicate, *args))
}

defg all_in(a:Seq, x) {
	a.all(@X in x)
}

defg filter(s:Seq, predicate:F, *args) {
	ret = []
	j = s.len()
	for(i=0;i<j;i=i+1) {
		if predicate(s[i], *args) {
			ret.push(s[i])
		}
	}
	ret
}

defg filter(s:Seq) { s @? X != null }
defg without(a:Seq, v) { a @? X != v }

defg count(s:Seq, predicate:F, *args) {
	sum(s @ predicate(X, *args).Number())
}

# Misc
defg values(s:Seq) { s }

# Types transformations
defg Bool(s:Seq) { s.len() > 0 }

# Magic methods

defg '[]'(s:Seq, idxs:Array) { idxs@s[X] }

defg '[]'(s:Seq, idx:Number) {
	guard idx < 0
	l = s.len()
	s[l+idx]
}

# ----- Seq - end -----


# ----- String - start -----

# String(SCALAR)
# later # defg String(l:F) { inspect(l) }

defg String(p:Process) {
	# TODO:
	#   Handle stderr
	ret = p.stdout.read().strip()
	p.finish()
	ret
}

# TODO: don't handle Array children types
defg String(a:Array) { "[${ a.join(', ') }]" }

# TODO: don't handle Hash children types
defg String(h:Hash) { '{' + h.map(F(k,v) { "$k: $v" }).join(', ') + '}' }

# Functions
# TODO: maybe generic for Seq
defg fill(s:String, n:Number) {
	t = n - s.len()
	t < 1 returns s
	s + ' ' * t
}

defg fill(nothing:Null, n:Number) { ' ' * n }

defg strip(s:Seq, elts:Seq) {
	l = s.len()
	i = 0
	while i < l and s[i] in elts {
		i = i + 1
	}
	j = l-1
	while j > i and s[j] in elts {
		j = j - 1
	}
	s.slice(i, j-i+1)
}

defg strip(s:String) { strip(s, " \t\r\n") }

defg split(s:String) { split(s, ' ') }

defg lines(s:String) { split(s, '\n') }

# TODO: escaping
defg repr(s:String) { "'$s'" }

# Magic methods
defg '*'(s:String, n:Number) { join(n@s) }

# Not sure, maybe Seq? Need use cases. For String it's: fname - '.txt' + '.bak'
defg '-'(s:String, sfx:String) {
	if s.endsWith(sfx) {
		s.slice(0, s.len() - sfx.len())
	} {
		# throw maybe?
		s
	}
}

# ----- String - end -----


# ----- Array - start -----

defg sum(a:Array) { reduce(a, 0, (+)) }

# Magic methods

global __literal_w = split

# Arithmetcis
{
	w'+ - * /'.each(F(op) {
		defg $op(a:Array, n:Number) {
			a.map(globals()[op], n)
		}
	})
}

# Magic methods
defg '.'(a:Array, attr:String) { map(a, (.), attr) }

# ----- Array - end -----


# ----- Hash - start -----

# Constructors
defg Hash(a:Array) {
	ret = {}
	a.each(@ ret[X[0]] = X[1])
	ret
}

defg Hash(a:Array, v) { Hash(a@[X,v]) }

defg Hash(keys:Array, mapper:F, *args) {
	Hash(keys@[X, mapper(X, *args)])
}

# Functional

defg each(h:Hash, processor:F, *args) { h.keys().each(@processor(X, h[X], *args)) }
defg map(h:Hash, mapper:F, *args) { h.keys() @ mapper(X, h[X], *args) }
defg filter(h:Hash, predicate:F, *args) {
	ret = {}
	h.each(F(k,v) {
		if predicate(k, v, *args) {
			ret[k] = v
		}
	})
	ret
}

defg values(h:Hash) { h@Y }

defg without(h:Hash, k) {
	h @? X != k
}

# Misc
defg get(h:Hash, k, dflt=null) {
	if k in h {
		h[k]
	} {
		dflt
	}
}

defg dflt(h:Hash, k, v) {
	if k not in h {
		h[k] = v
	}
	h
}

defg '.'(h:Hash, k) { h[k] }

defg '.='(h:Hash, k, v) { h[k] = v }

# Misc
defg '=='(h1:Hash, h2:Hash) {
	len(h1) != len(h2) returns false
	k = h1.keys().sort()
	k != h2.keys().sort() returns false
	k.all(@ h1[X]==h2[X])
}

# Type transformations

defg Bool(h:Hash)   { h.len() > 0 }

# ----- Hash - end -----


# ----- Set - start -----

typeg Set

defg count(s:Set, predicate:F, *args) { s.values().count(predicate, *args) }

# ----- Set - end -----

defg call(f:F, *args) { f(*args) }

# UNTESTED
defg osname() { null }
defg osname() { guard f'/etc/debian_version'; 'debian'}


# ----- Output sugar - start -----

# UNTESTED
defg echo(*args) {
	guard args.len() > 1
	args.each(echo)
}

# ----- Output sugar - end -----


# ----- Set - start -----

# Constructors
defg Set()            { s=obj(Set); s.data={}; s }
defg Set(items:Seq)   { ret = Set(); items.each(@ret.add(X)); ret }

# Mutators
defg add(s:Set, v)    { s.data[v] = true; s }
defg push(s:Set, v)   { add(s,v) }
defg remove(s:Set, v) { s.data.remove(v); s }

# Transformations
defg without(a:Set, v) { a @? X != v }
defg '-'(a:Set, b:Set) { a @? X not in b }

# Getters
defg values(s:Set) { s.data.keys() }
defg len(s:Set) { s.data.len() }

# Functional
# UNTESTED - start
defg each(s:Set, *args)   { s.values().each(*args); s }
defg map(s:Set, *args)    { s.values().map(*args).Set() }
defg filter(s:Set, *args) { s.values().filter(*args).Set() }
# UNTESTED - end

# Predicates
defg Bool(s:Set)        { s.len() > 0 }
defg in(v, s:Set)       { v in s.data }
defg '=='(a:Set, b:Set) { a.values().sort() == b.values().sort() }

# Misc
defg String(s:Set)      { "<Set ${s.values().sort()}>" }
defg repr(s:Set)        { "Set(${s.values().sort().repr()})" }
defg join(s:Set, *args) { join(s.values().sort(), *args) }


# ----- Set - end -----

# ----- `cmd` -----
# TODO: see what happens when the output of the process is lenghty
defg '``'(c:Command) {

	($()).call(c)

	if c.stdout is Null {
		c.stdout = c.process.String()
	}

	c.stdout.String()
}


# ----- ``cmd``- start -----

# Or throw exception?
defg '````'(c:Command) { (``).call(c) }

defg '````'(c:Command) {
	s = (``).call(c)
	guard s.startsWith('{')
	s.from_json()
}

# ----- ``cmd``- end -----

# later # # ----- MaybeFile - start -----
# later # 
# later # typeg MaybeFile(File)
# later # 
# later # defg MaybeFile(s:String) { File(s).as(MaybeFile) }
# later # 
# later # defg lines(f:MaybeFile) {
# later # 	guard not(f)
# later # 	[]
# later # }
# later # 
# later # defg read(f:MaybeFile) {
# later # 	guard not(f)
# later # 	''
# later # }
# later # 
# later # # ----- MaybeFile - end -----

# ----- DfltHash - start -----

typeg DfltHash

# TODO: what happens if someone external uses DfltHash()?
defg DfltHash(v) {
	dh = obj(DfltHash)
	dh.default = v
	dh.data = {}
	dh
}

defg DfltHash() { DfltHash(null) }

defg '[]'(dh:DfltHash, k) {
	dh.data.get(k, dh.default)
}

{
	'[]= keys values in map each'.split().each(F(method) {
		defg $method(dh:DfltHash, *args) { globals()[method].call(dh.data, *args) }
	})
}

defg String(dh:DfltHash) { "<DfltHash dflt=${dh.default} data=${dh.data}>" }

# ----- DfltHash - end -----

# ----- Stats - start -----

typeg Stats(DfltHash)

defg Stats() {
	s = DfltHash(0).as(Stats)
}

defg incr(s:Stats, k:String) {
	s[k] = s[k] + 1
}

defg String(s:Stats) { "<Stats ${s.data}>" }

# ----- Stats - end -----


# ----- Host name utilities - start -----

defg sanitize_hostname() {
	# TODO
}

# ----- Host name utilities - end -----
