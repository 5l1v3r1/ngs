# TODO: Organize by sections.
# TODO: Something that will tell whether all methods were covered at the end of each tests run.
#       Don't want to add a test for each method because some are checked by proxy.

# string * number -> the string repeated number times
defun __mul(s:String, n:Number) {
	ret = ""
	for(i=0;i<n;i=i+1) {
		ret = ret + s;
	}
	ret
}

defun not(x) { if x {false}{true} }

# TODO: somtheing genereic like:
# defun Bool(x) {
#   len_methods_first_args_types = len.args.filter(F(x) { x.len() == 1 }).map(first).map(third)
#   guard typeof(x) in len_methods_first_args
#   x.len() > 0
# }

defun Bool(a:Array)  { a.len() > 0 }
defun Bool(h:Hash)   { h.len() > 0 }
defun Bool(s:String) { s.len() > 0 }

defun Hash(a:Array) {
	ret = {}
	a.each(F(x) { ret[x[0]] = x[1] })
	ret
}

defun Hash(a:Array, v) {
	a.map(F(x) {[x,v]}).Hash()
}

defun zip(a:Array, b:Array) {
	l = len(a)

	if l != b.len() {
		throw ["args", "Zip with different arrays length"]
	}

	l.map(F(i) { [a[i], b[i]] })
}

defun __neq(a, b) {
	not(a==b)
}

defun __eq(a:Array, b:Array) {
	a.len() == b.len()
	and
	all(zip(a,b), F(x) { x[0] == x[1] })
}

defun __eq(a:Hash, b:Hash) {
	a.len() == b.len()
	and
	a.keys().sort() == b.keys().sort()
	and
	all(a.keys(), F(k) { a[k] == b[k] })
}

defun map(a:Array, mapper, *args) {
	a.len().map(F(i) { mapper(a[i], *args) })
}

defun map(n:Number, mapper, *args) {
	ret = []
	for(i=0;i<n;i=i+1) {
		ret.push(mapper(i, *args))
	}
	ret
}

defun map(h:Hash, mapper, *args) {
	h.keys().map(F(k) { mapper(k, h[k], *args) })
}

defun reduce(a:Array, start, reducer) {
	acc = start
	a.each(F(x) { acc = reducer(acc, x) })
	acc
}

defun each(a:Array, processor, *args) {
	j = a.len()
	for(i=0;i<j;i=i+1) {
		processor(a[i], *args)
	}
	a
}

defun each(n:Number, processor, *args) {
	for(i=0;i<n;i=i+1) {
		processor(i, *args)
	}
}

defun any(a:Array, predicate, *args) {
	j = a.len()
	for(i=0;i<j;i=i+1) {
		if predicate(a[i], *args) {
			return true
		}
	}
	false
}

defun all(a:Array, predicate, *args) {
	j = a.len()
	for(i=0;i<j;i=i+1) {
		if not(predicate(a[i], *args)) {
			return false
		}
	}
	true
}

defun none(a:Array, predicate, *args) {
	not(any(a, predicate, *args))
}

defun filter(a:Array, predicate, *args) {
	ret = []
	j = a.len()
	for(i=0;i<j;i=i+1) {
		if predicate(a[i], *args) {
			ret.push(a[i])
		}
	}
	ret
}

defun filter(a:Array) {
	a.filter(F(x) { x != null })
}

defun __get_item(a:Array, idx:Number) {
	guard idx < 0
	l = a.len()
	a[l+idx]
}

defun __get_item(a:Array, idxs:Array) {
	ret = []
	j = idxs.len()
	for(i=0;i<j;i=i+1) {
		ret.push(a[idxs[i]])
	}
	ret
}

defun __get_item(a:Hash, keys:Array) {
	ret = {}
	keys.each(F(k) { ret[k] = a[k] })
	ret
}

# hash.key is same as hash["key"]
defun __get_attr(h:Hash, k:String) {
	h[k]
}

defun __get_attr(a:Array, attr:String) {
	return map(a, __get_attr, attr)
}

defun __in(v, a:Array) {
	any(a, __eq, v)
}

defun __in(v, h:Hash) {
	v in h.keys()
}

defun __not_in(*args) {
	not(__in(*args))
}


defun min(a:Number, b:Number) { if a<b {a}{b} }
defun max(a:Number, b:Number) { if a<b {b}{a} }

defun startsWith(s:String, pfx:String) {
	if len(s) < len(pfx) {
		return false
	}
	l = pfx.len()
	for(i=0;i<l;i=i+1) {
		if s[i] != pfx[i] {
			return false
		}
	}
	true
}

# XXX: Warning: should be per Context or it will bite you
defun spawn_update_globals(args:Array, p:Process) {
	g = globals()
	g["P"] = p
	if "PP" not in g {
		g["PP"] = {}
	}
	g["PP"][args[0]] = p
}

defun spawn(*args) {
	# TODO: handle async
	p = native_spawn(*args)
	spawn_update_globals(args, p)
	ok = cmd_finished_ok_p(p)
	if not(ok) {
		# TODO: nicer output of the args
		# TODO: output stack trace
		throw ["runtime", "Command execution failed: " + inspect(args)]
	}
	p
}

defun spawn(*args) {
	guard args.map(typeof).any(__neq, "String")
	args.map(String).__super()
}

# Convert execution of (example) '-f somefile' to 'test -f somefile'
defun spawn(*args) {
	  guard args.len() > 1
	  guard startsWith(args[0], "-")
	  args = ["test"] + args
	  # or spawn() again?
	  return __super(*args)
}

defun osname() {
	null
}

defun osname() {
	guard $(-f /etc/debian_version)
	"debian"
}


# ----- Finished commands handlers - start -----

defun cmd_finished_ok_p(p:Process) {
	p.exit_code == 0
}

defun cmd_finished_ok_p(p:Process) {
	guard p.cmd == "test"
	p.exit_code in [0,1]
}

defun cmd_finished_ok_p(p:Process) {
	guard p.cmd == "false"
	p.exit_code == 1
}

defun cmd_finished_ok_p(p:Process) {
	guard p.cmd == "service"
	guard p.args[1] == "status"
	# Empirical
	p.exit_code < 4
}

# ----- Finished commands handlers - end -----

defun parse_file(f:String, content:String) {
	content
}

defun parse_file(f:String, content:String) {
	guard f ~ "\.json$"
	r = catch from_json(content)
	if not(r[0]) {
		throw ["runtime", "Failed to read json file " + f]
	}
	r[1]
}

defun read(f:String) {
	content = fetch_file(f)
	parse_file(f, content).meta("file", f)
}

defun one(a:Array) {
	if a.len() != 1 {
		throw ["data", "Expected array with exactly one item but had " + a.len().String(), a]
	}
	a[0]
}

# Abstract usage example:
# servers.filter(F(x) {'unicorn' in x.tags}).one("Unicorn server").create_image("Unicorn backup")
defun one(a:Array, s:String) {
	if a.len() != 1 {
		throw ["data", "Expected array with exactly one " + s + " but had " + a.len().String(), a]
	}
	a[0]
}

# ----- Output helpers - start -----

defun String(p:Process) {
	# TODO:
	#   Handle processes that are still running.
	#   Handle stderr
	#   Handle failed processes
	#   Handle exit_code
	p.stdout
}

defun join(a:Array, sep:String) {
	ret = ""
	j = a.len()
	for(i=0;i<j;i=i+1) {
		ret = ret + String(a[i])
		if i < j - 1 {
			ret = ret + sep
		}
	}
	ret
}

defun String(s:String) { s }

defun String(a:Array) {
	a.join(", ")
}

defun String(h:Hash) {
	"{" + h.map(F(k,v) { String(k) + ": " + String(v) }).join(", ") + "}"
}

defun String(b:Bool) {
	if b {"true"}{"false"}
}

defun String(n:Null) {
	"null"
}

defun String(l:Lambda) {
	inspect(l)
}

defun String(t:Thread) {
	"<Thread " + t.id.String() + " " + t.state + ">"
}

defun echo(x) {
	guard typeof(x) != "String"
	String(x).echo()
}

defun echo(*args) {
	guard args.len() > 1
	args.each(echo)
}

# ----- Output helpers - end -----

# ----- Meta sugar - start -----
defun meta(x, k:String) {
	x.meta()[k]
}

defun meta(x, k:String, v) {
	x.meta()[k] = v
	x
}

defun has_meta(x, k:String) {
	k in x.meta()
}
# ----- Meta sugar - end -----

defun first(a)  { a[0] }
defun second(a) { a[1] }
defun third(a)  { a[2] }
defun fourth(a) { a[3] }
defun fifth(a)  { a[4] }

defun last(a)   { a[-1] }
