# TODO: Organize by sections.
# TODO: Something that will tell whether all methods were covered at the end of each tests run.
#       Don't want to add a test for each method because some are checked by proxy.

# ----- String functions - start -----
# string * number -> the string repeated number times
defun global __mul(s:String, n:Number) {
	# n.map(F(x) { s }).join()
	join(n | s)
}

defun global __match(s:String, n:Number) { s.len() == n }

defun global strip(s:Seq, elts:Seq) {
	l = s.len()
	i = 0
	while i < l and s[i] in elts {
		i = i + 1
	}
	j = l-1
	while j > i and s[j] in elts {
		j = j - 1
	}
	s.slice(i, j-i+1)
}

defun global strip(s:String) {
	strip(s, " \t\r\n")
}

# Not the most efficient :/
defun global pos(s:Seq, subseq:Seq, start:Number=0) {
	sl = s.len()
	ssl = subseq.len()
	if sl < ssl {
		return null
	}
	j = sl - ssl + 1

	for(i=start; i<j; i=i+1) {
		if slice(s, i, ssl) == subseq {
			return i
		}
	}
	return null
}

defun global split(s:Seq, delim:Seq) {
	sl = s.len()
	dl = delim.len()
	ret = []
	start = 0
	while (i=s.pos(delim, start)) != null {
		ret.push(s.slice(start, i-start))
		start = i + dl
	}
	if(start<sl) {
		ret.push(s.slice(start, sl-start))
	}
	ret
}

defun global split(s:String) { split(s, ' ') }

defun global split(p:Process, *args) { split(p.stdout.strip(), *args) }

defun global Number(s:String) {
	# TODO: checks, negatives, floats, base
	ord_zero = ord('0')
	ret = 0
	s.each(F(ch) { ret = ret * 10 + ord(ch) - ord_zero })
	ret
}

# ----- String functions - end -----

defun global __match(a:Array, n:Number) { a.len() == n }

defun global not(x) { if x {false}{true} }

# TODO:
#   Make String and Array inherit from new type Sequence.
#   Sequence will have method len() among others.
#   defun Bool(s:Sequence) { s.len() > 0 }

defun global Bool(s:Seq)    { s.len() > 0 }
defun global Bool(h:Hash)   { h.len() > 0 }

defun global Hash(a:Array) {
	ret = {}
	a.each(F(x) { ret[x[0]] = x[1] })
	ret
}

defun global Hash(a:Array, v) {
	# a.map(F(x) {[x,v]}).Hash()
	Hash(a | [X,v])
}

defun global Hash(keys:Array, mapper:F, *args) {
	# keys.map(F(x) {[x, mapper(x, *args)]}).Hash()
	Hash(keys | [X, mapper(X, *args)])
}

defun global zip(a:Seq, b:Seq) {
	l = len(a)

	if l != b.len() {
		throw ['args', 'Zip with different Seqs length']
	}

	# l.map(F(i) { [a[i], b[i]] })
	l | [a[X], b[X]]
}

defun global __neq(a, b) {
	not(a==b)
}

# Don't make it Seq. It causes infinite recursion I guess.
defun global __eq(a:Array, b:Array) {
	a.len() == b.len()
	and
	all(zip(a,b), F(x) { x[0] == x[1] })
}

defun global __eq(a:Hash, b:Hash) {
	a.len() == b.len()
	and
	a.keys().sort() == b.keys().sort()
	and
	all(a.keys(), F(k) { a[k] == b[k] })
}

defun global __eq(a:Thread, b:Thread) { a.id == b.id }

defun global map(s:Seq, mapper:F, *args) {
	# s.len().map(F(i) { mapper(s[i], *args) })
	s.len() | mapper(s[X], *args)
}

defun global map(n:Number, mapper:F, *args) {
	ret = []
	for(i=0;i<n;i=i+1) {
		ret.push(mapper(i, *args))
	}
	ret
}

defun global map(h:Hash, mapper:F, *args) {
	# h.keys().map(F(k) { mapper(k, h[k], *args) })
	h.keys() | mapper(X, h[X], *args)
}

# defun global mapv(h:Hash, mapper:F, *args) {
# 	ret = {}
# 	h.keys().map(F(k) { ret[k] = mapper(h[k], *args) })
# 	ret
# }

# By default a pipe is map() but we don't do __pipe=map to
# allow overriding of __pipe for specific types.
defun global __pipe(*args) {
	map(*args)
}

defun global __pipe(h:Hash, f:F) {
	h.map(F(k, v) { f([k,v]) })
}

defun global reduce(s:Seq, start, reducer:F) {
	acc = start
	s.each(F(x) { acc = reducer(acc, x) })
	# s | acc = reducer(acc, X)
	acc
}

defun global sum(a:Array) { reduce(a, 0, __add) }

defun global each(s:Seq, processor:F, *args) {
	j = s.len()
	for(i=0;i<j;i=i+1) {
		processor(s[i], *args)
	}
	s
}

defun global each(n:Number, processor:F, *args) {
	for(i=0;i<n;i=i+1) {
		processor(i, *args)
	}
}

defun global any(s:Seq, predicate:F, *args) {
	j = s.len()
	for(i=0;i<j;i=i+1) {
		if predicate(s[i], *args) {
			return true
		}
	}
	false
}

defun global all(s:Seq, predicate:F, *args) {
	j = s.len()
	for(i=0;i<j;i=i+1) {
		if not(predicate(s[i], *args)) {
			return false
		}
	}
	true
}

defun global none(s:Seq, predicate:F, *args) {
	not(any(s, predicate, *args))
}

defun global filter(s:Seq, predicate:F, *args) {
	ret = []
	j = s.len()
	for(i=0;i<j;i=i+1) {
		if predicate(s[i], *args) {
			ret.push(s[i])
		}
	}
	ret
}

defun global filter(s:Seq) {
	s.filter(F(x) { x != null })
}

defun global __get_item(s:Seq, idx:Number) {
	guard idx < 0
	l = s.len()
	s[l+idx]
}

defun global __get_item(s:Seq, idxs:Array) {
	# idxs.map(F(i) { s[i] })
	idxs | s[X]
}

defun global __get_item(h:Hash, n:Number) {
	h[n.String()]
}

defun global __set_item(h:Hash, n:Number, v) {
	h[n.String()] = v
}

defun global __get_item(a:Hash, keys:Array) {
	# keys.map(F(k) { [k, a[k]] }).Hash()
	Hash(keys | [X, a[X]])
}

# Make hash.key same as hash['key']
defun global __get_attr(h:Hash, k:String) {
	h[k]
}

defun global __get_attr(a:Array, attr:String) {
	# map(a, __get_attr, attr)
	a | X.attr
}

defun global __in(v, s:Seq) {
	any(s, __eq, v)
}

defun global __in(v, h:Hash) {
	v in h.keys()
}

# TODO: defun global __in(substring, string)

defun global __not_in(*args) {
	not(__in(*args))
}

defun global has(container, item) {item in container}


defun global min(a:Number, b:Number) { if a<b {a}{b} }
defun global max(a:Number, b:Number) { if a<b {b}{a} }

defun global startsWith(s:Seq, pfx:Seq) {
	if len(s) < len(pfx) {
		return false
	}
	l = pfx.len()
	for(i=0;i<l;i=i+1) {
		if s[i] != pfx[i] {
			return false
		}
	}
	true
}

defun global endsWith(s:Seq, sfx:Seq) {
	if len(s) < len(sfx) {
		return false
	}
	l = sfx.len()
	sidx = s.len() - l
	for(i=0;i<l;i=i+1) {
		if s[sidx+i] != sfx[i] {
			return false
		}
	}
	true
}

# Not sure, maybe Seq? Need use cases. For String it's: fname - '.txt' + '.bak'
defun global __sub(s:String, sfx:String) {
	if s.endsWith(sfx) {
		s.slice(0, s.len() - sfx.len())
	} else {
		# throw maybe?
		s
	}
}

# XXX: Warning: should be per Context or it will bite you
defun global spawn_update_globals(args:Array, p:Process) {
	g = globals()
	g['P'] = p
	if 'PP' not in g {
		g['PP'] = {}
	}
	g['PP'][args[0]] = p

	# Hack for CLI
	thread().locals()['P'] = p
}

defun global spawn(*args) {
	# TODO: handle async
	p = native_spawn(*args)
	spawn_update_globals(args, p)
	p.wait()
	ok = cmd_finished_ok_p(p)
	if not(ok) {
		# TODO: nicer output of the args
		# TODO: output stack trace
		throw ['runtime', 'Command execution failed: ' + inspect(args)]
	}
	p
}

defun global spawn(*args) {
	guard args.map(typeof).any(__neq, 'String')
	__super(*args.map(String))
}

# Convert execution of (example) '-f somefile' to 'test -f somefile'
defun global spawn(*args) {
	  guard args.len() > 1
	  guard startsWith(args[0], '-')
	  args = ['test'] + args
	  # or spawn() again?
	  return __super(*args)
}

defun global osname() {
	null
}

defun global osname() {
	guard f'/etc/debian_version'
	'debian'
}


# ----- Finished commands handlers - start -----

defun global cmd_finished_ok_p(p:Process) {
	p.exit_code == 0
}

defun global cmd_finished_ok_p(p:Process) {
	guard p.cmd == 'test'
	p.exit_code in [0,1]
}

defun global cmd_finished_ok_p(p:Process) {
	guard p.cmd == 'false'
	p.exit_code == 1
}

defun global cmd_finished_ok_p(p:Process) {
	guard p.cmd == 'service'
	guard p.args[1] == 'status'
	# Empirical
	p.exit_code < 4
}

# ----- Finished commands handlers - end -----

defun global parse_file(f:String, content:String) {
	content
}

defun global parse_file(f:String, content:String) {
	guard f ~ /\\.json$/
	r = catch from_json(content)
	if not(r[0]) {
		throw ['runtime', "Failed to read json file ${f}"]
	}
	r[1]
}

defun global read(f:String) {
	content = fetch_file(f)
	parse_file(f, content).meta('file', f)
}

defun global one(s:Seq) {
	if s.len() != 1 {
		throw ['data', "Expected array with exactly one item but had ${a.len()}", a]
	}
	s[0]
}

# Abstract usage example:
# servers.filter(F(x) {'unicorn' in x.tags}).one('Unicorn server').create_image('Unicorn backup')
defun global one(s:Seq, msg:String) {
	if s.len() != 1 {
		throw ['data', "Expected array with exactly one $msg but had ${a.len()}", a]
	}
	s[0]
}

# ----- Output helpers - start -----

defun global String(p:Process) {
	# TODO:
	#   Handle processes that are still running.
	#   Handle stderr
	#   Handle failed processes
	#   Handle exit_code
	p.stdout.strip()
}

defun global join(s:Seq, sep:String) {
	ret = ''
	j = s.len()
	for(i=0;i<j;i=i+1) {
		ret = ret + String(s[i])
		if i < j - 1 {
			ret = ret + sep
		}
	}
	ret
}

defun global join(s:Seq) { join(s, '') }

defun global String(s:String) { s }

defun global String(a:Array) {
	'[' + a.join(', ') + ']'
	# Could be less readable: "[${a.join(', ')}]"
}

defun global String(a:Array) {
	guard typeof(a) != 'Array'
	'<' + typeof(a) + ' ' + __super(a) + '>'
}

defun global String(h:Hash) {
	'{' + h.map(F(k,v) { "$k: $v" }).join(', ') + '}'
}

defun global String(h:Hash) {
	guard typeof(h) != 'Hash'
	'<' + typeof(h) + ' ' + __super(h) + '>'
}


defun global String(b:Bool) {
	if b {'true'}{'false'}
}

defun global String(n:Null) {
	'null'
}

defun global String(l:Lambda) {
	inspect(l)
}

defun global String(t:Thread) {
	"<Thread ${t.id} ${t.state}>"
}

defun global String(c:Code) {
	"<Compiled code>"
}

defun global echo(x) {
	guard typeof(x) != 'String'
	x.String().echo()
}

defun global echo(*args) {
	guard args.len() > 1
	args.each(echo)
}

# ----- Output helpers - end -----

# ----- Meta sugar - start -----
defun global meta(x, k:String) {
	x.meta()[k]
}

defun global meta(x, k:String, v) {
	x.meta()[k] = v
	x
}

defun global has_meta(x, k:String) {
	k in x.meta()
}
# ----- Meta sugar - end -----

# ----- __get_item sugar - start -----
defun global first(s:Seq)  { s[0] }
defun global second(s:Seq) { s[1] }
defun global third(s:Seq)  { s[2] }
defun global fourth(s:Seq) { s[3] }
defun global fifth(s:Seq)  { s[4] }

defun global last(s:Seq)   { s[-1] }
# ----- __get_item sugar - end -----

# ----- Types sugar - start -----
defun global inherits(child:String, parent:String) {
	if child not in __TYPES {
		__TYPES[child] = {}
	}
	if 'inherits' not in __TYPES[child] {
		__TYPES[child]['inherits'] = []
	}
	if parent in __TYPES[child]['inherits'] {
		return null
	}
	__TYPES[child]['inherits'].push(parent)
}

defun global mktype(type:String, parents:Array) {
	parents.each(F(p) { inherits(type, p) })
	# parents | inherits(type, X)
	defun global "$type"() {
		obj(type).init()
	}
}

defun global mktype(type:String, parent:String) {
	mktype(type, [parent])
}
# ----- Types sugar - end -----

# Should be defined for files fetched from remote locations, maybe
# in some other cases too.
defun global validate_source_file(f:String, content:String) {
	  true
}

# TODO: path to search in
# TODO: specify version of the required file/module
defun global require(f:String, *args) {
	content = fetch_file(f)
	if not(validate_source_file(f, content)) {
		throw ['runtime', "Failed to validate source file $f"]
	}
	code = compile(content)
	lambda_ = load(code)
	lambda_(*args)
}

# ----- Files - start -----
global __literal_f = File

# Anything else will break $(ls $f) and probably other stuff
defun global String(f:File) { f.name }

defun global Bool(p:Path) { $(-e $p).Bool() }
defun global Bool(f:File) { $(-f $f).Bool() }

defun global read_till(fd:Number, tillChar:String, max:Number=1024) {
	ret = ''
	while (ch = fd.read()) != tillChar {
		ret = ret + ch
		if ret.len() > max { throw ['runtime', 'read_till epic fail'] }
		# echo("<CH thread=${thread().id} ord=${ch.ord()} ch=$ch ret=$ret>")
	}
	# echo("<READ_TILL thread=${thread().id} till=$tillChar ch=$ch ret=$ret>")
	ret
}

# ----- Files - end -----

# ----- Array arithmetcis - start -----
{
	'add sub mul div'.split().each(F(op) {
		defun global "__$op"(a:Array, n:Number) { a.map(globals()["__$op"], n) }
	})
}
# ----- Array arithmetcis - end -----

# ----- Lock sugar - start -----
defun global acquire(l:Lock, f:F, *args) {
	# TODO: maybe catch and rethrow after release()
	l.acquire()
	f(*args)
	l.release()
}
# ----- Lock sugar - end -----
