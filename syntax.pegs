// ***************************************************
// Warning operators precedence is not handled yet !!!
// ***************************************************

{
	var N = require('./ast_node').ASTNode;
}

start = 
  commands

space = [ \t\n]+
inline_space = [ \t]+
newline_space = inline_space? [\n]+ inline_space?

commands "commands" =
  space? c:command commands_separator cs:commands {
	return N('commands', [c]).concat(cs);
  } /
  c:command commands_separator? space? { return N('commands', [c]); }

commands_separator "Command separator" =
  newline_space /
  inline_space? [;] inline_space?

command "command" =
  CCEXPR_code /
  assignment inline_space command /
  assignment /
  if /
  while /
  for /
  async /
  hash_comment /
  execute_external_prog

hash_comment "# Comment" =
  inline_space? "#" c:[^\n]+ { return N('comment', [], c.join('')); }

slash_slash_comment "// Comment" =
  inline_space? "//" c:[^\n]+ { return N('comment', [], c.join('')); }

comment "Any kind of comment" =
  hash_comment /
  slash_slash_comment

if "if" =
  'if' space? cond:expr space? 'then'? space? if_true:CCEXPR if_false:(space? 'else'? space? CCEXPR)? {
    return N('if', [cond, if_true]).push(if_false ? if_false[3] : null);
  }

while "while" =
  // Experiemntal feature "not"
  "while" space? not:"not"? space? cond:expr space? body:CCEXPR {
    return N('while', [cond, body], not ? true : false);
  }

for "for" =
  // Experiemntal feature "not"
  "for" space? "(" space? init:expr space? ";" space? cond:expr space? ";" space? incr:expr space? ")" space? body:CCEXPR_code {
    return N('for', [init, cond, incr, body]);
  }

break "break" = "break" { return N('break', []); }
continue "continue" = "continue" { return N('continue', []); }

async "async" =
  "async" space e:CCEXPR {
    return N('async', [e]);
  }

assignment "assignment" =
  varname:varname space? '=' space? val:expr { return N('assignment', [varname, val]); }

varname "variable name" =
  v:[_a-zA-Z]+[_0-9a-zA-Z]* { return N('varname', [], v.join('')); }

CCEXPR "CCEXPR" =
  CCEXPR_commands /
  CCEXPR_code

CCEXPR_commands =
  space? '(' space? commands:commands space? ')' { return commands; }

CCEXPR_code =
  space? '{' space? code:top_level_expressions space? ";"? space? '}' {
    return code;
  }

top_level_expressions "Top-level expressions" =
  e:expr top_level_expressions_delimiter es:top_level_expressions {
    return N('top_level_expressions', [e]).concat(es);
  } /
  e:expr { return N('top_level_expressions', [e]); }

top_level_expressions_delimiter =
  newline_space /
  inline_space? ";" space?



// ********************************************************************
// TODO fix expr_* order for operation precedence. Low priority at top.
// ********************************************************************

expr "Expression" =
  comment /
  e:expr_set_item comment? { return e; }

expr_set_item "Expression/set_item" =
  // container must not be expr_get_item, should be expr_eq
  container:expr_eq inline_space? "[" space? idx:expr space? "]" space? "=" space? v:expr {
    return N('set_item', [container, idx, v]);
  } /
  e: expr_in


expr_in "Expression/in" =
  v:expr_or inline_space "in" space container:expr_or {
    return N('in', [v, container])
  } /
  v:expr_or inline_space "not" space "in" space container:expr_or {
    return N('not_in', [v, container])
  } /
  e: expr_or

expr_or "Expression/or" =
  e1:expr_and space? "or" space? e2:expr {
    return N('binop', [e1, e2], 'or', 2500);
  } /
  expr_and

expr_and "Expression/and" =
  e1:expr_eq space? "and" space? e2:expr {
    return N('binop', [e1, e2], 'and', 2000);
  } /
  expr_eq

expr_eq "Expression/eq" =
  e1:expr_add space? "==" space? e2:expr {
    return N('binop', [e1, e2], 'eq', 1500);
  } /
  e1:expr_add space? "!=" space? e2:expr {
    return N('binop', [e1, e2], 'neq', 1500);
  } /
  e1:expr_add space? "<" space? e2:expr {
    return N('binop', [e1, e2], 'lt', 1500);
  } /
  e1:expr_add space? ">" space? e2:expr {
    return N('binop', [e1, e2], 'gt', 1500);
  } /
  e1:expr_add space? "~" space? e2:expr {
    return N('binop', [e1, e2], 'tilde', 1500);
  } /
  e: expr_add

expr_add "Expression/add" =
  e1:expr_mul space? "+" space? e2:expr_add {
    return N('binop', [e1, e2], 'add', 1000);
  } /
  e1:expr_mul space? "-" space? e2:expr_add {
    return N('binop', [e1, e2], 'sub', 1000);
  } /
  e:expr_mul

expr_mul "Expression/mul" =
  e1:expr_call space? "*" space? e2:expr_call {
    return N('binop', [e1, e2], 'mul', 500);
  } /
  e:expr_chain


expr_chain =
  e:expr_call c:dots* {
	var ret = e;
	for(var i=0; i<c.length; i++) {
	  if(c[i].is('dot_call')) {
	    var a = c[i][1]; // args
	    a.unshift(ret);
	    ret = N('call', [c[i][0], a]);
	  }
	  if(c[i].is('get_attr')) {
	    c[i].push(ret); // container
		ret = c[i];
	  }
	  if(c[i].is('get_item')) {
	    c[i][0] = ret; // container
		ret = c[i];
	  }
	}
    return ret;
  }


dots "expression dot expression, maybe call" =
  dot_call /
  get_attr /
  get_item

dot_call "dot function call" =
  "." f:varname space? "(" space? args:comma_separated_expressions? space? ")" {
	var a = args || N('expressions', []);
	return N('dot_call', [f, a]);
  }

get_attr "Get attribute" =
  "." attr:varname !(space? "=" [^=]) {
    return N('get_attr', [], attr.data);
  }

get_item "Expression/get_item" =
  "[" space? idx:expr space? "]" !(space? "=" [^=]) {
    return N('get_item', [null, idx]);
  }


expr_call "Function call" =
  function_call /
  expr_base


expr_base "Expression/no-add" =
  if /
  while /
  for /
  break /
  continue /
  guard /
  match /
  type_definition /
  assignment /
  lambda /
  function_definition /
  return /
  number /
  string /
  "true" { return N('bool', [], true); } /
  "false" { return N('bool', [], false); } /
  "null" { return N('null', [], false); } /
  varname /
  array_literal /
  hash_literal /
  "(" space? e:expr space? ")" { return e; } /
  "$" cs:CCEXPR_commands { return cs; }

number "number" =
  "0x" hex_digits:[0-9a-fA-F]+ { return N('number', [], parseInt(hex_digits.join(''), 16)); } /
  digits:[0-9]+ { return N('number', [], parseInt(digits.join(''), 10)); }

execute_external_prog "execute external program" =
  w:cmd_words { return N('spawn', [w]); }

cmd_words "Command words" =
  w:cmd_word inline_space ws:cmd_words  {
    return N('array', [w]).concat(ws);
  } /
  w:cmd_word { return N('array', [w]); }

cmd_word "Command word" =
  CCEXPR_code /
  "$" v:varname { return v; } /
  "$*" v:varname { return N('splice', [v]); } /
  s:string  { return s; } /
  w:[-_a-zA-Z0-9*?/]+ {  return N('string', [], w.join('')); }

string "Command string" =
  '"' s:string_contents '"' {  return s; }

// Temp. TODO: add escaping and substitution
string_contents "String contents" =
  s:[^"]* {  return N('string', [], s.join('')); }

array_literal "array literal" =
  "[" space? es:comma_separated_expressions? space? "]" {
	return N('array', es ? es : []);
  }

comma_separated_expressions "comma-separated expressions" =
  e:expr_or_splice space? "," space? es:comma_separated_expressions {
	return N('expressions', [e]).concat(es);
  } /
  e:expr_or_splice { return N('expressions', [e]); }

expr_or_splice =
  e:expr { return e; } /
  s:splice { return s; }

splice "splice" =
  "*" space? e:expr { return N('splice', [e]); }

hash_literal "hash literal" =
  "{" space? es:comma_separated_kv? space? "}" {
	return N('hash', es ? es : []);
  }

comma_separated_kv "comma-separated kv" =
  k:expr space? ":" space? v:expr space? "," space? es:comma_separated_kv {
	return N('kv_list', [N('kv', [k,v])]).concat(es);
  } /
  k:expr space? ":" space? v:expr space? { return N('kv_list', [N('kv', [k,v])]); }

lambda "Lambda" =
  ("lambda" / "F") (space+ name:varname)? space? "(" space? params:parameters? space? ")" space? code:CCEXPR { return N('lambda', [params || N('parameters', []), code], (typeof name !== 'undefined') ? name.data : null); }

function_definition =
  "defun" space+ name:varname space? "(" space? params:parameters? space? ")" space? code:CCEXPR { return N('defun', [N('lambda', [params || N('parameters', []), code])], name.data); }

parameters "Function parameters list" =
  p:parameter space? "," space? ps:parameters {
    return N('parameters', [p]).concat(ps);
  } /
  p:parameter {
    return N('parameters', [p])
  }

parameter "Function parameter" =
  "*" v:varname { return N('arg_rest_pos', [], v.data); } /
  "**" v:varname { return N('arg_rest_kw', [], v.data); } /
  v:varname t:parameter_type? { return N('arg_pos', t ? [t] : [], v.data); }

parameter_type "Function parameter type" =
  space? ":" space? t:varname space? { return N('arg_type', [], t.data);  }

return "return" =
  "return" space e:expr { return N('ret', [e]); }

function_call "function call" =
  f:expr_base space? "(" space? args:comma_separated_expressions? space? ")" {
	return N('call', [f, args || N('expressions', [])]);
  }


type_definition "Type definition" =
  "deftype" space+ type:varname space? "{" space? ds:type_fields_definitions? space? "}" {
    return N('deftype', ds || [], type.data);
  }

type_fields_definitions "Definitions of fields of a type" =
  d:type_field_definition space? ";" space? ds:type_fields_definitions space? {
    return N('fields_definitions', [d]).concat(ds);
  } /
  d:type_field_definition space? ";" ? {
    return N('fields_definitions', [d]);
  }

type_field_definition "Definition of a field of a type" =
  space? name:varname space? ":" space? type:varname space? {
    return N('field_definition', [], [name.data, type.data]);
  }

guard "Function entry guard" =
  "guard" space? e:expr { return N('guard', [e]); }

match "Match" =
  "match" space? "(" space? args:comma_separated_expressions? space? ")" space? "{" space? c:cases space? "}" {
    return N('match', [args || N('expressions', []), c])
  }
  
cases "Match case clauses" =
  c:case space? cs:cases {
    return N('cases', [c]).concat(cs);
  } /
  c:case {
    return N('cases', [c]);
  }

case "Case clause" =
  "(" space? params:parameters? space? ")" space? code:CCEXPR {
    return N('lambda', [params || N('parameters', []), code]);
  }
