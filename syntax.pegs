// TODO: "not in" -> "not" space "in"
// TODO: implement sane parts of
//       https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
//       while fitting the style of NGS of course.
//       First candidate is ":=". Only for unset. If it's null, one should use "x or myval"
{
	var N = require('./ast_node').ASTNode;
	var ngs_precedence_src = [
		['in', 'not in'],
		['or'],
		['and'],
		['==', '!=', '<', '>', '~'],
		['+', '-'],
		['*', '/'],
    ]
	var ngs_precedence = {};
	for(var i=0; i<ngs_precedence_src.length; i++) {
		ngs_precedence_src[i].forEach(function(op) {
			ngs_precedence[op] = i;
		});
	}
	var ngs_binops_names = {
		'in'    : 'in',
		'not in': 'not_in',
		'or'    : 'or',
		'and'   : 'and',
		'=='    : 'eq',
		'!='    : 'neq',
		'<'     : 'lt',
		'>'     : 'gt',
		'~'     : 'tilde',
		'+'     : 'add',
		'-'     : 'sub',
		'*'     : 'mul',
		'/'     : 'div',
	}
}

start = 
  commands

space = [ \t\n]+
inline_space = [ \t]+
newline_space = (inline_space? [\n]+ inline_space?)+

commands "commands" =
  space? c:command commands_separator cs:commands {
	return N('commands', [c]).concat(cs);
  } /
  c:command commands_separator? space? { return N('commands', [c]); }

commands_separator "Command separator" =
  newline_space /
  inline_space? [;] inline_space?

command "command" =
  CCEXPR_code /
  assignment inline_space command /
  assignment /
  function_definition /
  function_call /
  if /
  while /
  for /
  async /
  hash_comment /
  execute_external_prog

hash_comment "# Comment" =
  inline_space? "#" c:[^\n]+ { return N('comment', [], c.join('')); }

slash_slash_comment "// Comment" =
  inline_space? "//" c:[^\n]+ { return N('comment', [], c.join('')); }

comment "Any kind of comment" =
  hash_comment /
  slash_slash_comment

if "if" =
  'if' space? cond:expr space? 'then'? space? if_true:CCEXPR if_false:(space? 'else'? space? CCEXPR)? {
    return N('if', [cond, if_true]).push(if_false ? if_false[3] : null);
  }

while "while" =
  // Experiemntal feature "not"
  "while" space? not:"not"? space? cond:expr space? body:CCEXPR {
    return N('while', [cond, body], not ? true : false);
  }

for "for" =
  // Experiemntal feature "not"
  "for" space? "(" space? init:expr space? ";" space? cond:expr space? ";" space? incr:expr space? ")" space? body:CCEXPR_code {
    return N('for', [init, cond, incr, body]);
  }

break "break" = "break" { return N('break', []); }
continue "continue" = "continue" { return N('continue', []); }

async "async" =
  "async" space e:CCEXPR {
    return N('async', [e]);
  }

assignment "assignment" =
  varname:varname space? '=' space? val:expr { return N('assignment', [varname, val]); }

varname "variable name" =
  v:([_a-zA-Z]+[_0-9a-zA-Z]*) { return N('varname', [], (v[0].concat(v[1])).join('')); }

CCEXPR "CCEXPR" =
  CCEXPR_commands /
  CCEXPR_code

CCEXPR_commands =
  space? '(' space? commands:commands space? ')' { return commands; }

CCEXPR_code =
  space? '{' space? code:top_level_expressions space? ";"? space? '}' {
    return code;
  }

top_level_expressions "Top-level expressions" =
  e:expr top_level_expressions_delimiter es:top_level_expressions {
    return N('top_level_expressions', [e]).concat(es);
  } /
  e:expr { return N('top_level_expressions', [e]); }

top_level_expressions_delimiter =
  newline_space /
  inline_space? ";" space?

expr "Expression" =
  comment /
  e:expr_set_item comment? { return e; }

expr_set_item "Expression/set_item" =
  // container must not be expr_get_item, should be expr_eq
  container:expr_binop inline_space? "[" space? idx:expr space? "]" space? "=" space? v:expr {
    return N('set_item', [container, idx, v]);
  } /
  container:expr_binop "." idx:varname space? "=" space? v:expr {
    return N('set_item', [container, N('string', [], idx.data), v]);
  } /
  e: expr_binop


expr_binop =
  e:expr_chain es:(binop expr_chain)* {
    var ret = [e];
    for(var i=0; i<es.length; i++) {
	  if(!ngs_binops_names[es[i][0]]) {
	    throw new Error("No name for binop: " + es[i][0]);
	  }
	  ret.push(N('binop', [], ngs_binops_names[es[i][0]], ngs_precedence[es[i][0]]));
	  ret.push(es[i][1]);
	}
    return N('binops', ret);
  }

binop =
  binop1 /
  binop2

binop1 = space? b:("==" / "!=" / "<" / ">" / "~" / "+" / "-" / "*" / "/") space? { return b; }
binop2 = space b:("or" / "and" /  "in" / "not in") space { return b; }

expr_chain =
  e:expr_call c:dots* {
	var ret = e;
	for(var i=0; i<c.length; i++) {
	  if(c[i].is('dot_call')) {
	    var a = c[i][1]; // args
	    a.unshift(ret);
	    ret = N('call', [c[i][0], a]);
	  }
	  if(c[i].is('get_attr')) {
	    c[i].push(ret); // container
		ret = c[i];
	  }
	  if(c[i].is('get_item')) {
	    c[i][0] = ret; // container
		ret = c[i];
	  }
	}
    return ret;
  }


dots "expression dot expression, maybe call" =
  dot_call /
  get_attr /
  get_item

dot_call "dot function call" =
  "." f:varname space? "(" space? args:comma_separated_expressions? space? ")" {
	var a = args || N('expressions', []);
	return N('dot_call', [f, a]);
  }

get_attr "Get attribute" =
  "." attr:varname !(space? "=" [^=]) {
    return N('get_attr', [], attr.data);
  }

get_item "Expression/get_item" =
  "[" space? idx:expr space? "]" !(space? "=" [^=]) {
    return N('get_item', [null, idx]);
  }


expr_call "Function call" =
  function_call /
  expr_base


expr_base "Expression/no-add" =
  if /
  while /
  for /
  break /
  continue /
  guard /
  match /
  assignment /
  lambda /
  function_definition /
  return /
  throw /
  number /
  string /
  "true" { return N('bool', [], true); } /
  "false" { return N('bool', [], false); } /
  "null" { return N('null', [], false); } /
  varname /
  array_literal /
  hash_literal /
  "(" space? e:expr space? ")" { return e; } /
  "$" cs:CCEXPR_commands { return cs; }

number "number" =
  "0x" hex_digits:[0-9a-fA-F]+ { return N('number', [], parseInt(hex_digits.join(''), 16)); } /
  neg:"-"? digits:[0-9]+ { return N('number', [], parseInt(digits.join(''), 10) * (neg ? -1 : 1)); }

execute_external_prog "execute external program" =
  w:cmd_words { return N('spawn', [w]); }

cmd_words "Command words" =
  w:cmd_word inline_space ws:cmd_words  {
    return N('array', [w]).concat(ws);
  } /
  w:cmd_word { return N('array', [w]); }

cmd_word "Command word" =
  CCEXPR_code /
  "$" v:varname { return v; } /
  "$*" v:varname { return N('splice', [v]); } /
  s:string  { return s; } /
  w:[-_a-zA-Z0-9*?/]+ {  return N('string', [], w.join('')); }

string "Command string" =
  "'" s:string_contents_sq "'" { return s; } /
  '"' s:string_contents_dq '"' { return s; }

string_contents_sq "Single quoted string contents" =
  sces:(string_contents_sq_element*) {  return N('string_container', sces); }

string_contents_dq "Double quoted string contents" =
  sces:(string_contents_dq_element*) {  return N('string_container', sces); }

string_contents_sq_element "String contents element" =
  string_contents_common_element /
  s:[^'\\]+ { return N('string', [], s.join('')); }

string_contents_dq_element "String contents element" =
  string_contents_common_element /
  "$" v:varname { return v; } /
  "$" c:CCEXPR_code { return c; } /
  "$" c:CCEXPR_commands { return c; } /
  s:[^"$\\]+ { return N('string', [], s.join('')); }

// http://en.wikipedia.org/wiki/Escape_sequences_in_C
string_contents_common_element =
  "\\a" { return N('string', [], String.fromCharCode(7)); } /
  "\\b" { return N('string', [], String.fromCharCode(8)); } /
  "\\e" { return N('string', [], String.fromCharCode(27)); } /
  "\\f" { return N('string', [], String.fromCharCode(12)); } /
  "\\n" { return N('string', [], String.fromCharCode(10)); } /
  "\\r" { return N('string', [], String.fromCharCode(13)); } /
  "\\t" { return N('string', [], String.fromCharCode(9)); } /
  "\\x" hex:([0-9A-F][0-9A-F]) { return N('string', [], String.fromCharCode(parseInt(hex.join(''), 16))); } /
  "\\u" hex:([0-9A-F][0-9A-F][0-9A-F][0-9A-F]) { return N('string', [], String.fromCharCode(parseInt(hex.join(''), 16))); } /
  "\\U" hex:([0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F][0-9A-F]) { return N('string', [], String.fromCharCode(parseInt(hex.join(''), 16))); } /
  "\\" ch:. { return N('string', [], ch); }

array_literal "array literal" =
  "[" space? es:comma_separated_expressions? space? ","? space? "]" {
	return N('array', es ? es : []);
  }

comma_separated_expressions "comma-separated expressions" =
  e:expr_or_splice space? "," space? es:comma_separated_expressions {
	return N('expressions', [e]).concat(es);
  } /
  e:expr_or_splice { return N('expressions', [e]); }

expr_or_splice =
  e:expr { return e; } /
  s:splice { return s; }

splice "splice" =
  "*" space? e:expr { return N('splice', [e]); }

hash_literal "hash literal" =
  "{" space? es:comma_separated_kv? space? "}" {
	return N('hash', es ? es : []);
  }

comma_separated_kv "comma-separated kv" =
  k:expr space? ":" space? v:expr space? "," space? es:comma_separated_kv {
	return N('kv_list', [N('kv', [k,v])]).concat(es);
  } /
  k:expr space? ":" space? v:expr space? { return N('kv_list', [N('kv', [k,v])]); }

lambda "Lambda" =
  ("lambda" / "F") name:(space+ varname)? space? "(" space? params:parameters? space? ")" space? code:CCEXPR {
    return N('lambda', [params || N('parameters', []), code], name ? name[1].data : null);
  }

function_definition =
  "defun" space+ name:varname space? "(" space? params:parameters? space? ")" space? code:CCEXPR { return N('defun', [N('lambda', [params || N('parameters', []), code], name.data)], name.data); }

parameters "Function parameters list" =
  p:parameter space? "," space? ps:parameters {
    return N('parameters', [p]).concat(ps);
  } /
  p:parameter {
    return N('parameters', [p])
  }

parameter "Function parameter" =
  "*" v:varname { return N('arg_rest_pos', [], v.data); } /
  "**" v:varname { return N('arg_rest_kw', [], v.data); } /
  v:varname t:parameter_type? { return N('arg_pos', t ? [t] : [], v.data); }

parameter_type "Function parameter type" =
  space? ":" space? t:varname space? { return N('arg_type', [], t.data);  }

return "return" =
  "return" space e:expr { return N('ret', [e]); }

throw "throw" =
  "throw" space e:expr { return N('throw', [e]); }

function_call "function call" =
  do_catch:("catch" space?)? f:expr_base space? "(" space? args:comma_separated_expressions? space? ")" {
	return N('call', [f, args || N('expressions', [])], do_catch ? true : false);
  }

guard "Function entry guard" =
  "guard" space? e:expr { return N('guard', [e]); }

match "Match" =
  "match" space? "(" space? args:comma_separated_expressions? space? ")" space? "{" space? c:cases space? "}" {
    return N('match', [args || N('expressions', []), c])
  }
  
cases "Match case clauses" =
  c:case space? cs:cases {
    return N('cases', [c]).concat(cs);
  } /
  c:case {
    return N('cases', [c]);
  }

case "Case clause" =
  "(" space? params:parameters? space? ")" space? code:CCEXPR {
    return N('lambda', [params || N('parameters', []), code]);
  }
