{
	var N = require('./ast_node').ASTNode;
}

start = 
  commands

space = [ \t\n]+
inline_space = [ \t]+

commands "commands" =
  space? c:command space? [;] space? cs:commands {
	return N('commands', [c]).concat(cs);
  } /
  c:command space? [;]? space? { return N('commands', [c]); }

command "command" =
  CCEXPR_code /
  assignment " " command /
  assignment /
  if /
  async /
  execute_external_prog

// if CCEXPR [then] CCEXPR [else] [CCEXPR]
// ( while should be: if CCEXPR [then] CCEXPR [[else] CCEXPR] )
if "if" =
  'if' space? cond:CCEXPR space? 'then'? space? if_true:CCEXPR space? 'else'? space? if_false:CCEXPR? {
    return N('if', [cond, if_true]).push(if_false);
  }

async "async" =
  "async" space e:CCEXPR {
    return N('async', [e]);
  }

assignment "assignment" =
  varname:varname space? '=' space? val:expr { return N('assignment', [varname, val]); }

varname "variable name" =
  v:[_a-zA-Z]+[_0-9a-zA-Z]* { return N('varname', [], v.join('')); }

CCEXPR "CCEXPR" =
  CCEXPR_commands /
  CCEXPR_code

CCEXPR_commands =
  '(' commands:commands ')' space? { return commands; }

CCEXPR_code =
  '{' code:expr '}' space? { return code; }

// TODO fix expr_* order for operation precedence. Low priority at top.

expr "Expression/add" =
  e1:expr_call space? "+" space? e2:expr_call {
    return N('binop', [e1, e2], 'add');
  } /
  e:expr_call { return e; }


expr_call "Function call" =
  function_call /
  expr_base

expr_base "Expression/no-add" =
  if /
  assignment /
  function_definition /
  // function_call /
  return /
  number /
  string /
  varname /
  array_literal /
  CCEXPR_commands

number "number" =
  "0x" hex_digits:[0-9a-fA-F]+ { return N('number', [], parseInt(hex_digits.join(''), 16)); } /
  digits:[0-9]+ { return N('number', [], parseInt(digits.join(''), 10)); }

execute_external_prog "execute external program" =
  w:cmd_words { return N('exec', [w]); }

cmd_words "Command words" =
  w:cmd_word space ws:cmd_words  {
    return N('array', [w]).concat(ws);
  } /
  w:cmd_word { return N('array', [w]); }

cmd_word "Command word" =
  CCEXPR_code /
  "$" v:varname { return v; } /
  "$*" v:varname { return N('splice', [v]); } /
  s:string  { return s; } /
  w:[-_a-zA-Z0-9*?]+ {  return N('string', [], w.join('')); }

string "Command string" =
  '"' s:string_contents '"' {  return s; }

// Temp. TODO: add escaping and substitution
string_contents "String contents" =
  s:[-_a-zA-Z0-9*?]* {  return N('string', [], s.join('')); }

array_literal "array literal" =
  "[" space? es:comma_separated_expressions space? "]" {
	return N('array', [es]);
  }

comma_separated_expressions "comma-separated expressions" =
  e:expr_or_splice space? "," space? es:comma_separated_expressions {
	return N('expressions', [e]).concat(es);
  } /
  e:expr_or_splice { return N('expressions', [e]); }

expr_or_splice =
  e:expr { return e; } /
  s:splice { return s; }

splice "splice" =
  "*" space? e:expr { return N('splice', [e]); }

function_definition "Function definition" =
  "func" space? params:paremeters_list space? code:CCEXPR { return N('func', ['TODO:ARGS', code]); }

paremeters_list "Function parameters list" =
  "(" space? ")"

return "return" =
  "return" space? e:expr { return N('ret', [e]); }

function_call "function call" =
  f:expr_base space? "(" space? args:comma_separated_expressions? space? ")" space? {
	return N('call', [f, args]);
  }

