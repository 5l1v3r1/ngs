// ***************************************************
// Warning operators precedence is not handled yet !!!
// ***************************************************

{
	var N = require('./ast_node').ASTNode;
}

start = 
  commands
  // top_level_expressions

space = [ \t\n]+
inline_space = [ \t]+
newline_space = inline_space? [\n]+ inline_space?

commands "commands" =
  space? c:command commands_separator cs:commands {
	return N('commands', [c]).concat(cs);
  } /
  c:command commands_separator? { return N('commands', [c]); }

commands_separator "Command separator" =
  newline_space /
  inline_space? [;] inline_space?

command "command" =
  CCEXPR_code /
  assignment inline_space command /
  assignment /
  if /
  while /
  for /
  async /
  execute_external_prog

// if CCEXPR [then] CCEXPR [else] [CCEXPR]
// ( while should be: if CCEXPR [then] CCEXPR [[else] CCEXPR] )
// TODO: if not
if "if" =
  'if' space? cond:CCEXPR space? 'then'? space? if_true:CCEXPR space? 'else'? space? if_false:CCEXPR? {
    return N('if', [cond, if_true]).push(if_false);
  }

while "while" =
  // Experiemntal feature "not"
  "while" space? not:"not"? space? cond:CCEXPR space? body:CCEXPR {
    return N('while', [cond, body], not ? true : false);
  }

for "for" =
  // Experiemntal feature "not"
  "for" space? init:CCEXPR space? cond:CCEXPR space? incr:CCEXPR space? body:CCEXPR space? {
    return N('for', [init, cond, incr, body]);
  }

break "break" = "break" space? { return N('break', []); }
continue "continue" = "continue" space? { return N('continue', []); }

async "async" =
  "async" space e:CCEXPR {
    return N('async', [e]);
  }

assignment "assignment" =
  varname:varname space? '=' space? val:expr { return N('assignment', [varname, val]); }

varname "variable name" =
  v:[_a-zA-Z]+[_0-9a-zA-Z]* { return N('varname', [], v.join('')); }

CCEXPR "CCEXPR" =
  CCEXPR_commands /
  CCEXPR_code

CCEXPR_commands =
  space? '(' space? commands:commands space? ')' space? { return commands; }

CCEXPR_code =
  space? '{' space? code:top_level_expressions space? ";"? space? '}' space? {
    return code;
  }

top_level_expressions "semicolon separated top-level expressions" =
  e:expr top_level_expressions_delimiter es:top_level_expressions {
    return N('top_level_expressions', [e]).concat(es);
  } /
  e:expr { return N('top_level_expressions', [e]); }

top_level_expressions_delimiter =
  inline_space? ";" space? /
  space?

// ********************************************************************
// TODO fix expr_* order for operation precedence. Low priority at top.
// ********************************************************************

expr "Expression/eq" =
  e1:expr_add space? "==" space? e2:expr {
    return N('binop', [e1, e2], 'eq');
  } /
  e1:expr_add space? "<" space? e2:expr {
    return N('binop', [e1, e2], 'lt');
  } /
  e: expr_add

expr_add "Expression/add" =
  e1:expr_mul space? "+" space? e2:expr_add {
    return N('binop', [e1, e2], 'add');
  } /
  e1:expr_mul space? "-" space? e2:expr_add {
    return N('binop', [e1, e2], 'sub');
  } /
  e:expr_mul

expr_mul "Expression/mul" =
  e1:expr_call space? "*" space? e2:expr_call {
    return N('binop', [e1, e2], 'mul');
  } /
  e:expr_call


expr_call "Function call" =
  function_call /
  expr_base

expr_base "Expression/no-add" =
  if /
  while /
  for /
  break /
  continue /
  guard /
  type_definition /
  assignment /
  lambda /
  function_definition /
  return /
  number /
  string /
  "true" { return N('bool', [], true); } /
  "false" { return N('bool', [], false); } /
  "null" { return N('null', [], false); } /
  varname /
  array_literal /
  "(" space? e:expr space? ")" { return e; } /
  "$" cs:CCEXPR_commands { return cs; }

number "number" =
  "0x" hex_digits:[0-9a-fA-F]+ { return N('number', [], parseInt(hex_digits.join(''), 16)); } /
  digits:[0-9]+ { return N('number', [], parseInt(digits.join(''), 10)); }

execute_external_prog "execute external program" =
  w:cmd_words { return N('exec', [w]); }

cmd_words "Command words" =
  w:cmd_word inline_space ws:cmd_words  {
    return N('array', [w]).concat(ws);
  } /
  w:cmd_word { return N('array', [w]); }

cmd_word "Command word" =
  CCEXPR_code /
  "$" v:varname { return v; } /
  "$*" v:varname { return N('splice', [v]); } /
  s:string  { return s; } /
  w:[-_a-zA-Z0-9*?]+ {  return N('string', [], w.join('')); }

string "Command string" =
  '"' s:string_contents '"' {  return s; }

// Temp. TODO: add escaping and substitution
string_contents "String contents" =
  s:[-_a-zA-Z0-9*?]* {  return N('string', [], s.join('')); }

array_literal "array literal" =
  "[" space? es:comma_separated_expressions? space? "]" {
	return N('array', es ? es : []);
  }

comma_separated_expressions "comma-separated expressions" =
  e:expr_or_splice space? "," space? es:comma_separated_expressions {
	return N('expressions', [e]).concat(es);
  } /
  e:expr_or_splice { return N('expressions', [e]); }

expr_or_splice =
  e:expr { return e; } /
  s:splice { return s; }

splice "splice" =
  "*" space? e:expr { return N('splice', [e]); }

lambda "Lambda" =
  "lambda" space? "(" space? params:parameters space? ")" space? code:CCEXPR { return N('lambda', ['TODO:ARGS', code]); }

function_definition =
  "defun" space+ name:varname space? "(" space? params:parameters? space? ")" space? code:CCEXPR { return N('defun', [N('lambda', [params || N('parameters', []), code])], name.data); }

parameters "Function parameters list" =
  p:parameter space? "," space? ps:parameters {
    return N('parameters', [p]).concat(ps);
  } /
  p:parameter {
    return N('parameters', [p])
  }

parameter "Function parameter" =
  "*" v:varname { return N('arg_rest_pos', [], v.data); } /
  "**" v:varname { return N('arg_rest_kw', [], v.data); } /
  v:varname t:parameter_type? { return N('arg_pos', t ? [t] : [], v.data); }

parameter_type "Function parameter type" =
  space? ":" space? t:varname space? { return N('arg_type', [], t.data);  }

return "return" =
  "return" space? e:expr { return N('ret', [e]); }

function_call "function call" =
  f:expr_base space? "(" space? args:comma_separated_expressions? space? ")" space? {
	return N('call', [f, args || N('expressions', [])]);
  }

type_definition "Type definition" =
  "deftype" space+ type:varname space? "{" space? ds:type_fields_definitions? space? "}" space? {
    return N('deftype', ds || [], type.data);
  }

type_fields_definitions "Definitions of fields of a type" =
  d:type_field_definition space? ";" space? ds:type_fields_definitions space? space? {
    return N('fields_definitions', [d]).concat(ds);
  } /
  d:type_field_definition space? ";" ? {
    return N('fields_definitions', [d]);
  }

type_field_definition "Definition of a field of a type" =
  space? name:varname space? ":" space? type:varname space? {
    return N('field_definition', [], [name.data, type.data]);
  }

guard "Function entry guard" =
  "guard" space e:expr { return N('guard', [e]); }
