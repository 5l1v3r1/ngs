Addition
1+2
3

Local variable should not override global variable
x=1; def f() {x=2}; f(); x
1

Function parameter should not override global variable
x=1; def f(x) {100}; f(10); x
1

Set global variable in function
x=1; def f() { global x = 2 }; f(); x
2

Set global variable at top level
x=1; global x=2; x
2

Correct method implementation selection
def ms(s:String) { 1 }
def ms(n:Number) { 2 }
ms("")
1

Constants and a list
[true, false, null]
#(:true :false :null)

Define global method
def dodefine() {
	defg gmethod() {
		 3
	}
}
dodefine()
gmethod()
3

echo(String)
echo("echotest")
"echotest"

Lambda
f=F(x) { x + 10 }
f(1)
11

Method param test
defg m(x) { x + 10 }; m(1)
11

Array splice
a=[1,2]; [3,*a,4]
#(3 1 2 4)

Function arguments splice
a=[1,2]; defg f2(x,y) { [y,x] }; f2(*a)
#(2 1)

Function parameters splice
defg fps(x, *y) { y }; fps(1,2,3)
(list 2 3)

Parameters number match
def pnm(x,y) { 1 }
def pnm() { 2 }
def pnm(x) { 3 }
pnm(10,11)
1

String interpolation
x=1; y=2; "ab\x40\u0040\U00000040cd${x}ef${y+10}\t$y$"
"ab@@@cd1ef12	2$"

String non-interpolation
x=1; 'ab$x'
"ab$x"

Get attribute
Number.name
"Number"

Dot call
1.String()
"1"

Get list item
[10,20,30][1]
20

Get string character at index
"abc"[1]
"b"

Hash
h=Hash(); h[7]=8; h[7]
8

Hash with object key
h=Hash(); h[String]=10; h[String]
10

Meta - basics
String.meta()["xyz"] = "string-meta"
String.meta()["xyz"]
"string-meta"

Meta - stdlib
String.meta("xyz", 7); [String.meta("xyz"), String.has_meta("xyz"), String.has_meta("no-such-meta")]
#(7 :true :false)

not(Bool)
[not(true), not(false)]
#(:false :true)

__neq
__neq(1,2)
:true

String(Bool)
[true.String(), false.String()]
#("true" "false")

Number(Bool)
[true.Number(), false.Number()]
#(1 0)

min,max
[min(10,20), min(20,10), max(30,40), max(40, 30)]
#(10 10 40 40)

each(Number,F,*args)
summ = 0; 5.each(F(x,y) { global summ = summ + x + y}, 1000); summ
5010

map(Number,F,*args)
3.map(F(x,y) { x+y}, 1000)
#(1000 1001 1002)

File literal
f'/etc/motd'
#P"/etc/motd"

Regexp match - whole and groups
'abcdef' ~ /(..)(.).*/
(list "abcdef" "ab" "c")

Regexp match all
'a1b2c' ~~ /\\d/
(list "1" "2")

Regexp ignore case
'A' ~ /a/i
(list "A")

Regexp split
'ab:cd,ef'.split(/[:,]/)
(list "ab" "cd" "ef")

Try-catch
try { 1 throws 7 } catch(e:String) {2} catch(e:Number) {3} catch(e) {4}
3

JSON parse
from_json('[true, false, null, [], 1]')
#(:true :false :null #() 1)

Read and parse a file
read('./test/test.json') == {'did_it': true}
:true

While
a=0; r=[]; while a<3 {r.push(a); a=a+1}; r
#(0 1 2)

While/break
a=0
r=[]
while a<10 {
	r.push(a)
	if a == 2 { break }
	a=a+1
}
r
#(0 1 2)

While/continue
a=0
r=[]
while a<3 {
	a=a+1
	if a == 2 { continue }
	r.push(a)
}
r
#(1 3)

For
r=[]; for(a=0;a<3;a=a+1) { r.push(a+2) }; r
#(2 3 4)

For/break
r=[]
for(a=0;a<10;a=a+1) {
	r.push(a+2)
	if a == 2 { break }
}
r
#(2 3 4)

For/continue
r=[]
for(a=0;a<3;a=a+1) {
	if a == 1 { continue }
	r.push(a+2)
}
r
#(2 4)

finish(Process), Process#code
[$(true).finish().process.code, $(false).finish().process.code, $(sleep 1).process.code]
#(0 1 :null)

Bool(Process)
[Bool($(true)), Bool($(false))]
#(:true :false)

Guard
def gg(x:Number) { 1 }; def gg(x:Number) { guard x==20; 2 }; [gg(20), gg(10)]
#(2 1)

Automatic @ lambda
[1,2] @ X+1
#(2 3)

Flatten (includes @X)
[[1,2],[3,4]].flatten()
#(1 2 3 4)

map_star(Seq,F,*args)
[[1,2], [3,4]].map_star(@ X+Y+Z, 1000)
#(1003 1007)

reduce(Seq, start, F)
reduce([1,2,3], 10, @X+Y)
16

any
[ [1,2].any((==), 2), [1,2].any((==), 20) ]
#(:true :false)

all
[ [2,2].all((==), 2), [1,2].all((==), 2) ]
#(:true :false)

none
[ [1,1].none((==), 2), [1,2].none((==), 2) ]
#(:true :false)

all_in
[ [1,2].all_in([1,2]), [1,2].all_in([1,3]) ]
#(:true :false)

filter
[1,2,11,12].filter(@X>10)
#(11 12)

filter/null (includes @?)
[1,null,2].filter()
#(1 2)

without
[1,2,3].without(2)
#(1 3)

'[]'(Seq, Array)
[1,2,3][[0,2]]
#(1 3)

last(Seq) (includes '[]'(Seq, Number < 0))
[1,2,3].last()
3

String(String)
String('abc')
"abc"

fill (includes '*'(String, Number))
'ab'.fill(3)
"ab "

fill(Null, Number)
fill(null, 2)
"  "

strip(Seq) (includes strip(Seq,Seq))
' a \n\t'.strip()
"a"

'-'(String, String)
['abcd' - 'cd', 'abxy' - 'cd']
#("ab" "abxy")

literal w (is split/1, includes split/2)
w'ab cd ef'
#("ab" "cd" "ef")

Array math
[1,2]+2
#(3 4)

Array.X
[File('name1'), File('name2')].name
#("name1" "name2")

Hash
h={'a':1, 'b':2}; hh={'a':3, **h, 'b':4, 1:7}; [hh['a'], hh['b'], hh[1]]
#(1 4 7)

Hash(Array, v) (includes Hash(Array))
h=Hash(['a', 'b'], 7); [h['a'], h['b']]
#(7 7)

Hash(Array, F, *args)
h=Hash([1,2], @X+Y, 10); [h[1], h[2]]
#(11 12)

each(Hash, F, *args)
r=[]; {'a': 1}.each(F(k,v) { r.push(k); r.push(v) }); r
#("a" 1)

map(Hash, F, *args)
{'a': 1}.map(@[X,Y,Z], 7)
#(#("a" 1 7))

filter(Hash, F, *args)
h={'a': 1, 'b': 2}.filter(@X!='a'); [h['b'], h.len()]
#(2 1)

values(Hash)
{'a': 1}.values()
#(1)

without(Hash, k)
h={'a': 1, 'b': 2}.without('a'); [h['b'], h.len()]
#(2 1)

get(Hash, k, dflt)
h={'a': 1}; [h.get('a', 10), h.get('b', 11)]
#(1 11)

dflt(Hash, k, v)
h={'a': 1}; h.dflt('a', 10).dflt('b', 11); [h.get('a', 10), h.get('b', 11)]
#(1 11)

Bool(Hash)
[Bool({}), Bool({'a': 1})]
#(:false :true)

Set(), in(v, Set), push(Set, v)
s=Set(); s.push(7); [7 in s, 8 in s]
#(:true :false)

count(Set, F, *args)
[1,2,11,12,13].Set().count(@X>Y, 10)
3

Bool(Set), Set(Seq)
s1=Set(); s2=Set([1,2]); [Bool(s1), Bool(s2)]
#(:false :true)

Remove(Set, x)
s=Set([1]); s.remove(1); len(s)
0

without(Set, x)
Set([1,2,3]).without(1).len()
2

'-'(Set, Set), values(Set)
(Set([1,2,3]) - Set([1,2])).values()
#(3)

len(Set)
Set([1,2]).len()
2

'=='(Set, Set)
[Set(["a", 1]) == Set(["a", 1]), Set(["a", 1]) == Set(["a", 2])]
#(:true :false)

String(Set)
Set([1,2]).String()
"<Set [1, 2]>"

repr(Set) (includes String(Array))
Set([1,2, null]).repr()
"Set([null, 1, 2])"

join(Set, *args)
Set([1, 2, 3]).join('::')
"1::2::3"

Process output capture (includes String(Process))
x=[1,2]; `echo abc $*x`
"abc 1 2"

``command`` (includes call(F, *args))
``echo '{"a": 1}'`` == {'a': 1}
:true

DfltHash(v)
d = DfltHash(10); d[1]=2; [d[1], d[2]]
#(2 10)

DfltHash()
d = DfltHash(); d[1]=2; [d[1], d[2]]
#(2 :null)

Stats (includes as(x, Type))
s = Stats(); s.incr('my'); [s.keys(), s['my'], s['something']]
#(#("my") 1 0)

lines(File) (includes lines(String))
f=f'/tmp/lines-test'; f.store('a\nb\n'); f.lines()
#("a" "b")

read_till(Stream, String, Number)
read_till(Stream('ab:cd'), ':')
"ab"

String(File)
String(f'abc')
"abc"

Bool(File) (includes startsWith(Seq,Seq))
[Bool(f'/etc/passwd'), Bool(f'/no-such-file')]
#(:true :false)

repr(File) (inlcudes repr(String))
repr(f'/')
"File('/')"

zip(Seq, Seq)
zip([1,2], [3,4])
#(#(1 3) #(2 4))

one(Seq)
[[10].one(), try { [20,30].one() } catch (e) { 'OK' }]
#(10 "OK")

join(Seq)
[1,2].join()
"12"

endsWith(Seq, Seq)
['abcd'.endsWith('cd'), 'abcd'.endsWith('bc')]
#(:true :false)

each(Seq,F,*args)
summ = 0; [0,1,2,3,4].each(F(x,y) { global summ = summ + x + y}, 1000); summ
5010

map(Seq,F,*args)
[0,1,2].map(F(x,y) { x+y}, 1000)
#(1000 1001 1002)

each_star(Seq,F,*args)
summ = 0; [[1,2], [3,4]].each_star(@ global summ = summ + X + Y + Z, 1000); summ
2010

count(Seq, F, *args) (includes sum(Seq))
[1,2,11,12,13].count(@X>Y, 10)
3

values(Seq)
[1,2].values()
#(1 2)

Bool(Seq)
[[], [1]] @ Bool(X)
#(:false :true)

String(Hash)
{'a': 7}.String()
"{a: 7}"

math_op(Array, Number)
a=[1,2]
[a+3, a-1, a*2, a/0.25]
#(#(4 5) #(0 1) #(2 4) #(4 8))

'.'(Array,String)
[{'a': 1}, {'a': 2}].a
#(1 2)

'|'(*args)
[1,2] | @X*2
#(2 4)
