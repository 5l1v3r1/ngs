Addition
1+2
3

Local variable should not override global variable
x=1; def f() {x=2}; f(); x
1

Function parameter should not override global variable
x=1; def f(x) {100}; f(10); x
1

Set global variable in function
x=1; def f() { global x = 2 }; f(); x
2

Set global variable at top level
x=1; global x=2; x
2

Correct method implementation selection
def ms(s:String) { 1 }
def ms(n:Number) { 2 }
ms("")
1

Constants and a list
[true, false, null]
#(:true :false :null)

Define global method
def dodefine() {
	defg gmethod() {
		 3
	}
}
dodefine()
gmethod()
3

Echo
echo("echotest")
"echotest"

Lambda
f=F(x) { x + 10 }
f(1)
11

Method param test
defg m(x) { x + 10 }; m(1)
11

Array splice
a=[1,2]; [3,*a,4]
#(3 1 2 4)

Function arguments splice
a=[1,2]; defg f2(x,y) { [y,x] }; f2(*a)
#(2 1)

Function parameters splice
defg fps(x, *y) { y }; fps(1,2,3)
(list 2 3)

Parameters number match
def pnm(x,y) { 1 }
def pnm() { 2 }
def pnm(x) { 3 }
pnm(10,11)
1

String interpolation
x=1; y=2; "ab\x40\u0040\U00000040cd${x}ef${y+10}\t$y$"
"ab@@@cd1ef12	2$"

String non-interpolation
x=1; 'ab$x'
"ab$x"

Get attribute
Number.name
"Number"

Dot call
1.String()
"1"

Get list item
[10,20,30][1]
20

Get string character at index
"abc"[1]
"b"

Hash
h=Hash(); h[7]=8; h[7]
8

Hash with object key
h=Hash(); h[String]=10; h[String]
10

Meta - basics
String.meta()["xyz"] = "string-meta"
String.meta()["xyz"]
"string-meta"

Meta - stdlib
String.meta("xyz", 7); [String.meta("xyz"), String.has_meta("xyz"), String.has_meta("no-such-meta")]
#(7 :true :false)

Stdlib not
[not(true), not(false)]
#(:false :true)

Stdlib __neq
__neq(1,2)
:true

Stdlib String(Bool)
[true.String(), false.String()]
#("true" "false")

Stdlib Number(Bool)
[true.Number(), false.Number()]
#(1 0)

Stdlib min,max
[min(10,20), min(20,10), max(30,40), max(40, 30)]
#(10 10 40 40)

Stdlib each(Number,F,*args)
summ = 0; 5.each(F(x,y) { global summ = summ + x + y}, 1000); summ
5010

Stdlib map(Number,F,*args)
3.map(F(x,y) { x+y}, 1000)
#(1000 1001 1002)

File literal
f'/etc/motd'
#P"/etc/motd"

Regexp match - whole and groups
'abcdef' ~ /(..)(.).*/
(list "abcdef" "ab" "c")

Regexp match all
'a1b2c' ~~ /\d/
(list "1" "2")

Regexp split
'ab:cd,ef'.split(/[:,]/)
(list "ab" "cd" "ef")

Try-catch
try { 1 throws 7 } catch(e:String) {2} catch(e:Number) {3} catch(e) {4}
3

JSON parse
from_json('[true, false, null, [], 1]')
(list :true :false :null nil 1)
