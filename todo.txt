**************************************************************
* THE CONTENTS OF THIS FILE ARE BEING MOVED TO GITHUB ISSUES *
**************************************************************

Note that this started as internal document so things here are unformed, not final and fluid.

[roadmap]

	* Phase 6 - nice to have

		* Data manipulation
			* '.'(Iter, Str) -> AttrIter or alike maybe MappingIter or child
		* make ResDef ArrLike for the resources?
		* make Res HashLike?
		* last(?, predicate)
		* Consider Ref(h:Hash, k) and Ref(a:Arr, idx:Int)
		* add avg()
		* Address resolution functions
		* Consider somethig like data_strucure ~ [Capture("x"), 7 , "xx"]

		* dig with data_struct['a', 10, *, ...]
			* Not sure about the star, maybe:
				~All
				X ~ All

		* Function static variables
			F decode(s:Str, ...)
			?static? re = /myregex/
			guard s ~ re
			...
		* Completion-safe marker in scripts + completion protocol
		* ASN1 parser
		* while/for should return a value?
		* Consider having chunk() method as in Ruby

		* f'file literals'

		* Consider IP and subnet literals of the form:
			1.2.3.4
			1.2.3.4/8

		* Go over "TODO"s in all *.ngs files

		* Better start time

		* benchmarks - different tasks and languages
			+ There is one task benchmark in the Makefile (time-sum target)

		* RegExp
			* c_pcre_exec() - support options?
				PCRE_NOTBOL
				PCRE_NOTEOL
			* c_pcre_study()

		* implement decode() wherever possible (example: IPAddr, IPNet)
			+ allow auto-load missing implementations by extension and mime type

		* match, ematch - some way to get the match object?

			+ Check if match is used before doing this task. Currently there is not single usage of match construct.

			For example when RegExp is implmeneted in the code

				match mystring {
					/my_regex(.*)/ { my_code }
				}

			in my_code there should be access to the match object
			The syntax might be

				match mystring {
					/my_regex(.*)/ -> my_match { my_code }
				}

			or something alike, not sure yet.
			Maybe

				match my_string my_match {
					/my_regex(.*)/ { my_code }
				}

		* Destructuring. Automatically declare the variables local, as for does.
			+ Check whether really needed. Currently would fit OK in several places in stdlib when returning few values from C calls:
				result = c_something(...)
				... result[0] ...
				... result[1] ...
				...
			* [a,b=default,*some,c]
			* {'a','b':newvar,**some,'c'=default}
			+ Not sure about the syntax.
			+ Nested?
			+ Pattern matching like [a, *other1, 100, b, *other2] ?
				+ If yes, shouldn't the syntax be tilde (~) as for RegExp/Pfx/Sfx/... ?
			+ "xyz${myvar}www" = myvar syntax for regexes? ... for consistency.
			+ {[_, dst], **args} = h means also changing function arguments?

		* text templates (stdlib with builtin parse I guess)

		* K M G suffixes for numbers

		* Dynamic file names for use cases such as logger
			logger = DynFile('/var/log/...%h')
			logger.echo('my log event')

		* Channels - Chan type & syntax
			Initial syntax thoughts:

			1..10 | map(X*2) | sum | echo

			a = Chan()
			b = Chan()
			1..10 | group({A % 2 ==0 }, a, b)
			a | { echo("Even number $A") }
			b | sum | { echo("Sum of odd numbers: $A") }

			F map(in:Chan, out:Chan, mapper:Fun) {
				# while in(&item) ?
				while in -> item {
					# out(mapper(item)) ?
					out <- mapper(item)
				}
			}

		* Intern strings automatically (see Python algorithm)
			+ do profiling first

		* Optimize calling speed
			* Optimize obj_is_of_type()
			* Optimize vm_call matching algorithm
			* Optimize calling of unrelated methods
				+ such as F f(t:T1) and F f(t:T2) when T1 and T2 are unrelated types

		* Optimize so that namespace items access ("namespace::item") will not have Hash lookups

		* Consider augeas integration

		* Documentation
			* Comparison and link to https://github.com/RexOps/Rex

		* Conditional modification of value
			* Condition can be Fun/value
			* Replacement can be Fun/value
			Syntax for common pattern, somewhat analogous to only():
			newval = if my_cond then my_func(my_val) else my_val

		* Consider introducing AnyVal / AnyRef types. These do _not_ correspond to BasicType and NormalType.

[types]
	* Cloud / Compute / etc ?
	* Host
		+ ip?, public_ip, private_ip, other ips?
		+ image_id
		+ instance_id
		+ ssh_user()
		+ ssh_key()
		+ cloud type / endpoint / ... ?
	* HostsGroup
		+ refresh() or get()?
	* Widget
		+ Command
		+ Status
		+ Progress
		+ Pipes
	* HistoryEntry

[things to look at]

	* Look at ipython, books systems, bpython for ideas
	* Comparison to https://www.dmst.aueb.gr/dds/sw/dgsh/
	* Comparison to ipython
	* Take a look at Red programming language http://www.red-lang.org/p/documentation.html
	* Juju / conjure-up
