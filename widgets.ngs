# TODO: get rid of /dev/tty references all over the place

mktype('ScreenManager', 'Hash')

mktype('Widget', 'Hash')
mktype('OrigCmdWidget', 'Widget')
mktype('OutputWidget', 'Widget')
mktype('StdoutWidget', 'OutputWidget')
mktype('StderrWidget', 'OutputWidget')
mktype('ErrorWidget', 'Widget')

mktype('WidgetsSeq', 'Hash')

redraw_lock = Lock()

status_width = 5
spacer = ' ' * status_width

defun colored(s:String, c:String) { "${tput_cache["${c}_color"]}$s${tput_cache.sgr0}" }

defun OrigCmdWidget(cmd:String, time:String) {
	w = __super()
	w.cmd = cmd
	w.time = time
	w.exit_code = null
	w
}
defun height(w: OrigCmdWidget) { 1 }
defun echo(w:OrigCmdWidget) {
	err = false
	ok = false
	if w.exit_code == null {
		status = 'R'
	}
	if w.exit_code == 0 {
		status = 'OK'
		ok = true
	}
	if w.exit_code {
		status = w.exit_code.String()
		err = true
	}
	status = status.fill(status_width)
	if err {
		status = colored(status, 'error')
	}
	if ok {
		status = colored(status, 'success')
	}
	echo("$status--- ${w.cmd} --- ${w.time}${tput_cache.el}");
}

defun ErrorWidget(cmd:String) {w = __super(); w.cmd = cmd; w}
defun height(w: ErrorWidget) { 1 }
defun echo(w:ErrorWidget) { echo("${spacer}ERROR: ${w.cmd} ${tput_cache.el}"); }

defun WidgetsSeq() { ws = __super(); ws.items = []; ws}
defun push(ws:WidgetsSeq, x) { ws.items.push(x); ws }
defun height(ws:WidgetsSeq) { ws.items.map(height).sum() }
defun echo(ws:WidgetsSeq) { ws.items.each(echo); }

defun init(ow:OutputWidget) { ow.text = ''; ow }
defun colored(ow:OutputWidget, s:String) { s }
defun echo(ow:OutputWidget) {
	if not(ow.text) { return null }
	ow.text.lines().each(@echo("$spacer${ow.colored(X)}${tput_cache.el}"))
}
defun height(ow:OutputWidget) { ow.text.lines().len() }
defun height(ow:OutputWidget) { guard not(ow.text); 0 }

defun colored(ew:StderrWidget, s:String) { colored(s, 'error') }

defun ScreenManager(indev:Stream, outdev:Stream) {
	sm = __super()
	sm.init(indev, outdev)
	sm.widgets = []
	sm
}

defun init(sm:ScreenManager, indev:Stream, outdev:Stream) {
	sm.indev = indev
	sm.outdev = outdev
	# TODO: later: sm <- indev, outdev
	sm.updateDimensions()
	sm.rl = Readline()
	sm
}

defun read(sm:ScreenManager, prompt:String) {
	sm.rl.read(prompt)
}

defun updateDimensions(sm:ScreenManager) {
	sm.dims = getDimensions()
	sm
}

defun echo(sm:ScreenManager) {
	# TODO: Smarter, on demand, maybe partial screen update.
	# TODO: handle situations when cursor is now higher than the number of lines needed for widgets
	redraw_lock.acquire(F() {
		sm.rl.pause()
		pos = getCursorPosition()
		lines_count = sm.widgets.map(height).sum()
		setCursorPosition(pos[0] - lines_count, 0)
		sm.widgets.map(echo)
		setCursorPosition(*pos)
		sm.rl.resume()
	})
}

defun String(sm:ScreenManager) { "<ScreenManager id=${sm.id()} lines=${sm.dims[0]} cols=${sm.dims[1]}>" }

# --------------- Low level tty handling - start ---------------

defun getDimensions() {
	# TODO: check why does not work with stdin. Is it connected?
	# TODO: think how to get "dims = ..." line to be nearly short as bash alternative B

	# $(stty size -F /dev/tty).stdout.strip().split().map(Number)
	$(stty size -F /dev/tty).split().map(Number)

	# Bash alternative A:
	# t=`stty size -F /dev/tty`
	# lines=`echo "$t" | awk '{print $1}'`
	# cols=`echo "$t" | awk '{print $2}'`
	# Bash alternative B:
	# dims=($(stty size -F /dev/tty))
}

# Based on http://stackoverflow.com/questions/2575037/how-to-get-the-cursor-position-in-bash
defun getCursorPosition() {
	tty = f'/dev/tty'
	saved_stty=$(stty -F $tty -g)
	$(stty -F $tty raw -echo min 0)
	tty.write('\e[6n')
	# $(sleep '0.01')

	0.read_till('\e') # somewhat safer
	# IFS=';' read -r -d R -a pos;row=$((${pos[0]:2} - 1));col=$((${pos[1]} - 1))
	ret = 0.read_till('R').strip('\x00\e[').split(';').map(Number) - 1

	$(stty -F $tty $saved_stty)
	ret
}

defun setCursorPosition(line, col) { $(tput cup $line $col).stdout.write() }

# http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x405.html
tput_cache = ['el', 'sc', 'rc', 'smso', 'rmso', 'sgr0'].Hash(@ $(tput $X).String())
{
	tput_cache.error_color = $(tput setaf 1).String()   # red
	tput_cache.success_color = $(tput setaf 2).String() # green
}

# --------------- Low level tty handling - end ---------------
