# TODO: get rid of /dev/tty references all over the place

mktype('ScreenManager', 'Hash')

mktype('Widget', 'Hash')
mktype('OrigCmdWidget', 'Widget')
mktype('OutputWidget', 'Widget')
mktype('StdoutWidget', 'OutputWidget')
mktype('StderrWidget', 'OutputWidget')
mktype('ErrorWidget', 'Widget')

mktype('WidgetsSeq', 'Hash')

redraw_lock = Lock()

defun OrigCmdWidget(cmd:String) {w = __super(); w.cmd = cmd; w}
defun height(w: OrigCmdWidget) { 1 }
defun echo(w:OrigCmdWidget) { echo("--- ${w.cmd} ---"); }

defun ErrorWidget(cmd:String) {w = __super(); w.cmd = cmd; w}
defun height(w: ErrorWidget) { 1 }
defun echo(w:ErrorWidget) { echo("ERROR: ${w.cmd}"); }

defun WidgetsSeq() { ws = __super(); ws.items = []; ws}
defun push(ws:WidgetsSeq, x) { ws.items.push(x); ws }
defun height(ws:WidgetsSeq) { ws.items.map(height).sum() }
defun echo(ws:WidgetsSeq) { ws.items.each(echo); }

defun init(ow:OutputWidget) { ow.text = ''; ow }
defun echo(ow:OutputWidget) {
	if not(ow.text) { return null }
	ow.text.lines().map(echo)
}
defun height(ow:OutputWidget) { ow.text.lines().len() }
defun height(ow:OutputWidget) { guard not(ow.text); 0 }

defun ScreenManager(indev:Stream, outdev:Stream) {
	sm = __super()
	sm.init(indev, outdev)
}

defun init(sm:ScreenManager, indev:Stream, outdev:Stream) {
	sm.indev = indev
	sm.outdev = outdev
	# TODO: later: sm <- indev, outdev
	sm.updateDimensions()
	sm.rl = Readline()
	sm
}

defun read(sm:ScreenManager, prompt:String) {
	sm.rl.read(prompt)
}

defun updateDimensions(sm:ScreenManager) {
	sm.dims = getDimensions()
	sm
}

defun echo(sm:ScreenManager, widgets:Array) {
	redraw_lock.acquire(F() {
		sm.rl.pause()
		pos = getCursorPosition()
		lines_count = widgets.map(height).sum()
		widgets.map(echo)
		setCursorPosition(*pos)
		sm.rl.resume()
	})
}

defun String(sm:ScreenManager) {
	"<ScreenManager id=${sm.id()} lines=${sm.dims[0]} cols=${sm.dims[1]}>"
}

# --------------- Low level tty handling - start ---------------

defun getDimensions() {
	# TODO: check why does not work with stdin. Is it connected?
	# TODO: think how to get "dims = ..." line to be nearly short as bash alternative B

	# $(stty size -F /dev/tty).stdout.strip().split().map(Number)
	$(stty size -F /dev/tty).split().map(Number)

	# Bash alternative A:
	# t=`stty size -F /dev/tty`
	# lines=`echo "$t" | awk '{print $1}'`
	# cols=`echo "$t" | awk '{print $2}'`
	# Bash alternative B:
	# dims=($(stty size -F /dev/tty))
}

# Based on http://stackoverflow.com/questions/2575037/how-to-get-the-cursor-position-in-bash
defun getCursorPosition() {
	tty = f'/dev/tty'
	# defun stty(*args) { $(stty -F $tty $*args) }
	saved_stty=$(stty -F $tty -g)
	$(stty -F $tty raw -echo min 0)
	tty.write('\e[6n')
	$(sleep '0.01')

	0.read_till('\e') # somewhat safer
	# IFS=';' read -r -d R -a pos;row=$((${pos[0]:2} - 1));col=$((${pos[1]} - 1))
	# t = 0.read_till('R', 16)
	# ret = t.strip('\x00\e[').split(';').map(Number) - 1

	ret = 0.read_till('R').strip('\x00\e[').split(';').map(Number) - 1

	$(stty -F $tty $saved_stty)
	# echo("getCursorPosition -> ${ret}")
	# echo("READ TILL '$t'")
	ret
}

defun setCursorPosition(line, col) {
	$(tput cup $line $col)
}

# http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x405.html
tput_cache = ["el", "sc", "rc", "smso", "rmso"].Hash(F(x) { $(tput $x).stdout })

# --------------- Low level tty handling - end ---------------
