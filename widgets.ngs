# TODO: get rid of /dev/tty references all over the place

mktype('ScreenManager', 'Hash')

mktype('Widget', 'Hash')
mktype('OrigCmdWidget', 'Widget')
mktype('OutputWidget', 'Widget')
mktype('StdoutWidget', 'OutputWidget')
mktype('StderrWidget', 'OutputWidget')
mktype('ErrorWidget', 'Widget')

mktype('WidgetsSeq', 'Hash')

redraw_lock = Lock()

status_width = 5
spacer = ' ' * status_width

def colored(s:String, c:String) { "${tput_cache["${c}_color"]}$s${tput_cache.sgr0}" }

def OrigCmdWidget(cmd:String, time:String) {
	w = __super()
	w.cmd = cmd
	w.time = time
	w.exit_code = null
	w
}
def lines(w:OrigCmdWidget) {
	err = false
	ok = false
	if w.exit_code == null {
		status = 'R'
	}
	if w.exit_code == 0 {
		status = 'OK'
		ok = true
	}
	if w.exit_code {
		status = w.exit_code.String()
		err = true
	}
	status = status.fill(status_width)
	if err {
		status = colored(status, 'error')
	}
	if ok {
		status = colored(status, 'success')
	}
	["$status--- ${w.cmd} --- ${w.time}${tput_cache.el}"]
}

def ErrorWidget(cmd:String) {w = __super(); w.cmd = cmd; w}
def lines(w:ErrorWidget) { ["${spacer}ERROR: ${w.cmd} ${tput_cache.el}"] }

def WidgetsSeq() { ws = __super(); ws.items = []; ws}
def push(ws:WidgetsSeq, x) { ws.items.push(x); ws }
def lines(ws:WidgetsSeq) { ws.items.map(lines).flatten() }

def init(ow:OutputWidget) { ow.text = ''; ow }
def colored(ow:OutputWidget, s:String) { s }
def lines(ow:OutputWidget) {
	if not(ow.text) { return [] }
	ow.text.lines() @ "$spacer${ow.colored(X)}${tput_cache.el}"
}

def colored(ew:StderrWidget, s:String) { colored(s, 'error') }

def ScreenManager(indev:Stream, outdev:Stream) {
	sm = __super()
	sm.init(indev, outdev)
	sm.widgets = []
	sm
}

def init(sm:ScreenManager, indev:Stream, outdev:Stream) {
	sm.indev = indev
	sm.outdev = outdev
	# TODO: later: sm <- indev, outdev
	sm.updateDimensions()
	sm.rl = Readline()
	sm
}

def read(sm:ScreenManager, prompt:String) {
	sm.rl.read(prompt)
}

def updateDimensions(sm:ScreenManager) {
	sm.dims = getDimensions()
	sm
}

prev_lines = []
def echo(sm:ScreenManager) {
	# TODO: Only redraw updated lines
	# TODO: handle situations when cursor is now higher than the number of lines needed for widgets
	redraw_lock.acquire(F() {
		l = sm.widgets.map(lines).flatten()
		if l == prev_lines {
			return null
		}
		prev_lines = l
		sm.rl.pause()
		pos = getCursorPosition()
		setCursorPosition(pos[0] - l.len(), 0)
		l.each(echo)
		setCursorPosition(*pos)
		sm.rl.resume()
	})
}

def String(sm:ScreenManager) { "<ScreenManager id=${sm.id()} lines=${sm.dims[0]} cols=${sm.dims[1]}>" }

# --------------- Low level tty handling - start ---------------

def getDimensions() {
	# TODO: check why does not work with stdin. Is it connected?
	# TODO: think how to get "dims = ..." line to be nearly short as bash alternative B

	# $(stty size -F /dev/tty).stdout.strip().split().map(Number)
	$(stty size -F /dev/tty).split().map(Number)

	# Bash alternative A:
	# t=`stty size -F /dev/tty`
	# lines=`echo "$t" | awk '{print $1}'`
	# cols=`echo "$t" | awk '{print $2}'`
	# Bash alternative B:
	# dims=($(stty size -F /dev/tty))
}

# Based on http://stackoverflow.com/questions/2575037/how-to-get-the-cursor-position-in-bash
def getCursorPosition() {
	tty = f'/dev/tty'
	saved_stty=$(stty -F $tty -g)
	$(stty -F $tty raw -echo min 0)
	tty.write('\e[6n')
	# $(sleep '0.01')

	0.read_till('\e') # somewhat safer
	# IFS=';' read -r -d R -a pos;row=$((${pos[0]:2} - 1));col=$((${pos[1]} - 1))
	ret = 0.read_till('R').strip('\x00\e[').split(';').map(Number) - 1

	$(stty -F $tty $saved_stty)
	ret
}

def setCursorPosition(line, col) { $(tput cup $line $col).stdout.write() }

# http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x405.html
tput_cache = ['el', 'sc', 'rc', 'smso', 'rmso', 'sgr0'].Hash(@ $(tput $X).String())
{
	tput_cache.error_color = $(tput setaf 1).String()   # red
	tput_cache.success_color = $(tput setaf 2).String() # green
}

# --------------- Low level tty handling - end ---------------
